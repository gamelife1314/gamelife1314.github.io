---
title: 【Golang】汇编语言
date: 2022-03-01 11:27:32
categories:
    - golang
mathjax: true
---

汇编语言是最接近机器代码的人类可读语言，通过阅读汇编代码，我们可以了解到自己所编写的高级语言代码最终生成的指令都是什么，以便更好的掌握高级语言和了解计算机系统。Go 语言的汇编器基于 [Plan9 汇编器](https://9p.io/sys/doc/asm.html)，并且在此基础之上定义了一些创新。

{% asset_img bg.png 汇编代码 %}

<!-- more -->

### X86-64 汇编

在学习 Go 语言的汇编语法之前，先大致了解下基于 `X86-64` 系列处理器的汇编语言，`X86-64` 是最常见的 Intel 处理器系列，普遍应用于桌面电脑和服务器中，本节的内容大都总结于《深入理解计算机系统》这本书。

#### 示例

演示一段简单的C代码生成的汇编指令。假设我们写了一个 C 语言代码文件，`mstore.c`，它包含如下的函数定义：

```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

使用如下的指令生成汇编代码，汇编代码会保存在 `mstore.s` 中：

> gcc -Og -S mstore.c

其内容位：

```
[root@ecs-335906 ~]# cat mstore.s
	.file	"mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (GNU) 8.5.0 20210514 (Red Hat 8.5.0-4)"
	.section	.note.GNU-stack,"",@progbits
```

我们也可以使用 `-c` 命令行选项，编译并汇编该段代码，这会生成一个二进制文件 `mstore.o`，我们可以使用 `GDB` 调试工具查看 `multstore` 生成的汇编指令：

```
[root@ecs-335906 ~]# gdb mstore.o
...
(gdb) x/14xb multstore
0x0 <multstore>:	0x53	0x48	0x89	0xd3	0xe8	0x00	0x00	0x00
0x8 <multstore+8>:	0x00	0x48	0x89	0x03	0x5b	0xc3
(gdb) disa
disable      disassemble
(gdb) disassemble multstore
Dump of assembler code for function multstore:
   0x0000000000000000 <+0>:	push   %rbx
   0x0000000000000001 <+1>:	mov    %rdx,%rbx
   0x0000000000000004 <+4>:	callq  0x9 <multstore+9>
   0x0000000000000009 <+9>:	mov    %rax,(%rbx)
   0x000000000000000c <+12>:	pop    %rbx
   0x000000000000000d <+13>:	retq
End of assembler dump.
(gdb)
```

或者使用反汇编工具将二进制文件翻译成汇编代码格式：

```
[root@ecs-335906 ~]# objdump -d mstore.o

mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	callq  9 <multstore+0x9>
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	retq
[root@ecs-335906 ~]#
```

我们可以看到 `multstore` 函数编译成二进制文件之后，占据了 `14` 字节，反汇编工具将它们分成了 `6` 组，每组 `1~5` 个字节不等，每组都是一条指令，右边是等价的汇编语言。其中一些关于机器代码和它的反汇编表示的特性值得注意：

- x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的子节数少，而那些不太常用或操作数较多的指令所需字节数较多。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 `pushg %rbx` 是以字节值 `53` 开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的 `q`。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 `call` 和 `ret` 指令添加了 `q` 后缀，同样，省略这些后缀也没有问题。

以 `.` 开头的都是指导汇编器和链接器工作的伪指令，去除它们之后，我们可以看到 `multstore` 函数转换成汇编语言之后的指令位：

```
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	ret
```

我们常用的 `GCC`，`OBJDUMP` 生成的汇编代码是 `ATT`（根据 `AT&T` 命名，它是运营贝尔实验室多年的公司） 格式，有些 `Microsoft` 生成的格式是 `Intel` 的，这两种格式在许多方面有所不同，例如，我们可以用下面的指令生成 `multstore` 函数的 Intel 格式的汇编代码：

> gcc -Og -S -masm=intel mstore.c

```
multstore:
	push	rbx
	mov	rbx, rdx
	call	mult2
	mov	QWORD PTR [rbx], rax
	pop	rbx
	ret
```

#### 数据格式

大多数GCC生成的汇编代码都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种：`movb`（传送字节），`movw`（传送字），`movl`（传送双字） 以及 `movq`（传送四字）。汇编代使用后缀 `l`表示4字节整数和8字节双精度浮点数，这不会产生歧义，因为浮点数使用的一组完全不同的指令和寄存器。

Intel 派系中，“字（Word）”表示16位数据类型，因此，32位称之为 “双字”，64位称之为 “四字”。下表给出C语言数据类型和对应的 X86-64 表示。

|C声明|Intel 数据类型|汇编代码后缀|大小（字节）|
|:--:|:--:|:--:|:--:|
|char|字节|b|1|
|short|字|w|2|
|int|双字|l|4|
|long|四字|q|8|
|char*|四字|q|8|
|float|单精度|s|4|
|double|双精度|l|8|

#### 寄存器

一个 X86-64 的CPU包含一组16个存储64位值得通用目的寄存器，这些寄存器可以用来存储整数数据和指针。名称都是以 `%r` 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集烟花而来的。最初 8086 CPU 有8个16位的寄存器，即 `%ax ~ %sp`，每个寄存器都有特殊的用途。扩展到 IA32架构时，这些寄存器也扩展成32位的，标号从 `%eax ~ %esp`。扩展到 X86-64 之后，原来的8个寄存器扩展成64位，标号从 `%rax ~ %rsp`，除此之外，还增加了8个新的寄存器，它们的标号是按照新的命名规则制定的：从 `%r8 ~ %r15`。

在常见的程序里，不同的寄存器扮演着不同的角色，其中最特别的是栈指针：`%rsp`，用来指明运行时栈的结束为止，约定的用途如下：

![所有16个寄存器的低位部分都可以作为字节，字（16位），双字（32位），四字（64位）来访问](registers.png)

有很多指令能用于复制生成1字节，2字节，4字节和8字节的值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩余的字节会被按照以下两条规则处理：

- 生成1字节和2字节数字的指令，会保持剩下的字节不变；
- 生成4字节数字的指令，会把高位4字节置为0；

#### 操作数

大多数指令有一个或者多个操作数（operand），指示处执行一个操作中要使用的源数据值，以及放置结果的目标位置。X86-64 支持多种数据格式，源数据可以是常数值，或者从寄存器或者内存中读出，而结果呢可以放在寄存器或者内存中，因此各种不同的操作数可以分为三种类型：`立即数`，`寄存器`， `内存引用`。

##### 立即数

在ATT密码格式中，立即数的表示是 `$` 后面跟一个用标准C表示法的表示的整数。比如 `%-577` 或者 `$0x1F`。不同的指令允许的立即数范围不同，汇编器会自动选择最紧凑的方式进行数值编码。

##### 寄存器

寄存器表示寄存器中的内容，所有16个寄存器中的1字节，2字节，4字节或者8字节中一个作为操作数，这些字节数分别对应于8位，16位，32位或者64位。我们用表示 $r_a$ 表示任意寄存器 `a`，用引用 $R[r_a]$ 表示它的值，这是将寄存器看成一个数组 `R`，用寄存器标识符作为索引。

##### 内存引用

内存引用根据计算出来的地址（通常称为有效地址）访问某个内存位置。通常情况下，我们将内存看成一个大的字节数组，因此用符号 $M_b[Addr]$ 表示对存储在内存中从地址 `Addr` 开始的 `b` 个字节值的引用，为了方便，通常省去下标 `b`，最常用的内存引用表示形式是 $Imm(r_b,r_i,s)$ ，这里的引用有四个组成部分：
- `Imm`：立即数偏移；
- $r_b$：基址寄存器，必须是64位寄存器；
- $r_i$：变址寄存器，必须是64位寄存器；
- `s`：比例因子，必须是 `1`，`2`，`4`，或者 `8`，编译器根据源代码中数组的类型来确定比例因子，`char` 类型是 `1`，`int` 类型是 `4`，`double` 类型是8。

有效地址被计算为：$Imm + R[r_b] + R[r_i] · s$，引用数组元素时，会用到通用模式，其他形式都是这种通用形式的特殊情况，省略了某些部分而已，有关计算机寻址方式可以查看：

- [基址加变址寻址方式-百度百科](https://baike.baidu.com/item/%E5%9F%BA%E5%9D%80%E5%8A%A0%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/6686487)
- [寻址模式-维基百科](https://zh.wikipedia.org/wiki/%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F)

下面的表格给出常用的操作数类型机器含义：

|类型|格式|操作数值|名称|
|:--:|:--:|:--:|:--:|
|立即数|`$Imm`|`Imm`|立即数值|
|寄存器|$r_a$|$R[r_a]$|寄存器寻址|
|存储器|`Imm`|`M[Imm]`|绝对寻址|
|存储器|$(r_a)$|$M[R[r_a]]$|间接寻址|
|存储器|$Imm(r_b)$|$M[Imm+R[r_b]]$|(基址+偏移量)寻址|
|存储器|$(r_b,r_i)$|$M[R[r_b]+R[r_i]]$|变址寻址|
|存储器|$Imm(r_b,r_i)$|$M[Imm+R[r_b]+R[r_i]]$|变址寻址|
|存储器|$(,r_i,s)$|$M[R[r_i]·s]$|比例变址寻址|
|存储器|$Imm(,r_i,s)$|$M[Imm+R[r_i]·s]$|比例变址寻址|
|存储器|$(r_b,r_i,s)$|$M[R[r_b]+R[r_i]·s]$|比例变址寻址|
|存储器|$Imm(r_b,r_i,s)$|$M[Imm+R[r_b]+R[r_i]·s]$|比例变址寻址|

#### 数据传送

汇编代码中最常见的就是数据传送指令，经常需要将数据从一个位置复制到另外一个位置。操作数表示的通用性使得一条简单的数据传送指令能够许多机器中好几条不同的指令才能完成的功能。最简单的数据传送指令是 `MOV` 类，这些指令把数据从源位置复制到目的位置，不能做任何变化。`MOV` 类指令主要由四条指令组成：`movb`，`movw`，`movl` 以及 `movq`，这些指令执行同样的操作，区别在于它们传送的数据大小不同，分别是：`1`，`2`，`4` 和 `8` 字节。

|指令|效果|描述|
|:--:|:--:|:--:|
|`MOV S, D`|`D<-S`|传送|
|`movb`||传送字节|
|`movw`||传送字|
|`movl`||传送双字|
|`movq`||传送四字|
|`movabsq I, R`|`R<-I`|传送绝对四字|

源操作数指定的是一个立即数，存储在寄存器或者内存中，目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。**`X86-64` 添加了一条限制，传送指令两个操作数不能都指向内存地址**，所以要在内存之间传送数据，就需要两次操作。

大多数情况下， `MOV` 指令大多数情况下，只会更新目的操作数指定的那些寄存器或者内存位置，根据指令最后一个字符指定的大小，例如每次 `movb` 指令只会更新一个字节，`movw` 更新双字16个字。有个例外就是 **`movl` 指令以寄存器位目的地址时，它会把寄存器的高4字节置为0（X86-64惯例）**。

下面是几个数据传送的指令：

- `movl $0x4050, %eax`&emsp;&emsp;&emsp;    立即数->寄存器，4字节
- `movw %bp, %sp`&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;       寄存器->寄存器，2字节
- `movb (%rdi, %rcx), %al`&emsp;      内  存->寄存器，1字节
- `movb ($-17, (%rsp))`&emsp;&emsp;&nbsp;&nbsp;  立即数->内  存，1字节
- `movq %rax, -12(%rbp)`&emsp;&emsp; 寄存器->内  存，8字节

除此之外，**`movq` 指令只能以表示32位补码数字的立即数位源操作数，然后把这个值符号扩展到64位的值，放到目的位置**。而 **`movabsq` 指令能够以任何64位立即数值作为源操作数，并且只能以寄存器作为目的**。

还有两类寄存器，在移动数据时能够对符号位进行扩展，**`MOVZ` 类中的指令把目的剩余字节填充位0，而 `MOVS` 类中的指令通过符号扩展来填充，把源操作数的最高位进行赋值**，这两类指令最后两个字符都是大小指示符，第一个字符指定源操作数的大小，第二个指定目的大小。

|指令|效果|描述|
|:--:|:--:|:--:|
|`MOVZ S, R`|`D<-S（零扩展）`|以零扩展进行传送|
|`movzbw`||将做了零扩展的字节传送到字|
|`movzbl`||将做了零扩展的字节传送到双字|
|`movzwl`||将做了零扩展的字传送到双字|
|`movzbq`||将做了零扩展的字节传送到四字|
|`movzwq`||将做了零扩展的字传送到四字|

或者

|指令|效果|描述|
|:--:|:--:|:--:|
|`MOVZ S, R`|`D<-S（符号扩展）`|以传送符号扩展的字节|
|`movsbw`||将做了符号扩展的字节传送到字|
|`movsbl`||将做了符号扩展的字节传送到双字|
|`movswl`||将做了符号扩展的字传送到双字|
|`movsbq`||将做了符号扩展的字节传送到四字|
|`movswq`||将做了符号扩展的字传送到四字|

下面是一段 `C` 代码的示例生成的汇编代码：

{% tabs 数据传送指令示例 %}

<!-- tab 源代码 -->

```c
long exchange(long *xp, long y) {
    long x = *xp;
    *xp = y;
    return x;
}
```
<!-- endtab -->

<!-- tab 汇编代码 -->

根据约定，参数 `xp` 和 `y` 分别存储在寄存器 `%rdi` 和 `%rsi` 中，返回值存储在 `%rax` 中。先将 `xp` 中的值放到 `%rax` 中返回，然后将 `y` 的值放到  `xp` 指向的内存地址。

```asm
exchange:
	movq	(%rdi), %rax
	movq	%rsi, (%rdi)
	ret
```
<!-- endtab -->

{% endtabs %}

#### 压栈和出栈

栈在处理函数（过程）调用中起到至关重要的作用，栈是一种数据结构，可以添加或者删除，遵循**后进先出**的原则。通过 `push` 操作将数据压入栈中，通过 `pop` 操作删除数据，因此，弹出的值永远是最近被压入而且仍然在栈中的值。

在实现上，栈可以以数组的形式实现，总是从数据的一段插入和删除元素，这一端称为 **栈顶**。在 `x86-64` 中，程序栈放在内存中的某个区域，栈是从高地址向低地址增长，栈顶元素的地址是所有栈元素地址中最低的。

|指令|效果|描述|
|:--:|:--:|:--:|
|`pushq S`|`R[%rsp]<-R[%rsp]-8`；`M[R[%rsp]] <- S`|将四字压入栈|
|`popq  D`|`D<-M[R[%rsp]]`；`R[%rsp]<-R[%rsp]+8`|将四字弹出栈|

`pushq` 的功能是将数据压入到栈上，而 `popq` 指令是弹出数据，这些指令都只有一个操作数，压入的数据和弹出的数据目的地。

`pushq` 在压栈之前，首先要将栈指针减8，然后将数据写到栈顶位置，因此，指令 `pushq %rbp`的行为等于下面两条指令：

```
    subq %8, %rsp
    movq %rbp, (%rsp)
```

由于压栈和出栈操作太频繁，所以用一个单独的指令实现，减小最终生成的二进制文件体积。因为，上面两条指令在机器代码中占用8个字节，而 pushq 只需要1个字节。

![压栈和出栈](pushq_popq.png)

`x86-64` 中，栈的方向是向低地址增长，所以压栈是减小栈指针（`%rsp`）的值，并将数据存储到内存中，而出栈是从内存中读取数据，并增加栈的指针。

#### 算数和逻辑操作

下面的表格列出了一些整数和逻辑操作，大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种。指令类 `ADD` 由四条加法指令组成：`addb`，`addw`，`addl` 和 `addq`，下面给出的每个指令都有对这四种不同大小数据的变种（除 `leaq` 之外），这些指令被分成四组：加载有效地址，一元操作，二元操作和移位。

|指令|效果|描述|
|:--:|:--:|:--:|
|`leaq S, D`|`D<-&S`|加载有效地址|
|`INC D`|`D <-  D+1`|加1|
|`DEC D`|`D <-  D-1`|减1|
|`NEG D`|`D <-  - D`|取负|
|`NOT D`|`D <-  ~ D`|取补|
|`ADD S, D`|`D <-  D + S`|加|
|`SUB S, D`|`D <-  D - S`|减|
|`IMUL S, D`|`D <- D * S`|乘|
|`XOR  S, D`|`D <- D ^ S`|异或|
|`OR   S, D`|`D <- D | S`|或|
|`AND  S, D`|`D <- D & S`|与|
|`SAL  k, D`|`D <- D << k`|左移|
|`SHL  k, D`|`D <- D << k`|左移（等同于 `SAL`）|
|`SAR  k, D`|`D <- D >>`$_A$ `k`|算数右移|
|`SHR  k, D`|`D <- D >>`$_L$ `k`|逻辑右移|

##### 加载有效地址

`leaq`（加载有效地址）指令实际上是 `movq` 指令的变形，它的指令形式是从内存读取数据到寄存器，但实际上根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但是该指令实际上并不从指定位置读取数据，而是将有效地址写入到目的操作数。

除此之外，它还可以简单的描述普通的算数操作，例如，如果寄存器 `%rdx` 的值为 `x`，那么指令 `leaq 7(%rdx, %rdx, 4), %rax` 将设置寄存器 `%rax` 的值为 `7 + (x + x * 4) = 5x + 7`，编译器经常会使用 `leaq` 的一些灵活用法，看下面的示例代码：

```c
long scale(long x, long y, long z) {
    long t = x + 4 * y + 12 * z;
    return t;
}
```

`%rdi = x, %rsi = y, %rdx = z, %rax = t`，编译之后的汇编代码位：

```
scale:
	leaq	(%rdi,%rsi,4), %rax      // x + 4 * y
	leaq	(%rdx,%rdx,2), %rcx      // z + 2 * z = 3z
	leaq	0(,%rcx,4), %rdx         // (x + 4 * y) + 4 * (3 * z) = x + 4 * y + 12 * z
	addq	%rdx, %rax
	ret
```

##### 一元操作和二元操作

一元操作，及时源又是目的，这个操作数可以是寄存器，也可以是内存位置。例如，`incq (%rsp)` 会使栈顶的8字节元素加1，这种语法类似于C语言的`++` 和 `--` 从操作。

二元操作中，第二个操作数既是源又是目的，类似于C语言中的 `-=`，`+=`，`*=` 运算操作符。例如，`subq %rax, %rdx` 是将寄存器 `%rdx` 减去 `%rax` 的结果保存在 `%rdx` 中，第一个操作数可以使立即数，寄存器或是任意内存位置，第二个操作数可以是寄存器或是内存位置。

##### 移位操作

移位操作，先给出移位量，然后第二项给出的是要移位的数，可以进行算数和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器 `%cl` 中（这些指令很特别，只允许以这个特定的寄存器作为操作数）。原则上来说，1字节的移位量使得移位量的编码范围可以达到 $2^8-1=255$。

`x86-64` 中，移位操作对 `w` 位长的数据值进行操作，移位量由 `%cl` 寄存器的低 `m` 位决定，这里 $2^m=w$，高位会被忽略。所以，当寄存器 `%cl` 的十六进制位 `%0xFF` 时，指令 `salb` 会移 `7` 位，`salw` 会移 `15` 位，`sall` 会移 `31` 位，`salq` 会移 `63` 位。

左移指令有两个名字：`SAL` 和 `SHL`，两者的效果是一样的，都是讲右边填上0。右移指令不同， `SAR` 执行算数移位（填上符号位），而 `SHR` 执行逻辑移位（填上0）。移位操作的目的操作数可以是一个寄存器或者一个内存位置。


### 参考链接

1. [A Quick Guide to Go's Assembler](https://go.dev/doc/asm)
2. [第3章 Go汇编语言](https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html)
3. [Golang Calling Convention](https://particle.cafe/blog/golang-calling-convention.html)
4. [数学公式语法——Mathjax教程](https://oysz2016.github.io/post/8611e6fb.html)

