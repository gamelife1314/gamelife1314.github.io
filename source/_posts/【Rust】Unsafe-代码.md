---
title: 【Rust】Unsafe 代码
date: 2022-05-05 14:37:24
tags:
  - Unsafe
  - 《Rust 程序设计》
categories:
  - rust
---

系统编程的秘密乐趣在于，在每一种安全语言和精心设计的抽象之下，都存在着极其`unsafe`的机器语言和小技巧，我们也可以用 `Rust` 来写。

到目前为止，我们介绍的语言可确保程序通过类型、生命周期、边界检查等完全自动地避免内存错误和数据竞争，但是这种自动推断有其局限性，有许多有价值的技术手段是无法被 `Rust` 认可的。             

`Unsafe` 代码告诉 `Rust`，程序选择使用它无法保证安全的特性。通过将代码块或函数标记为 `Unsafe`，可以获得调用标准库中的`unsafe`函数、解引用`unsafe`指针以及调用用其他语言（如 `C` 和 `C++`）编写的函数以及其他能力。 

这种跳出安全 `Rust` 边界的能力使得在 `Rust` 中实现许多 `Rust` 最基本的功能成为可能，就像`C`和`C++`用来实现自己的标准库一样。`Unssafe` 代码允许 `Vec` 有效地管理其缓冲区、`std::io` 能直接和操作系统对话、以及提供并发原语的 `std::thread` 和 `std::sync` 。

本节介绍了使用`unsafe`功能的要点：

- `Rust` 的 `Unsafe` 块在安全的 `Rust` 代码和使用`unsafe`特性的代码之间建立了界限；

- 可以将函数标记为`unsafe`，提醒调用者存他们必须遵守的额外规范以避免未定义的行为；

- 原生指针及其方法允许不受限制地访问内存，并允许构建 `Rust` 类型系统原本禁止的数据结构。尽管 `Rust` 的引用是安全但受约束的，但正如任何 `C` 或 `C++` 程序员所知道的，原生指针是一个强大而锋利的工具；

- 了解未定义行为将帮助理解为什么它会产生比仅仅得到错误结果更严重的后果；

- `unsafe`的`Trait`，类似于`unsafe`的函数，强加了每个实现必须遵循的契约；

<!-- more -->

### 示例

下面这段程序在原书中说是运行会崩溃，但是在我自己的电脑上并未发生，就当它崩溃了吧。（我的 `Rust` 版本是 `rustc 1.62.0-nightly`）

```rust
fn main() {
    let mut a: usize = 0;
    let ptr = &mut a as *mut usize;
    unsafe {
        *ptr.offset(3) = 0x7000;
    }
}
```

该程序借用了对局部变量 `a` 的可变引用，将其转换为 `*mut usize` 类型的原始指针，然后使用 `offset` 方法在内存中生成一个指针，新指针等于 `ptr + 3 * size_of::<uszie>()`。按原书说这恰好是存储 `main` 的返回地址的地方（这其实得看 `Rust` 的调用规约了）。程序用一个常量覆盖了返回地址，这样从 `main` 中返回的行为就令人惊讶。导致这次崩溃的原因是程序对`unsafe`特性的错误使用，在这里就是滥用解引用原生指针的能力。

一个`unsafe`的特性是会有一个使用规约：但是 `Rust` 不能自动强制执行，所以必须遵循这些规约以避免未定义的行为。

`Unsafe` 代码能跳过常规的类型检查和生命周期检查，但增加了更多的使用规约。通常，`Rust` 本身根本不知道这些规约，它们只是在该功能的文档中进行了解释。例如，原始指针类型有一个规约，禁止解引用已超出其原来范围的指针，此示例中的表达式 `*ptr.offset(3) = ...` 违反了此约定。但是，`Rust` 依然编译了程序：它的安全检查没有检测到这种违规行为。当使用`unsafe`的功能时，作为程序员，有责任检查代码是否符合他们的规约。

许多功能都有正确使用它们应该遵循的规则，但这些规则不是我们在这里所说的意义上的规约，除非可能的后果包括未定义的行为。未定义的行为是 `Rust` 坚信你的代码永远不会出现的行为，例如，`Rust` 假设你不会用其他东西覆盖函数调用的返回地址。通过 `Rust` 的安全检查并遵守非安全功能规约的代码不可能做这样的事情。由于该程序违反了原始指针规约，它的行为是未定义的，所以出错了。

如果代码出现了未定义的行为，`Rust` 就无法保证代码会执行到哪里了，也无法保证结局，更无法保证安全。可能报告出一对不相关的错误消息然后崩溃，或者系统的控制权让出给其他程序，而且不同的 `Rust` 版本之间也不保证一致，也不会存在告警。

只能在`unsafe`代码块或`unsafe`函数中使用`unsafe`的功能；我们将在接下来的部分中解释这两个。这使得无意间使用`unsafe` 很困难：通过强制编写一个`unsafe`的块或函数，`Rust` 确保开发者已经承的代码可能需要遵循额外的规约。

