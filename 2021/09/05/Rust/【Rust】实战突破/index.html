<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta name="google-site-verification" content="lk2gSYFP_NyLNFob-fFnt7fm-I_n1ZYws-WZll7mshg">
  <meta name="msvalidate.01" content="6Jdc01DjYOLguhS5">
  <meta name="baidu-site-verification" content="code-NR10G09zww">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7Ccursive:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/yellow/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.fudenglong.site","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":800},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/local-search.xml","localsearch":{"enable":true,"top_n_per_article":10,"unescape":false,"preload":true,"trigger":"auto"}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script>

    <meta name="description" content="Rust 是一门赋予每个人构建可靠且高效软件能力的语言。   Rust 相比其他语言，具有显著的特点，尤其是：   性能高；Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。   高可靠；Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。   极具生产力">
<meta property="og:type" content="article">
<meta property="og:title" content="【Rust】实战突破">
<meta property="og:url" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/index.html">
<meta property="og:site_name" content="MichaelFu">
<meta property="og:description" content="Rust 是一门赋予每个人构建可靠且高效软件能力的语言。   Rust 相比其他语言，具有显著的特点，尤其是：   性能高；Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。   高可靠；Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。   极具生产力">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/why-is-rust-programmng-language-so-popular-fi.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/closure-convert-to-fn-failed.PNG">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/string-not-implement-copy.PNG">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/drop_trait.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/vec-over-panic.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/recursive-list.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/rct-example.svg">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/rct-example-failed.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/refcell-mock-failed.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/refcell-mock-failed-again.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/refcell-mock-pass.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/rct-and-refcellt.png">
<meta property="article:published_time" content="2021-09-05T13:08:01.000Z">
<meta property="article:modified_time" content="2021-09-05T13:08:01.000Z">
<meta property="article:author" content="MichaelFu">
<meta property="article:tag" content="rust基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/why-is-rust-programmng-language-so-popular-fi.png">


<link rel="canonical" href="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/","path":"2021/09/05/Rust/【Rust】实战突破/","title":"【Rust】实战突破"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>【Rust】实战突破 | MichaelFu</title>
  







<script async src="/lib/fireworks.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MichaelFu</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好记性不如烂笔头</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-云-&nbsp;&nbsp;原-&nbsp;&nbsp;生"><a href="/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="section"><i class="fa fa-cloud fa-fw"></i>云 &nbsp;&nbsp;原 &nbsp;&nbsp;生</a></li><li class="menu-item menu-item-rust-编程"><a href="/Programming-Rust/" rel="section"><i class="fa fa-cat fa-fw"></i>Rust 编程</a></li><li class="menu-item menu-item-go-&nbsp;&nbsp;&nbsp;编程"><a href="/Programming-Go/" rel="section"><i class="fa fa-hippo fa-fw"></i>Go &nbsp;&nbsp;&nbsp;编程</a></li><li class="menu-item menu-item-前端知识"><a href="https://wshuhua.github.io/" rel="section" target="_blank"><i class="fa fa-sun fa-fw"></i>前端知识</a></li><li class="menu-item menu-item-leetcode-rust"><a href="/Leetcode-Rust/" rel="section"><i class="fa fa-book fa-fw"></i>Leetcode-Rust</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text"> 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#loop"><span class="nav-number">1.1.</span> <span class="nav-text"> loop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if-let"><span class="nav-number">1.2.</span> <span class="nav-text"> if let</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while-let"><span class="nav-number">1.3.</span> <span class="nav-text"> while let</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text"> 零类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#match"><span class="nav-number">3.</span> <span class="nav-text"> match</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.1.</span> <span class="nav-text"> 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%AB%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.2.</span> <span class="nav-text"> 卫语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A"><span class="nav-number">3.3.</span> <span class="nav-text"> @ 绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text"> 解构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">3.5.</span> <span class="nav-text"> 指针和引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%8D%E9%A9%B3%E6%80%A7"><span class="nav-number">3.6.</span> <span class="nav-text"> 可反驳性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text"> 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">5.</span> <span class="nav-text"> 闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.1.</span> <span class="nav-text"> 简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F"><span class="nav-number">5.2.</span> <span class="nav-text"> 捕获变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E5%85%A5%E5%8F%82"><span class="nav-number">5.3.</span> <span class="nav-text"> 作为入参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">5.4.</span> <span class="nav-text"> 作为返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">5.5.</span> <span class="nav-text"> 函数指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trait"><span class="nav-number">6.</span> <span class="nav-text"> Trait</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%85%B3%E8%81%94%E5%8F%82%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text"> 默认类型和关联参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text"> 完全限定语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.</span> <span class="nav-text"> 自定义实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.4.</span> <span class="nav-text"> 默认实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">6.5.</span> <span class="nav-text"> 作为参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="nav-number">6.6.</span> <span class="nav-text"> 作为返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">6.7.</span> <span class="nav-text"> 有条件地实现方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6-trait"><span class="nav-number">6.8.</span> <span class="nav-text"> 父 trait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-clone"><span class="nav-number">6.9.</span> <span class="nav-text"> Copy、Clone</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#copy"><span class="nav-number">6.9.1.</span> <span class="nav-text"> Copy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#clone"><span class="nav-number">6.9.2.</span> <span class="nav-text"> Clone</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fn-fnmut-fnonce"><span class="nav-number">6.10.</span> <span class="nav-text"> Fn、FnMut、FnOnce</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#fnonce"><span class="nav-number">6.10.1.</span> <span class="nav-text"> FnOnce</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fnmut"><span class="nav-number">6.10.2.</span> <span class="nav-text"> FnMut</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fn"><span class="nav-number">6.10.3.</span> <span class="nav-text"> Fn</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deref-derefmut"><span class="nav-number">6.11.</span> <span class="nav-text"> Deref、DerefMut</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%BC%95%E7%94%A8%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.11.1.</span> <span class="nav-text"> 隐式引用强制转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%BC%95%E7%94%A8%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">6.11.2.</span> <span class="nav-text"> 隐式引用强制转换与可变性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drop"><span class="nav-number">6.12.</span> <span class="nav-text"> Drop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF"><span class="nav-number">7.</span> <span class="nav-text"> 错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#panic%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF"><span class="nav-number">7.1.</span> <span class="nav-text"> panic!，不可恢复错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#result%E5%8F%AF%E6%81%A2%E5%A4%8D%E9%94%99%E8%AF%AF"><span class="nav-number">7.2.</span> <span class="nav-text"> Result，可恢复错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E4%BC%A0%E6%92%AD"><span class="nav-number">7.3.</span> <span class="nav-text"> 错误传播</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.4.</span> <span class="nav-text"> ? 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#option"><span class="nav-number">7.5.</span> <span class="nav-text"> Option</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.6.</span> <span class="nav-text"> 定义错误类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#boxerrorerror"><span class="nav-number">7.7.</span> <span class="nav-text"> Box&lt;error::Error&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.</span> <span class="nav-text"> 类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#from-into"><span class="nav-number">8.1.</span> <span class="nav-text"> From、Into</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tryfrom-tryinto"><span class="nav-number">8.2.</span> <span class="nav-text"> TryFrom、TryInto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tostring-fromstr"><span class="nav-number">8.3.</span> <span class="nav-text"> ToString、FromStr</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">9.</span> <span class="nav-text"> 泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">10.</span> <span class="nav-text"> 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#boxt-%E6%8C%87%E5%90%91%E5%A0%86%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">10.1.</span> <span class="nav-text"> Box 指向堆上的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E4%B8%8A"><span class="nav-number">10.1.1.</span> <span class="nav-text"> 数据存储在堆上</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.1.2.</span> <span class="nav-text"> 创建递归类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rct-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">10.2.</span> <span class="nav-text"> Rc 引用计数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-rct-%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">10.2.1.</span> <span class="nav-text"> 使用 Rc&lt;T&gt; 共享数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rcstrong_count"><span class="nav-number">10.2.2.</span> <span class="nav-text"> Rc::strong_count</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#refcell"><span class="nav-number">10.3.</span> <span class="nav-text"> RefCell</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E5%90%88-rct-%E5%92%8C-rccellt"><span class="nav-number">10.3.1.</span> <span class="nav-text"> 结合 Rc&lt;T&gt; 和 RcCell&lt;T&gt;</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MichaelFu"
      src="/avatar.jpeg">
  <p class="site-author-name" itemprop="name">MichaelFu</p>
  <div class="site-description" itemprop="description">实践能让记忆更深刻</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gamelife1314" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gamelife1314" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:michael.fudenglong@qq.com" title="E-Mail → mailto:michael.fudenglong@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://www.rust-lang.org/zh-CN/" title="https:&#x2F;&#x2F;www.rust-lang.org&#x2F;zh-CN&#x2F;" rel="noopener" target="_blank">Rust</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://go.dev/" title="https:&#x2F;&#x2F;go.dev&#x2F;" rel="noopener" target="_blank">Golang</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.python.org/" title="https:&#x2F;&#x2F;www.python.org&#x2F;" rel="noopener" target="_blank">Python</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://doc.rust-lang.org/cargo/index.html" title="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;index.html" rel="noopener" target="_blank">Cargo</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://gist.github.com/rxaviers/7360908" title="https:&#x2F;&#x2F;gist.github.com&#x2F;rxaviers&#x2F;7360908" rel="noopener" target="_blank">Emoji</a>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpeg">
      <meta itemprop="name" content="MichaelFu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MichaelFu">
      <meta itemprop="description" content="实践能让记忆更深刻">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="【Rust】实战突破 | MichaelFu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Rust】实战突破
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-05 21:08:01" itemprop="dateCreated datePublished" datetime="2021-09-05T21:08:01+08:00">2021-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>52k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>47 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote class="blockquote-center">
<p><code>Rust</code> 是一门赋予每个人构建可靠且高效软件能力的语言。</p>

</blockquote>
<p><code>Rust</code> 相比其他语言，具有显著的特点，尤其是：</p>
<ol>
<li>
<p>性能高；<code>Rust</code> 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</p>
</li>
<li>
<p>高可靠；<code>Rust</code> 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</p>
</li>
<li>
<p>极具生产力；<code>Rust</code> 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</p>
</li>
</ol>
<img data-src="/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/why-is-rust-programmng-language-so-popular-fi.png" class="" title="why rust so popular">
<span id="more"></span>
<h3 id="表达式"><a class="markdownIt-Anchor" href="#表达式"></a> 表达式</h3>
<h4 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> <code>loop</code></h4>
<p>不同于其他语言，<code>rust</code> 的 <code>loop</code> 循环是可以返回值的，因为 <code>loop</code> 循环是一个表达式，表达式可以求值，这样就可以作为赋值语句使用，如下示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if-let"><a class="markdownIt-Anchor" href="#if-let"></a> <code>if let</code></h4>
<p>由于 <code>match</code> 模式匹配必须要指出所有的可能性，所以在使用上不是很优雅，因此有了 <code>if let</code>，可以说它是 <code>match</code> 的语法糖，可以按需只匹配自己想要的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value is &#123;&#125;&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rust 中的 None 值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(n) = none &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value is &#123;&#125;&quot;</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value is none&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="while-let"><a class="markdownIt-Anchor" href="#while-let"></a> while let</h4>
<p>同 <code>if let</code> 类似，<code>while let</code> 可以简化代码的书写方式，使得呈现上更加优雅。</p>
<div class="tabs" id="loop-and-while-let"><ul class="nav-tabs"><li class="tab"><a href="#loop-and-while-let-1">loop match</a></li><li class="tab active"><a href="#loop-and-while-let-2">while let</a></li></ul><div class="tab-content"><div class="tab-pane" id="loop-and-while-let-1"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> number &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> value &gt; <span class="number">9</span> &#123;</span><br><span class="line">                    number = <span class="literal">None</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    number = <span class="title function_ invoke__">Some</span>(value + <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;number is &#123;:?&#125;&quot;</span>, number);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is none: &#123;&#125;&quot;</span>, number.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane active" id="loop-and-while-let-2"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = number &#123;</span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">9</span> &#123;</span><br><span class="line">            number = <span class="literal">None</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            number = <span class="title function_ invoke__">Some</span>(value + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;number is &#123;:?&#125;&quot;</span>, number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is none: &#123;&#125;&quot;</span>, number.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="零类型"><a class="markdownIt-Anchor" href="#零类型"></a> 零类型</h3>
<p><code>rust</code> 中某些类型的是不占用任何内存的，享受 <code>rust</code> 为他们提供的优化，我们可以用标准库提供的 <code>std::mem::size_of_val</code> 函数进行测量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">R</span>(<span class="type">i16</span>),</span><br><span class="line">    <span class="title function_ invoke__">G</span>(<span class="type">i16</span>),</span><br><span class="line">    <span class="title function_ invoke__">B</span>(<span class="type">i16</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该枚举等价于，所以他们可以被当做函数使用</span></span><br><span class="line"><span class="comment">// fn Color::R(c: i16) -&gt; Color &#123; /* ... */ &#125;</span></span><br><span class="line"><span class="comment">// fn Color::G(c: i16) -&gt; Color &#123; /* ... */ &#125;</span></span><br><span class="line"><span class="comment">// fn Color::B(c: i16) -&gt; Color &#123; /* ... */ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 同样一个函数，我们再赋值给一个变量时，在指定函数指针类型时，占用8个字节</span></span><br><span class="line">    <span class="comment">// 不指定时，为函数项类型，占用0字节，函数项类型在必要时可以自动转化为函数指针类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add</span> = add;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_ptr</span>: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>, <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = add;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add size: &#123;&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;add)); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add_ptr size: &#123;&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;add_ptr)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举项占用的大小也是0</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Color::B size: &#123;&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;Color::B)); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="match"><a class="markdownIt-Anchor" href="#match"></a> match</h3>
<p><code>rust</code>提供<code>match</code>关键字用于模式匹配，类似于其他语言中的<code>switch</code>，不同的是<code>match</code>必须列出所有可能情况。</p>
<h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// match 分支必须覆盖所有可能的情况</span></span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        <span class="comment">// 可以匹配单个值</span></span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One&quot;</span>),</span><br><span class="line">        <span class="comment">// 可以匹配多个值</span></span><br><span class="line">        <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;2 -&gt; 5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还可以匹配一个范围</span></span><br><span class="line">        <span class="number">6</span>..=<span class="number">10</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;6 -&gt; 10&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;others&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不仅如此，<code>match</code> 还可以用于解构枚举<code>enum</code>，下面是一个复杂的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举值相互嵌套</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>, r, g, b)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,</span><br><span class="line">                h, s, v</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配剩下所有的情况</span></span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>match</code> 在匹配到第一个条件之后，不会再往下匹配：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">match</span> pair &#123;</span><br><span class="line">        <span class="comment">// 只会匹配到这里</span></span><br><span class="line">        (<span class="number">0</span>, y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;First is `0` and `y` is `&#123;:?&#125;`&quot;</span>, y),</span><br><span class="line">        (x, <span class="number">0</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;`x` is `&#123;:?&#125;` and last is `0`&quot;</span>, x),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="卫语句"><a class="markdownIt-Anchor" href="#卫语句"></a> 卫语句</h4>
<p><code>match</code> 模式匹配可以加上 <code>if</code>条件语句来过滤分支，提供更加灵活的匹配方式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = (<span class="number">2</span>, -<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">match</span> pair &#123;</span><br><span class="line">        (x, y) <span class="keyword">if</span> x + y == <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; == 0&quot;</span>, x, y),</span><br><span class="line">        (x, y) <span class="keyword">if</span> x == y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x == y&quot;</span>),</span><br><span class="line">        (x, y) <span class="keyword">if</span> x % y == <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; % &#123;&#125; == 0&quot;</span>, x, y),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="绑定"><a class="markdownIt-Anchor" href="#绑定"></a> @ 绑定</h4>
<p><code>match</code> 提供了 <code>@</code> 运算符用于将值绑定到变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">age</span>() <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_number</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Tell me type of person you are&quot;</span>);</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">age</span>() &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m not born yet I guess&quot;</span>),</span><br><span class="line">        <span class="comment">// 可以直接 `match` 1 ..= 12，但怎么把岁数打印出来呢？</span></span><br><span class="line">        <span class="comment">// 相反，在 1 ..= 12 分支中绑定匹配值到 `n` 。现在年龄就可以读取了。</span></span><br><span class="line">        n @ <span class="number">1</span>..=<span class="number">12</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m a child of age &#123;:?&#125;&quot;</span>, n),</span><br><span class="line">        n @ <span class="number">13</span>..=<span class="number">19</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m a teen of age &#123;:?&#125;&quot;</span>, n),</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">        n =&gt; <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;m an old person of age &#123;:?&#125;&quot;</span>, n),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以用于枚举</span></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">some_number</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n @ <span class="number">42</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The Answer: &#123;&#125;!&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Not interesting... &#123;&#125;&quot;</span>, n),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解构"><a class="markdownIt-Anchor" href="#解构"></a> 解构</h4>
<p>解构可以非常方便地从一个结构体或者元组中提取某个字段或者全部：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        x: (<span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">        y: <span class="type">u32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解构结构体的成员，字段x是一个元组，分别解析到a，b；字段y解析到y</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo</span> = Foo &#123; x: (<span class="number">1</span>, <span class="number">2</span>), y: <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Foo</span> &#123; x: (a, b), y &#125; = foo;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;,  y = &#123;&#125; &quot;</span>, a, b, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以解构结构体并重命名变量，成员顺序并不重要；将y解析成i；x解析成j；</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Foo</span> &#123; y: i, x: j &#125; = foo;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;i = &#123;:?&#125;, j = &#123;:?&#125;&quot;</span>, i, j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以忽略某些变量，只解析y，忽略x</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Foo</span> &#123; y, .. &#125; = foo;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针和引用"><a class="markdownIt-Anchor" href="#指针和引用"></a> 指针和引用</h4>
<p>对指针来说，解构（<code>destructure</code>）和解引用（<code>dereference</code>）要区分开，因为这两者的概念 是不同的，和 C 那样的语言用法不一样。</p>
<ul>
<li>解引用使用 <code>*</code></li>
<li>解构使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 获得一个 `i32` 类型的引用。`&amp;` 表示取引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference</span> = &amp;<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> reference &#123;</span><br><span class="line">        <span class="comment">// 如果用 `&amp;val` 这个模式去匹配 `reference`，就相当于做这样的比较：</span></span><br><span class="line">        <span class="comment">// `&amp;i32`（译注：即 `reference` 的类型）</span></span><br><span class="line">        <span class="comment">//    |</span></span><br><span class="line">        <span class="comment">// `&amp;val`（译注：即用于匹配的模式）</span></span><br><span class="line">        <span class="comment">// ^ 我们看到，如果去掉匹配的 `&amp;`，`i32` 应当赋给 `val`。</span></span><br><span class="line">        <span class="comment">// 译注：因此可用 `val` 表示被 `reference` 引用的值 4。</span></span><br><span class="line">        &amp;val =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a value via destructuring: &#123;:?&#125;&quot;</span>, val),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不想用 `&amp;`，需要在匹配前解引用。</span></span><br><span class="line">    <span class="keyword">match</span> *reference &#123;</span><br><span class="line">        val =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a value via dereferencing: &#123;:?&#125;&quot;</span>, val),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一开始就不用引用，会怎样？ `reference` 是一个 `&amp;` 类型，因为赋值语句</span></span><br><span class="line">    <span class="comment">// 的右边已经是一个引用。但下面这个不是引用，因为右边不是。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_not_a_reference</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。</span></span><br><span class="line">    <span class="comment">// 下面这行将得到一个引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref</span> _is_a_reference = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mut_value</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 `ref` 关键字来创建引用。</span></span><br><span class="line">    <span class="comment">// 译注：下面的 r 是 `&amp;i32` 类型，它像 `i32` 一样可以直接打印，因此用法上</span></span><br><span class="line">    <span class="comment">// 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能</span></span><br><span class="line">    <span class="comment">// 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解</span></span><br><span class="line">    <span class="comment">// 引用。</span></span><br><span class="line">    <span class="keyword">match</span> value &#123;</span><br><span class="line">        <span class="keyword">ref</span> r =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got a reference to a value: &#123;:?&#125;&quot;</span>, r),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似地使用 `ref mut`。</span></span><br><span class="line">    <span class="keyword">match</span> mut_value &#123;</span><br><span class="line">        <span class="keyword">ref</span> <span class="keyword">mut</span> m =&gt; &#123;</span><br><span class="line">            <span class="comment">// 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。</span></span><br><span class="line">            *m += <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;We added 10. `mut_value`: &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&amp;</code> 和 <code>ref</code> 都表示获取引用，只是一个出现在表达式左边一个出现在右边，当 <code>&amp;</code> 出现在右边的时候等价于 <code>ref</code> 出现在左边，<code>&amp;</code> 出现在左边的时候等价于 <code>*</code> 出现在右边：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(core_intrinsics)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;<span class="literal">false</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &amp;x = &amp;<span class="literal">false</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref</span> x = &amp;<span class="literal">false</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = &amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> &amp;y = x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = *x;</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(x);</span><br><span class="line">    <span class="title function_ invoke__">print_type_name_of</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_type_name_of</span>&lt;T&gt;(_: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123; std::intrinsics::type_name::&lt;T&gt;() &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;bool</span><br><span class="line">bool</span><br><span class="line">&amp;&amp;bool</span><br><span class="line">&amp;i32</span><br><span class="line">i32</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://users.rust-lang.org/t/ref-keyword-versus/18818/2"><code>https://users.rust-lang.org/t/ref-keyword-versus/18818/2</code></a></p>
<h4 id="可反驳性"><a class="markdownIt-Anchor" href="#可反驳性"></a> 可反驳性</h4>
<p>模式有两种形式：<code>refutable</code>（可反驳的）和 <code>irrefutable</code>（不可反驳的）。能匹配任何传递的可能值的模式被称为是不可反驳的（<code>irrefutable</code>），反之，对某些可能的值进行匹配会失败的模式被称为是可反驳的（<code>refutable</code>）。</p>
<p>举个例子，<code>let x = 5;</code> 中的 <code>x</code> 可以匹配任何值不会失败，所以称为不可反驳。<code>if let Some(x) = a_value</code> 中，如果 <code>a_value</code> 是 <code>None</code>，那么这个表达式就匹配不上，所以称为可反驳。</p>
<p>为什么有这么个模式？因为，函数参数，<code>let</code>，<code>for</code> 只能接收不可反驳的模式，也就是说只允许匹配成功，是一种确定性操作。而 <code>if let</code>，或者 <code>while let</code> 表达式被限制为只能接收可反驳的模式，也就是说他们允许出现匹配不上，即匹配失败的情况，再者说，他们的出现就是为了处理成功和失败这两种情况。下面的这段代码就会<mark class="label danger">编译失败</mark>，因为没有处理 <code>a_value</code> 为 <code>None</code> 的情况，<code>let</code> 也处理不了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a_value</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Some</span>(x) = a_value;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于此，<code>match</code> 匹配分支必须使用可反驳模式，除了最后一个分支需要使用能匹配任何剩余值的不可反驳模式。<code>Rust</code> 允许我们在只有一个匹配分支的 <code>match</code> 中使用不可反驳模式，不过这么做不是特别有用，并可以被更简单的 <code>let</code> 语句替代。</p>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<p>方法通常用于和函数对比，和函数的区别是方法附着于对象，方法分为静态方法和实例方法，静态方法常用语构造对象，实例方法中通过关键字 <code>self</code> 来引用对象中的数据。</p>
<div class="tabs" id="静态方法和实例方法"><ul class="nav-tabs"><li class="tab active"><a href="#静态方法和实例方法-1">静态方法</a></li><li class="tab"><a href="#静态方法和实例方法-2">实例方法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="静态方法和实例方法-1"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法，返回原点</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">origin</span>() <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定坐标构造</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = Point::<span class="title function_ invoke__">origin</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">other</span> = Point::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="静态方法和实例方法-2"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// &amp;self 其实是 self: &amp;Self 的语法糖，表示不可变引用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &amp;mut self 其实是 self: &amp;mut Self, 表示可变引用</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">plus_one</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.width += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">self</span>.height += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self 直接将所有权转移</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">transfer</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rec</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">1</span>,</span><br><span class="line">        height: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rectangle &#123;:?&#125;, area is: &#123;&#125;&quot;</span>, rec, rec.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">    rec.<span class="title function_ invoke__">plus_one</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rectangle &#123;:?&#125;, area is: &#123;&#125;&quot;</span>, rec, rec.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rec1</span> = rec.<span class="title function_ invoke__">transfer</span>();</span><br><span class="line">    <span class="comment">// rec; // 编译失败，rec 的所有权已经转移至 rec1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h3>
<p>闭包是函数式编程中不可获取的一员，<code>rust</code> 对此也提供了支持，也叫 <code>lambda</code>，能够捕获环境中的变量，例如：</p>
<blockquote>
<p><code>|val| val + x</code></p>
</blockquote>
<h4 id="简单示例"><a class="markdownIt-Anchor" href="#简单示例"></a> 简单示例</h4>
<p>这种超级简便的语法使得它在临时使用时非常方便，输入和返回值类型都可以自行推导，但是必须指定输入参数名称。在声明参数是，同函数不同，它是使用 <code>||</code> 而不是 <code>()</code> 将参数包裹起来；另外们对于单个表达式的闭包，<code>&#123;&#125;</code> 是可以省略的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b) = (<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">// 捕获变量 b</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">plus_b_closure</span> = |input| input + b;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">plus_one</span> = |x| x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">plus_b_fn</span>(input: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        input + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a + b = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">plus_b_closure</span>(a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a + b = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">plus_b_fn</span>(a, b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">plus_one</span>(a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a + 1 = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">plus_one</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="捕获变量"><a class="markdownIt-Anchor" href="#捕获变量"></a> 捕获变量</h4>
<p>闭包会自动满足函数功能的要求，使得闭包不需要类型说明就可以工作。这允许变量捕获（<code>capture</code>）灵活地适应使用场合，既可移动（<code>move</code>）又可借用（<code>borrow</code>）变量。闭包可以通过：<code>引用 &amp;T</code>， <code>可变引用 &amp;mut T</code>，<code>值 T</code>  自动捕获变量，也可以通过 <code>move</code> 强制获得变量的所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">color</span> = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    <span class="comment">// 这个闭包打印 `color`。它会立即借用（通过引用，`&amp;`）`color` 并将该借用和</span></span><br><span class="line">    <span class="comment">// 闭包本身存储到 `print` 变量中。`color` 会一直保持被借用状态直到 `print` 离开作用域。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">print</span> = || <span class="built_in">println!</span>(<span class="string">&quot;`color`: &#123;&#125;&quot;</span>, color);</span><br><span class="line">    <span class="title function_ invoke__">print</span>();</span><br><span class="line">    <span class="title function_ invoke__">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这个闭包使 `count` 值增加。要做到这点，它需要得到 `&amp;mut count` 或者</span></span><br><span class="line">    <span class="comment">// `count` 本身。`inc` 前面需要加上 `mut`，因为闭包里存储着一个 `&amp;mut` 变量。</span></span><br><span class="line">    <span class="comment">// 调用闭包时，该变量的变化就意味着闭包内部发生了变化。因此闭包需要是可变的。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inc</span> = || &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;`count`: &#123;&#125;&quot;</span>, count);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">inc</span>();</span><br><span class="line">    <span class="title function_ invoke__">inc</span>();</span><br><span class="line">    <span class="comment">// 不能再次获得 count 的可变引用，因为前面的闭包中已经借用一次了</span></span><br><span class="line">    <span class="comment">// let reborrow = &amp;mut count;</span></span><br><span class="line">    <span class="comment">// reborrow += 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可复制类型（non-copy type）。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">movable</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// `mem::drop` 要求 `T` 类型本身，所以闭包将会捕获变量的值。这种情况下，</span></span><br><span class="line">    <span class="comment">// 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动</span></span><br><span class="line">    <span class="comment">// （move）到闭包中，因而 `movable` 变量在这里立即移动到了闭包中。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume</span> = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;`movable`: &#123;:?&#125;&quot;</span>, movable);</span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(movable);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// `consume` 消耗了该变量，所以该闭包只能调用一次。</span></span><br><span class="line">    <span class="title function_ invoke__">consume</span>();</span><br><span class="line">    <span class="comment">// consume();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 move 关键字强制将 numbers 的所有权移动到闭包中</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contains</span> = <span class="keyword">move</span> |needle| numbers.<span class="title function_ invoke__">contains</span>(needle);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;numbers include 1 ? &#123;&#125;&quot;</span>, <span class="title function_ invoke__">contains</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;numbers include 4 ? &#123;&#125;&quot;</span>, <span class="title function_ invoke__">contains</span>(&amp;<span class="number">5</span>));</span><br><span class="line">    <span class="comment">// 由于 numbers 的所有权已经被移入 contains 中，所以这里不能再使用</span></span><br><span class="line">    <span class="comment">// println!(&quot;numbers length is &#123;&#125;&quot;, numbers.len());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作为入参"><a class="markdownIt-Anchor" href="#作为入参"></a> 作为入参</h4>
<p>虽然闭包可以自动做类型推断，但是在编写函数以闭包作为参数时，还是得必须明确指定类型，可以通过以下三个之一来指定闭包捕获变量的类型，他们的受限程度依次递减：</p>
<ul>
<li><code>Fn</code>：表示捕获方式为通过引用（<code>&amp;T</code>）的闭包</li>
<li><code>FnMut</code>：表示捕获方式为通过可变引用（<code>&amp;mut T</code>）的闭包</li>
<li><code>FnOnce</code>：表示捕获方式为通过值（<code>T</code>）的闭包</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>&lt;T&gt;(<span class="keyword">mut</span> f: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">FnMut</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;execute plus one&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数将闭包作为参数并调用它。</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">apply</span>&lt;F&gt;(f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="comment">// 闭包没有输入值和返回值。</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_ invoke__">plus_one</span>(|| number += <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is &#123;&#125;&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 不可复制的类型。`to_owned` 从借用的数据创建有所有权的数据。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">farewell</span> = <span class="string">&quot;goodbye&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diary</span> = || &#123;</span><br><span class="line">        <span class="comment">// `greeting` 通过引用捕获，故需要闭包是 `Fn`。</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I said &#123;&#125;.&quot;</span>, greeting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。</span></span><br><span class="line">        <span class="comment">// 现在需要 `FnMut`。</span></span><br><span class="line">        farewell.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Then I screamed &#123;&#125;.&quot;</span>, farewell);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动调用 drop 又要求闭包通过值获取 `farewell`。</span></span><br><span class="line">        <span class="comment">// 现在需要 `FnOnce`。</span></span><br><span class="line">        mem::<span class="title function_ invoke__">drop</span>(farewell);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以闭包作为参数，调用函数 `apply`。</span></span><br><span class="line">    <span class="title function_ invoke__">apply</span>(diary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作为返回值"><a class="markdownIt-Anchor" href="#作为返回值"></a> 作为返回值</h4>
<p>闭包可以作为输入参数，也可以作为返回值返回，由于闭包的类型是未知的，所以只有使用 <code>impl Trait</code> 才能返回一个闭包。除此之外，还必须使用 <code>move</code> 关键字，它表明所有的捕获都是通过值进行的。因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">create_fn</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Fn</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;Fn&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;This is a: &#123;&#125;&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_fnmut</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;FnMut&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;This is a: &#123;&#125;&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">create_fnonce</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnOnce</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;FnOnce&quot;</span>.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">    <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;This is a: &#123;&#125;&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_plain</span> = <span class="title function_ invoke__">create_fn</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">fn_mut</span> = <span class="title function_ invoke__">create_fnmut</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_once</span> = <span class="title function_ invoke__">create_fnonce</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">fn_plain</span>();</span><br><span class="line">    <span class="title function_ invoke__">fn_mut</span>();</span><br><span class="line">    <span class="title function_ invoke__">fn_once</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h4>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.fn.html">函数指针</a>是指向代码而非数据的指针。它们可以像函数一样被调用。与引用一样，函数指针被假定为不为空，因此如果想通过 FFI 传递函数指针并能够容纳空指针，需要使用所需的的类型 <code>Option&lt;fn()&gt; </code>。</p>
<p>函数指针的类型是 <code>fn</code>，注意和 <code>Fn</code> 区分，后者是闭包实现的 <code>trait</code> 类型。 函数指针实现了<strong>所有三个闭包</strong> <code>trait</code>（<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>），所以总是可以在调用期望闭包的函数时传递函数指针作为参数。倾向于编写使用泛型和闭包 <code>trait</code> 的函数，这样它就能接受函数或闭包作为参数。<code>Fn</code> 系列 <code>trait</code> 由标准库提供，<strong>所有的闭包都实现了 <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> 中的一个或多个</strong>。</p>
<p>我们可以将一个闭包转换为函数指针作为参数传入，但是仅限于没有捕获任何环境变量的闭包，这个从闭包和函数的概念上也能区分出来，闭包相对于函数，就是捕获了环境变量。没有捕获任何环境变量的闭包会被编译器重写为匿名独立函数。</p>
<div class="tabs" id="函数和闭包作为参数"><ul class="nav-tabs"><li class="tab active"><a href="#函数和闭包作为参数-1">闭包作为参数</a></li><li class="tab"><a href="#函数和闭包作为参数-2">函数作为参数</a></li><li class="tab"><a href="#函数和闭包作为参数-3">元组结构体作为参数</a></li><li class="tab"><a href="#函数和闭包作为参数-4">闭包转换为函数</a></li><li class="tab"><a href="#函数和闭包作为参数-5">闭包不能转换为函数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="函数和闭包作为参数-1"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list_of_strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数和闭包作为参数-2"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list_of_strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数和闭包作为参数-3"><p>在构造元组结构体时使用 <code>()</code> 语法进行初始化，很像是函数调用，实际上它们确实被实现为返回由参数构造的实例的函数，所以它们也被称为实现了闭包 <code>trait</code> 的函数指针。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Value</span>(<span class="type">u32</span>),</span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_statuses</span>: <span class="type">Vec</span>&lt;Status&gt; = (<span class="number">0u32</span>..<span class="number">5</span>).<span class="title function_ invoke__">map</span>(Status::Value).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list_of_statuses);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_statuses</span>: <span class="type">Vec</span>&lt;State&gt; = (<span class="number">0u32</span>..<span class="number">5</span>).<span class="title function_ invoke__">map</span>(State).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list_of_statuses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数和闭包作为参数-4"><p>没有捕获任何环境变量的闭包会被编译器重写为匿名独立函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RGB</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>() <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    <span class="title function_ invoke__">RGB</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show</span>(f: <span class="title function_ invoke__">fn</span>() <span class="punctuation">-&gt;</span> RGB) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;color is &#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">f</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = || <span class="title function_ invoke__">RGB</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭包自动转换为函数指针</span></span><br><span class="line">    <span class="title function_ invoke__">show</span>(c);</span><br><span class="line">    <span class="title function_ invoke__">show</span>(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="函数和闭包作为参数-5"><p>闭包捕获环境变量之后，就不能再转换为函数了。这里有个例子：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52696907/why-does-passing-a-closure-to-function-which-accepts-a-function-pointer-not-work?answertab=active#tab-top">https://stackoverflow.com/questions/52696907/why-does-passing-a-closure-to-function-which-accepts-a-function-pointer-not-work?answertab=active#tab-top</a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">wrap</span>(c: <span class="title function_ invoke__">fn</span>() <span class="punctuation">-&gt;</span> ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="title function_ invoke__">c</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">wrap</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译这段代码就会报错，帮我们指出闭包只有在没有捕获任何环境变量的情况下才能转换为函数，不得不说 <code>rust</code> 的编译器还是很友好：</p>
<p><img data-src="closure-convert-to-fn-failed.PNG" alt="closure convert to fn failed" /></p></div></div></div>
<h3 id="trait"><a class="markdownIt-Anchor" href="#trait"></a> Trait</h3>
<p><code>trait</code> 用于定义共享的行为，<code>trait</code> 告诉 <code>Rust</code> 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 <code>trait</code> 以一种抽象的方式定义共享的行为，可以使用 <code>trait bounds</code> 指定泛型是任何拥有特定行为的类型。<code>trait</code> 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合，这里定义的方法可以只是签名说明而没有函数体。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="默认类型和关联参数"><a class="markdownIt-Anchor" href="#默认类型和关联参数"></a> 默认类型和关联参数</h4>
<p><code>rust</code> 官方提供了一个 <code>use std::ops::Add;</code>，可以用于重载 <code>+</code> 运算符，定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: RHS) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>Output</code> 被称作关联类型，用来决定 <code>add</code> 的返回值类型，在具体实现的时候指定具体类型。这里的 <code>RHS=Self</code> 语法表示：<strong>默认类型参数</strong>，<code>RHS</code> 是 <code>right hand side</code> 的缩写，用于定义 <code>add</code> 方法中的 <code>rhs</code> 参数。如果实现 <code>Add trait</code> 时不指定 <code>RHS</code> 的具体类型，<code>RHS</code> 的类型将是默认的 <code>Self</code> 类型，也就是在其上实现 <code>Add</code> 的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// 关联类型 Output 指定为 Point</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RHS 默认类型参数指定为：Meters</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meters&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="comment">// 关联类型 Output 指定为 Millimeters，指定 add 方法返回值类型</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Meters) <span class="punctuation">-&gt;</span> Millimeters &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">3</span> &#125;,</span><br><span class="line">        Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">meter</span> = <span class="title function_ invoke__">Meters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">millimeters</span> = <span class="title function_ invoke__">Millimeters</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Millimeters</span>(<span class="number">1001</span>), millimeters + meter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完全限定语法"><a class="markdownIt-Anchor" href="#完全限定语法"></a> 完全限定语法</h4>
<p><code>Rust</code> 既不能避免一个 <code>trait</code> 与另一个 <code>trait</code> 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 <code>trait</code>。甚至直接在类型上实现开始已经有的同名方法也是可能的。下面的示例中通过在方法名称前面添加 <code>trait</code> 限定符，我们向 <code>rust</code> 指定我们需要哪个实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is your captain speaking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();         <span class="comment">// 直接调用 Human 的方法</span></span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);  <span class="comment">// 调用 Human 为 Pilot 的 fly 实现</span></span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person); <span class="comment">// 调用 Human 为 Wizard 的 fly 实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>像上面这种 <code>fly</code> 方法有一个 <code>self</code> 参数，即使有多个类型实现同一 <code>trait</code>，在使用 <code>Trait::method(self)</code>时，<code>rust</code> 可以根据 <code>self</code> 类型帮我们定位具体哪个类型的实现。然而，当遇到关联函数，即第一个参数不是 <code>self</code> 时，<code>rust</code> 就不能帮我们计算出该使用哪个类型了。下面的示例中使用完全限定语法消除歧义，该语法为：</p>
<blockquote>
<p><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></p>
<p>关联函数没有 <code>receiver</code></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Dog 类型的实现</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">    <span class="comment">// Dog 类型为 Animal trait 的实现</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义实现"><a class="markdownIt-Anchor" href="#自定义实现"></a> 自定义实现</h4>
<p>实现 <code>trait</code> 时需要注意的一个限制是，只有当 <code>trait</code> 或者要实现 <code>trait</code> 的类型位于 <code>crate</code> 的本地作用域时，才能为该类型实现 <code>trait</code>，这个限制是被称为<code>相干性（coherence）</code> 的程序属性的一部分，或者更具体的说是<code>孤儿规则（orphan rule）</code>。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个<code>crate</code>可以分别对相同类型实现相同的<code>trait</code>，而<code>Rust</code>将无从得知应该使用哪一个实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">article</span> = Article &#123;</span><br><span class="line">        content: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认实现"><a class="markdownIt-Anchor" href="#默认实现"></a> 默认实现</h4>
<p>默认实现指我们在定义 <code>trait</code> 方法时提供默认的实现行为，在为类型实现<code>trait</code>时，就可以不用再去实现它的方法了。默认实现的<code>trait</code>方法中还允许我们调用相同<code>trait</code>的其他方法，即使他们没有实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;author is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.author.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">article</span> = Article &#123;</span><br><span class="line">        content: <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_owned</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作为参数"><a class="markdownIt-Anchor" href="#作为参数"></a> 作为参数</h4>
<p>我们可以将函数参数定义为实现了某个<code>trait</code>的类型，这样我们不用于去关心<code>trait</code>背后的具体类型，只在乎这些类型的行为。实现这一目标以多种不同的语法方式，它们是等价的，只是表现形式不同。</p>
<div class="tabs" id="trait作为参数"><ul class="nav-tabs"><li class="tab active"><a href="#trait作为参数-1">impl</a></li><li class="tab"><a href="#trait作为参数-2">trait bound</a></li><li class="tab"><a href="#trait作为参数-3">多个 trait bound</a></li></ul><div class="tab-content"><div class="tab-pane active" id="trait作为参数-1"><p>如下，我们定义 <code>notify</code> 函数，指定 <code>item</code> 参数为实现了 <code>Summary</code> 的一个类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;author is &#123;&#125;&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;notify: &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="trait作为参数-2"><p><code>impl</code> 看起来比较直观，它实际上是一个较长形式的语法糖，称之为 <code>trait bound</code>，所以前面的 <code>impl Summary</code> 等价于如下的形式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;notify: &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_bound</span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;notify: &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>impl</code> 形式在参数较少时比较方便，在参数较多时就看起来比较冗余，使用 <code>trait bound</code> 看起来就比较方便：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_para2</span>(item1: <span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;notify1: &#123;&#125;, notify2: &#123;&#125;&quot;</span>,</span><br><span class="line">        item1.<span class="title function_ invoke__">summarize</span>(),</span><br><span class="line">        item2.<span class="title function_ invoke__">summarize</span>()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_para2_bound</span>&lt;T: Summary&gt;(item1: T, item2: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;notify1: &#123;&#125;, notify2: &#123;&#125;&quot;</span>,</span><br><span class="line">        item1.<span class="title function_ invoke__">summarize</span>(),</span><br><span class="line">        item2.<span class="title function_ invoke__">summarize</span>()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="trait作为参数-3"><p><code>trait bound</code> 可以理解为将 <code>trait</code> 绑定到某个泛型上，当需要将参数声明为实现了多个<code>trait</code>的类型时，可以使用 <code>+</code> ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_two_trait</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_two_trait_bound</span>&lt;T: Summary + Display&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用过多的 <code>trait bound</code> 也有缺点。每个泛型有其自己的 <code>trait bound</code>，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 <code>trait bound</code> 信息，这使得函数签名难以阅读。为此，<code>Rust</code> 有另一个在函数签名之后的 <code>where</code> 从句中指定 <code>trait bound</code> 的语法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_complex</span>&lt;T: Summary + Display, U: <span class="built_in">Debug</span> + <span class="built_in">Copy</span>&gt;(item1: T, item2: U) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;item1: &#123;&#125;, item2: &#123;:?&#125;&quot;</span>, item1, item2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">notify_complex_where</span>&lt;T, U&gt;(item1: T, item2: U)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Debug</span> + <span class="built_in">Copy</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;item1: &#123;&#125;, item2: &#123;:?&#125;&quot;</span>, item1, item2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h4 id="作为返回值-2"><a class="markdownIt-Anchor" href="#作为返回值-2"></a> 作为返回值</h4>
<p>我们可以将函数的返回值定义为实现了某个trait的类型，例如我们指定 <code>returns_summarizable</code> 函数返回实现了 <code>Summary</code> 的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Display&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">        author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = <span class="title function_ invoke__">returns_summarizable</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果我们想从一个函数中返回多种实现了同一<code>trait</code>的类型，就不可以了，如下面这段代码就<mark class="label danger">不能通过编译</mark>，因为<code>rust</code>需要在编译时期就确定函数返回值的大小。返回不同的类型，意味着函数的返回值大小是不确定的，这对于 <code>rust</code> 来说是<mark class="label danger">不允许</mark>的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">try_return_multiple_types</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        Tweet &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">            author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Article &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">            author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们确实想这样做，我们可以使用 <code>Box&lt;T&gt;</code> 类型，这个类型将数据实际存储在堆上，保留该数据的指针，所以其大小是固定的，这样就实现了动态分发：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">try_return_multiple_types</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Summary&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Tweet &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">            author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Article &#123;</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course, as you probably already know, people&quot;</span>),</span><br><span class="line">            author: <span class="string">&quot;michael&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有条件地实现方法"><a class="markdownIt-Anchor" href="#有条件地实现方法"></a> 有条件地实现方法</h4>
<p>有时候我们在为某一个泛型结构体实现方法的时候，首先需要它的类型实现某些<code>trait</code>。如下示例中，类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法，不过只有那些为 <code>T</code> 类型实现了 <code>PartialOrd trait</code> （来允许比较） 和 <code>Display trait</code> （来启用打印）的 <code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = Pair &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line">    pair.<span class="title function_ invoke__">cmp_display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对任何实现了特定 <code>trait</code> 的类型有条件地实现 <code>trait</code>。对任何满足特定 <code>trait bound</code> 的类型实现 <code>trait</code> 被称为 <code>blanket implementations</code>，他们被广泛的用于 <code>Rust</code> 标准库中。例如，标准库为任何实现了 <code>Display trait</code> 的类型实现了 <code>ToString trait</code>。这个 <code>impl</code> 块看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以可以对任何实现了 <code>Display trait</code> 的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。</p>
<blockquote>
<p><code>let s = 3.to_string();</code></p>
</blockquote>
<h4 id="父-trait"><a class="markdownIt-Anchor" href="#父-trait"></a> 父 trait</h4>
<p>在前面的例子中，我们演示过可以在 <code>trait</code> 的默认实现中使用相同<code>trait</code>的其他方法，即使该方法未实现。但是，我们有时也需要在当前<code>trait</code>中使用其他<code>trait</code>中的功能，这就形成了 <code>trait</code> 依赖，被依赖的<code>trait</code>的我们称之为当前<code>trait</code>的 <strong>父trait</strong>。</p>
<p>下面的例子中，<code>OutlinePrint</code> 在定义的默认方法 <code>outline_print</code> 调用了 <code>fmt::Display</code> 中的 <code>to_string</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutlinePrint</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    point.<span class="title function_ invoke__">outline_print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="copy-clone"><a class="markdownIt-Anchor" href="#copy-clone"></a> Copy、Clone</h4>
<p><code>Copy</code> 和 <code>Clone</code> 直接从字面意义上感觉没什么区别，它们最终都是产生了一个新的对象，但是这两个 <code>trait</code> 面向的对象不同，<code>Copy</code> 面向编译器，而 <code>Clone</code> 面向开发者。换句话说就是<code>copy</code>操作编译器帮我们做了，但是 <code>clone</code> 需要我们自己手动调用。</p>
<p>参考文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone?answertab=active#tab-top"><code>https://stackoverflow.com/questions/31012923/what-is-the-difference-between-copy-and-clone?answertab=active#tab-top</code></a></li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone"><code>https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone</code></a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21730929"><code>https://zhuanlan.zhihu.com/p/21730929</code></a></li>
<li><a target="_blank" rel="noopener" href="https://hashrust.com/blog/moves-copies-and-clones-in-rust/"><code>https://hashrust.com/blog/moves-copies-and-clones-in-rust/</code></a></li>
</ol>
<h5 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> Copy</h5>
<p><code>Copy</code> 的全称是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>std::marker::Copy</code></a>，它的内部其实什么方法都没有，但是实现它必须实现 <code>Clone</code>。一旦一个类型实现 <code>Copy</code> 意味着在任何需要的时候，我们可以简单的通过内存拷贝（C语言的按位拷贝<code>memcpy</code>）实现该类型的复制，而不会出现任何问题。在变量绑定、函数参数传递、函数返回值传递等场景下，它都是 <code>copy</code> 语义，而不再是默认的 <code>move</code> 语义</p>
<blockquote>
<p><code>pub trait Copy: Clone &#123; &#125;</code></p>
</blockquote>
<div class="tabs" id="copy对所有权移动的影响"><ul class="nav-tabs"><li class="tab active"><a href="#copy对所有权移动的影响-1">实现 Copy</a></li><li class="tab"><a href="#copy对所有权移动的影响-2">未实现Copy</a></li></ul><div class="tab-content"><div class="tab-pane active" id="copy对所有权移动的影响-1"><p><code>i32</code> 实现了 <code>Copy</code>，所以我们在使用 <code>let</code> 表达式的时候，其实是复制而不是所有权转移。</p>
<p>实现 <code>Copy</code> 的基本类型： <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html#implementors"><code>https://doc.rust-lang.org/std/marker/trait.Copy.html#implementors</code></a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="copy对所有权移动的影响-2"><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html#when-cant-my-type-be-copy"><code>String</code> 没有实现 <code>Copy</code></a>，所以它在使用 <code>let</code> 表达式的时候，是所有权转移，下面的代码<mark class="label danger">编译失败</mark></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="./string-not-implement-copy.PNG" alt="String not implement Copy" /></p></div></div></div>
<p>并不是所有的类型都可以实现 <code>Copy</code> 。<code>Rust</code> 规定，对于自定义类型，只有所有的成员都实现了 <code>Copy</code> ，这个类型才有资格实现 <code>Copy</code>。例如下面的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">   x: <span class="type">i32</span>,</span><br><span class="line">   y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是看下面的 <code>PointList</code> 类型，他就不能实现 <code>Copy</code>，因为 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 没有实现 <code>Copy</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PointList</span> &#123;</span><br><span class="line">    points: <span class="type">Vec</span>&lt;Point&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 <code>PointList</code> 不能实现 <code>Copy</code>，但是是由于共享引用 <code>&amp;T</code> 可以 <code>Copy</code>，所以我们可以实现一个 <code>PointListWrapper</code>，包含 <code>PointList</code> 的一个引用，这样即使 <code>PointList</code> 不能 <code>Copy</code>，<code>PointListWrapper</code> 也可以 <code>Copy</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PointListWrapper</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    point_list_ref: &amp;<span class="symbol">&#x27;a</span> PointList,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="clone"><a class="markdownIt-Anchor" href="#clone"></a> Clone</h5>
<p><code>Clone</code> 的全称是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>std::clone::Clone;</code></a>，他定义了两个方法，其中 <code>clone_from</code> 默认实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Clone</span>: <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone_from</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, source: &amp;<span class="keyword">Self</span>) &#123;</span><br><span class="line">        *<span class="keyword">self</span> = source.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clone</code> 方法一般用于基于语义的复制操作。所以，它做什么事情，跟具体类型的作用息息相关。比如对于 <code>Box</code> 类型，<code>clone</code> 就是执行的深拷贝，而对于 <code>Rc</code> 类型，<code>clone</code> 做的事情就是把引用计数值加<code>1</code>。你可以根据情况在 <code>clone</code> 函数中编写任意的逻辑。但是有一条规则需要注意：对于实现了 <code>Copy</code> 的类型，它的 <code>clone</code> 方法应该跟 <code>Copy</code> 语义相容，等同于按位拷贝。</p>
<p>实现了 <code>Clone</code> 的所有基本类型： <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/clone/trait.Clone.html#implementors"><code>https://doc.rust-lang.org/std/clone/trait.Clone.html#implementors</code></a></p>
<p>下面这段代码是<mark class="label success">编译通过</mark>的，可以看到，<code>String</code> 虽然未实现 <code>Copy</code>，但是它实现了 <code>Clone</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fn-fnmut-fnonce"><a class="markdownIt-Anchor" href="#fn-fnmut-fnonce"></a> Fn、FnMut、FnOnce</h4>
<p>这三个 <code>trait</code> 位于 <code>std::ops</code> 模块中，其实是对函数调用运算符 <code>()</code> 的重载，区别在于 <code>receiver</code> 的类型，可以看到 <code>Fn</code> 的受限成都最高，<code>FnOnce</code> 最低：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">self</span>, args: Args) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FnMut</span>&lt;Args&gt;: <span class="built_in">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>, </span><br><span class="line">        args: Args</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Fn</span>&lt;Args&gt;: <span class="built_in">FnMut</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>, args: Args) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>Once</code> 的意义， 正如<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch13-01-closures.html#%E9%97%AD%E5%8C%85%E4%BC%9A%E6%8D%95%E8%8E%B7%E5%85%B6%E7%8E%AF%E5%A2%83">闭包会捕获其环境</a> 中描述的那样：</p>
<ul>
<li>
<p><code>FnOnce</code> 消费从周围作用域捕获的变量，闭包周围的作用域被称为其环境，<code>environment</code>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 <code>Once</code> 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</p>
</li>
<li>
<p>由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 <code>FnOnce</code> 。</p>
</li>
</ul>
<h5 id="fnonce"><a class="markdownIt-Anchor" href="#fnonce"></a> FnOnce</h5>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> 获取了 <code>receiver</code> 的所有权，如果一个类型仅仅实现了 <code>FnOnce</code> 它只可以被调用一次。<code>FnOnce</code> 由可能消耗捕获变量的闭包以及实现 <code>FnMut</code> 的所有类型自动实现。</p>
<p>由于 <code>Fn</code> 和 <code>FnMut</code> 都是 <code>FnOnce</code> 的 <code>subtraits</code> ，因此可以在需要 <code>FnOnce</code> 的地方使用 <code>Fn</code> 或 <code>FnMut</code> 的任何实例。如果我们在一个类函数类型参数使用场景中，如果我们期望只调用它一次，就使用 <code>FnOnce</code> 作为其类型，如果我们需要调用它多次是就使用 <code>FnMut</code> 作为其类型，如果我们还想要它不改变状态时，我们就用 <code>Fn</code>。</p>
<p>从 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html#implementors"><code>implementors</code></a> 也可以看出，对于任何实现了 <code>FnOnce</code> 的类型 <code>F</code>，<code>&amp;F</code> 和 <code>&amp;mut F</code> 也自动实现 <code>FnOnce</code>。</p>
<div class="tabs" id="fnonce"><ul class="nav-tabs"><li class="tab active"><a href="#fnonce-1">闭包捕获非Copy类型，获取其所有权</a></li><li class="tab"><a href="#fnonce-2">闭包捕获可Copy类型</a></li><li class="tab"><a href="#fnonce-3">非Copy类型，获取所有权，但是并不消耗</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fnonce-1"><p>这个例子中，<code>consume_and_return_x</code> 捕获了 <code>x</code> 并获得了其所有权，并且在第一次调用时已经将 <code>x</code> 的所有权转移，所以无法再次调用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">consume_with_relish</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>,</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func 消耗了它捕获的环境变量，所以它只能被运行一次</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Consumed: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Delicious!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果再尝试调用，func()，将会出现编译错误</span></span><br><span class="line">    <span class="comment">// func();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume_and_return_x</span> = <span class="keyword">move</span> || x;</span><br><span class="line">    <span class="title function_ invoke__">consume_with_relish</span>(consume_and_return_x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="fnonce-2"><p>当我们将前面例子中变量 <code>x</code> 的类型由 <code>String</code> 改为 <code>i32</code>，我们来看几个变种类型，改动很小。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">consume_with_relish</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Consumed: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>());</span><br><span class="line">    <span class="comment">// 这里调用会出现编译错误，在首次调用时，会将捕获的变量 x 消耗掉</span></span><br><span class="line">    <span class="comment">// func(); </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这里 x 移入闭包的时候，由于 x 默认实现了 Copy 类型，所以执行的是 copy 操作，而不是获取所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume_and_return_x</span> = <span class="keyword">move</span> || x;</span><br><span class="line">    <span class="title function_ invoke__">consume_with_relish</span>(consume_and_return_x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;print x again: &#123;&#125;&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是由于 <code>i32</code> 是可复制的，所以生成的闭包也是可复制的，还记得 <code>Copy</code> 的含义，当所有成员都实现 <code>Copy</code> 的时候，这个类型就可能实现 <code>Copy</code>。我们可以将上面示例中泛型参数 <code>F</code> 的类型声明为以下任何一种，就可以实现 <code>func</code> 多次调用，我们其实是在告诉编译器，可以通过 <code>Copy</code> 避免所有权的转移：</p>
<ul>
<li><code>F: FnOnce() -&gt; i32 + Copy</code></li>
<li><code>F: Copy + FnOnce() -&gt; i32</code></li>
<li><code>F: Copy + FnOnce() -&gt; i32 + Copy</code></li>
</ul></div><div class="tab-pane" id="fnonce-3"><p>下面的例子运行是没有问题的，<code>consume_and_return_x</code> 获取了变量 <code>x</code> 的所有权，因为 <code>String</code> 不可 <code>Copy</code>。但是我们在使用的时候并没有消耗它的所有权，所以是可以多次使用的。这个时候 <code>consume_and_return_x</code> 其实已经实现了 <code>Fn</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">consume_with_relish</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">func</span>();</span><br><span class="line">    <span class="title function_ invoke__">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">consume_and_return_x</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="title function_ invoke__">consume_and_return_x</span>();</span><br><span class="line">    <span class="title function_ invoke__">consume_and_return_x</span>();</span><br><span class="line">    <span class="title function_ invoke__">consume_with_relish</span>(consume_and_return_x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h5 id="fnmut"><a class="markdownIt-Anchor" href="#fnmut"></a> FnMut</h5>
<p><code>FnMut</code> 实例可以被重复多次调用，并且可以改变环境变量。它被那些捕获了环境变量可变引用的闭包，所有<code>Fn</code> 的实现者，以及函数指针自动实现。对于任何实现了 <code>FnMut</code> 的类型 <code>F</code>，<code>&amp;mut F</code> 也实现了 <code>FnMut</code>。</p>
<p>另外，因为 <code>FnOnce</code> 是 <code>FnMut</code> 的 <strong>父trait</strong>，所以任何需要 <code>FnOnce</code> 的地方都可以传入 <code>FnMut</code>。当你需要对一个类似函数类型的参数限定为，可调用多次并且可改变内部状态时，可以使用 <code>FnMut</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>&lt;F&gt;(<span class="keyword">mut</span> func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>(),</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">func</span>();</span><br><span class="line">    <span class="title function_ invoke__">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span>: <span class="type">usize</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_two_to_x</span> = || x += <span class="number">2</span>;</span><br><span class="line">    <span class="title function_ invoke__">do_twice</span>(add_two_to_x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="fn"><a class="markdownIt-Anchor" href="#fn"></a> Fn</h5>
<p><code>Fn</code> 要和 函数指针 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/primitive.fn.html"><code>fn</code></a> 区别，<code>Fn</code> 被那些仅捕获环境中变量不可变引用的闭包，或者不捕获任何东西的闭包，或者函数指针自动实现。需要 <code>Fn</code>或者<code>FnMut</code> 的地方，都可以传入 <code>Fn</code>。如果类型 <code>F</code> 实现 <code>Fn</code>，那么 <code>&amp;F</code> 也将自动实现 <code>Fn</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call_with_one</span>&lt;F&gt;(func: F) <span class="punctuation">-&gt;</span> <span class="type">usize</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">Fn</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">func</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">double</span> = |x| x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">call_with_one</span>(double), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="deref-derefmut"><a class="markdownIt-Anchor" href="#deref-derefmut"></a> Deref、DerefMut</h4>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> 允许我们重载解引用运算符 <code>*</code>，它包含一个 <code>deref</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Deref</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span>: ?<span class="built_in">Sized</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。下面的示例中创建了一个 <code>i32</code> 值的引用，接着使用解引用运算符来跟踪所引用的数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义我们自己的 <code>MyBox</code> 类型，实现 <code>Deref</code>，<code>deref</code> 方法体中写入了 <code>&amp;self.0</code>，这样 <code>deref</code> 返回了我希望通过 <code>*</code> 运算符访问的值的引用。没有 <code>Deref trait</code> 的话，编译器只会解引用 <code>&amp;</code> 引用类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(item: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">    <span class="comment">// Rust 将 * 运算符替换为先调用 deref 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 deref 方法了</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *(y.<span class="title function_ invoke__">deref</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="隐式引用强制转换"><a class="markdownIt-Anchor" href="#隐式引用强制转换"></a> 隐式引用强制转换</h5>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">隐式引用强制转换</a>是 Rust 在函数或方法传参上的一种便利，这仅仅用在实现了 <code>Deref</code> 的 trait，隐式引用强制将这样一个类型转换为另一个类型或者引用。例如，<code>&amp;String</code> 转换为 <code>&amp;str</code>，因为 <code>String</code> 实现了 <code>Deref</code> 返回了 <code>&amp;str</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(item: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello: &#123;&#125;&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;potato&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;MyBox::<span class="title function_ invoke__">new</span>(<span class="string">&quot;michael&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">people</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="comment">// 如果没有隐式引用强制转换，我们就得这样做</span></span><br><span class="line">    <span class="comment">// *people == *(people.deref()) -&gt; String</span></span><br><span class="line">    <span class="comment">// &amp;(*people) -&gt; &amp;String</span></span><br><span class="line">    <span class="comment">// &amp;(*people)[..] -&gt; &amp;str</span></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;(*people)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="隐式引用强制转换与可变性"><a class="markdownIt-Anchor" href="#隐式引用强制转换与可变性"></a> 隐式引用强制转换与可变性</h5>
<p>类似于如何使用 <code>Deref</code> 重载不可变引用的 <code>*</code> 运算符，Rust 提供了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> 用于重载可变引用的 <code>*</code> 运算符。</p>
<p>Rust 在发现类型和 trait 实现满足三种情况时会自动进行引用强制转换：</p>
<ul>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;T</code> 到 <code>&amp;U</code>；</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code>；</li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code> 时从 <code>&amp;mut T</code> 到 <code>&amp;U</code>；</li>
</ul>
<h4 id="drop"><a class="markdownIt-Anchor" href="#drop"></a> Drop</h4>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 <code>Drop</code> 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。在 Rust 中，可以指定每当值离开作用域时被执行的代码，编译器会自动插入这些代码。</p>
<p>指定在值离开作用域时应该执行的代码的方式是实现 <code>Drop</code>。<code>Drop</code> 要求实现一个叫做 <code>drop</code> 的方法，它获取一个 <code>self</code> 的可变引用。</p>
<p><img data-src="drop_trait.png" alt="实现Drop" /></p>
<h3 id="错误"><a class="markdownIt-Anchor" href="#错误"></a> 错误</h3>
<p>任何程序都不能完全正确地按照开发者的意愿去运行，总会遇到错误，例如打开文件时，文件不存在。Rust 将程序可能出现的错误分为<strong>可恢复错误（recoverable）<strong>和</strong>不可恢复错误（unrecoverable）</strong>。可恢复错误通常意味着意料之中的情况，我们可以选择向用户报告错误或者进行重试。不可恢复的错误往往意味着bug，比如数组访问越界。</p>
<p>Rust 中没有异常，如果遇到可恢复错误就返回 <code>Result&lt;T, E&gt;</code> 让开发者处理，遇到不可恢复的错误就 <code>panic!</code>。</p>
<h4 id="panic不可恢复错误"><a class="markdownIt-Anchor" href="#panic不可恢复错误"></a> panic!，不可恢复错误</h4>
<p>当程序遇到不可处理的异常时，选择 <code>panic</code> 未尝不可。可以通过宏 <code>panic!</code>，退出程序。</p>
<p>当程序 <code>panic</code> 时，程序默认会开始<strong>展开（unwinding）</strong>，这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接<strong>终止（abort）</strong>，这会不清理数据就退出程序，那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，<code>panic</code> 时通过在 <code>Cargo.toml</code> 的 <code>[profile]</code> 部分增加 <code>panic = 'abort'</code>，可以由展开切换为终止。例如，如果你想要在<code>release</code>模式中 <code>panic</code> 时直接终止：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = &#x27;abort&#x27;</span><br></pre></td></tr></table></figure>
<p>我们可以通过将 <code>RUST_BACKTRACE</code> 设置为一个非 <code>0</code> 的数值，用于在程序 <code>panic</code> 时得到程序的调用栈。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还提示我们可以通过将 <code>RUST_BACKTRACE</code> 设置为 <code>full</code>，得到更详细的调用栈。</p>
<p><img data-src="vec-over-panic.png" alt="数组越界panic" /></p>
<h4 id="result可恢复错误"><a class="markdownIt-Anchor" href="#result可恢复错误"></a> Result，可恢复错误</h4>
<p>程序往往不会严重到不能执行，在出现异常情况时，返回一个错误大多是比较合适的处理方式。Rust 中经常通过枚举类型 <code>Result</code> 代表返回一个错误或者一个期望的值。如下面 <code>Result</code> 的定义所示，它被定义为一个泛型，在处理正确时返回 <code>Ok(T)</code>，出现错误时返回错误 <code>Err(E)</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一个打开文件的例子，目的是获得操作文件的句柄，在文件不存在时，我们创建新的文件，如果都失败或者其他未知错误，直接 <code>panic</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_name</span> = <span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(file_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(file_name) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;create file failed: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_err =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;open file failed: &#123;:?&#125;&quot;</span>, other_err),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看着上面层层嵌套的 <code>match</code>，在感叹其强大的匹配功能的同时，也会感慨较深的代码嵌套不易阅读，我们尝试对其进行简化，其中 <code>unwrap_or_else</code> 接受一个闭包，它在前面的返回值没有问题时，直接返回；当遇到错误时，调用我们传入的闭包继续处理，期望返回我们需要的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file_name</span> = <span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(file_name).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(file_name).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;meet unkown error: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="错误传播"><a class="markdownIt-Anchor" href="#错误传播"></a> 错误传播</h4>
<p>当我们开发一个功能在遇到错误时，经常会选择向上传递错误，让调用者自由选择处理的方式，例如我们开发一个函数，读取指定的文件内容，我们可能会这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Error, ErrorKind, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file_content</span>(file: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(file);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(f) =&gt; f,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="title function_ invoke__">Err</span>(err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到的是，我们使用 <code>match</code> 完成错误匹配，选择继续执行还是返回。但也展现出语法繁琐，所以就有了 <strong>?</strong> 运算符。<code>?</code> 在遇到返回值 <code>OK(value)</code>，将取出 <code>value</code> 继续执行，如果遇到 <code>Err</code>，将会返回当前的错误。我们来改写上面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Error, ErrorKind, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file_content</span>(file: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(file)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>match</code> 表达式与问号运算符所做的有一点不同：<code>?</code> 运算符所使用的错误值被传递给了 <code>from</code> 函数，它定义于标准库的 <code>From trait</code> 中，其用来将错误从一种类型转换为另一种类型。当 <code>?</code> 运算符调用 <code>from</code> 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型。这在当函数返回单个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 <code>from</code> 函数来定义如何将自身转换为返回的错误类型，<code>?</code> 运算符会自动处理这些转换。<strong>总结就是，? 将收集到错误值自动转换为要返回的错误类型。</strong></p>
<p>另外，由于 <code>main</code> 函数是比较特殊的，它返回什么类型是由限制的，一般情况下它的返回值是 <code>()</code>，但是为了方便，他也允许返回 <code>Result&lt;(), E&gt;</code>，因此，我们也可以在 <code>main</code> 中使用 <code>?</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;Error, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file_content</span>(file: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(file)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = <span class="title function_ invoke__">read_file_content</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;content is: &#123;&#125;&quot;</span>, content);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> ? 运算符</h4>
<p><code>?</code> 除了可以用于 <code>Result</code> 类型之外，还可以用于 <code>Option</code> 类型。如果 <code>x</code> 是 <code>Option</code>，那么若 <code>x</code> 是 <code>Some</code> ，对 <code>x?</code> 表达式求值将返回底层值，否则无论函数是否正在执行都将终止且返回 <code>None</code> 。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    job: <span class="type">Option</span>&lt;Job&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">work_phone_area_code</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.job?.phone_number?.area_code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    phone_number: <span class="type">Option</span>&lt;PhoneNumber&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    area_code: <span class="type">Option</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    number: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        job: <span class="title function_ invoke__">Some</span>(Job &#123;</span><br><span class="line">            phone_number: <span class="title function_ invoke__">Some</span>(PhoneNumber &#123;</span><br><span class="line">                area_code: <span class="title function_ invoke__">Some</span>(<span class="number">128</span>),</span><br><span class="line">                number: <span class="number">439222222</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(p.<span class="title function_ invoke__">work_phone_area_code</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">128</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="option"><a class="markdownIt-Anchor" href="#option"></a> Option</h4>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#implementations"><code>Option</code></a> 自己实现了很多有用的方法，可以更快速的完成我们的代码编写。</p>
<div class="tabs" id="option-methods"><ul class="nav-tabs"><li class="tab active"><a href="#option-methods-1">map</a></li><li class="tab"><a href="#option-methods-2">and_then</a></li></ul><div class="tab-content"><div class="tab-pane active" id="option-methods-1"><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>map</code></a> 可以做的 <code>Some</code> -&gt; <code>Some</code>，<code>None</code> -&gt; <code>None</code> 的映射，可以串起来调用，我们来举一个煮饭的例子。<code>map</code> 中返回的是一个新的类型，当然这个类型可以是 <code>Option</code>，不过这将导致 <code>Option</code> 嵌套。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    Apple,</span><br><span class="line">    Carrot,</span><br><span class="line">    Potato,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Peeled</span>(Food);</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chopped</span>(Food);</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cooked</span>(Food);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">cook</span>(food: <span class="type">Option</span>&lt;Food&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Cooked&gt; &#123;</span><br><span class="line">    food.<span class="title function_ invoke__">map</span>(|f| <span class="title function_ invoke__">Peeled</span>(f))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|<span class="title function_ invoke__">Peeled</span>(f)| <span class="title function_ invoke__">Chopped</span>(f))</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|<span class="title function_ invoke__">Chopped</span>(f)| <span class="title function_ invoke__">Cooked</span>(f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eat</span>(food: <span class="type">Option</span>&lt;Cooked&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> food &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(f) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Mmm. I love &#123;:?&#125;&quot;</span>, f),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Oh no! It wasn&#x27;t edible.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apple</span> = <span class="title function_ invoke__">Some</span>(Food::Apple);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">carrot</span> = <span class="title function_ invoke__">Some</span>(Food::Carrot);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">potato</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">eat</span>(<span class="title function_ invoke__">cook</span>(apple));</span><br><span class="line">    <span class="title function_ invoke__">eat</span>(<span class="title function_ invoke__">cook</span>(carrot));</span><br><span class="line">    <span class="title function_ invoke__">eat</span>(<span class="title function_ invoke__">cook</span>(potato));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="option-methods-2"><p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>and_then</code></a> 当 <code>Option</code> 是 <code>None</code> 时，返回 <code>None</code>。否则将 <code>Some</code> 中包裹的值传入闭包函数，这个闭包返回一个新的 <code>Option</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sq</span>(x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(x * x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">nope</span>(_: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="number">2</span>).<span class="title function_ invoke__">and_then</span>(sq).<span class="title function_ invoke__">and_then</span>(sq), <span class="title function_ invoke__">Some</span>(<span class="number">16</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="number">2</span>).<span class="title function_ invoke__">and_then</span>(sq).<span class="title function_ invoke__">and_then</span>(nope), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(<span class="number">2</span>).<span class="title function_ invoke__">and_then</span>(nope).<span class="title function_ invoke__">and_then</span>(sq), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="literal">None</span>.<span class="title function_ invoke__">and_then</span>(sq).<span class="title function_ invoke__">and_then</span>(sq), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h4 id="定义错误类型"><a class="markdownIt-Anchor" href="#定义错误类型"></a> 定义错误类型</h4>
<p>定义自己的错误类型在传递错误信息时是必要的，我们来看一个例子，将一个字符串数组中的第一个元素转换为数字并且乘以2。下面的代码中我们也定义了自己的 <code>Result</code> 类型，定义自己的错误类型需要实现 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, DoubleFirstError&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleFirstError</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">DoubleFirstError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;double first int error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">DoubleFirstError</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_first</span>(vec: &amp;<span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    vec.<span class="title function_ invoke__">first</span>().<span class="title function_ invoke__">ok_or</span>(DoubleFirstError).<span class="title function_ invoke__">and_then</span>(|s| &#123;</span><br><span class="line">        s.parse::&lt;<span class="type">i32</span>&gt;()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| DoubleFirstError)</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|i| <span class="number">2</span> * i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(result: <span class="type">Result</span>&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(r) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;&#125;&quot;</span>, r),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;err is &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="string">&quot;42&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">empty</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;tofu&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;numbers));</span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;empty));</span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;strings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="boxerrorerror"><a class="markdownIt-Anchor" href="#boxerrorerror"></a> <code>Box&lt;error::Error&gt;</code></h4>
<p>当我们只关注错误信息，而不关注错误类型的时候，我们可以将错误装进 <code>Box</code>，我们对上面的例子稍加修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::result::<span class="type">Result</span>&lt;T, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> error::Error&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleFirstError</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">DoubleFirstError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;double first int error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">error</span>::Error <span class="keyword">for</span> <span class="title class_">DoubleFirstError</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">double_first</span>(vec: &amp;<span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    vec.<span class="title function_ invoke__">first</span>().<span class="title function_ invoke__">ok_or</span>(DoubleFirstError.<span class="title function_ invoke__">into</span>()).<span class="title function_ invoke__">and_then</span>(|s| &#123;</span><br><span class="line">        s.parse::&lt;<span class="type">i32</span>&gt;()</span><br><span class="line">            .<span class="title function_ invoke__">map_err</span>(|_| DoubleFirstError.<span class="title function_ invoke__">into</span>())</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|i| <span class="number">2</span> * i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(result: <span class="type">Result</span>&lt;<span class="type">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(r) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;the result is &#123;&#125;&quot;</span>, r),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;err is &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="string">&quot;42&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">empty</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;tofu&quot;</span>, <span class="string">&quot;93&quot;</span>, <span class="string">&quot;18&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;numbers));</span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;empty));</span><br><span class="line">    <span class="title function_ invoke__">print</span>(<span class="title function_ invoke__">double_first</span>(&amp;strings));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h3>
<p>Rust 使用 trait 解决类型之间的转换问题。最一般的转换会用到 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> 两个 trait。</p>
<h4 id="from-into"><a class="markdownIt-Anchor" href="#from-into"></a> <code>From</code>、<code>Into</code></h4>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 定义怎么根据另一种类型生成自己，而在定义 <code>From</code> 之后，我们就自然的获得了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>，因为它就是 <code>From</code> 倒过来，但是在使用 <code>Into</code> 的时候，我们得指明要转换的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(item: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Number &#123; value: item &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = Number::<span class="title function_ invoke__">from</span>(<span class="number">188</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, number);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span>: Number = <span class="number">166i32</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tryfrom-tryinto"><a class="markdownIt-Anchor" href="#tryfrom-tryinto"></a> <code>TryFrom</code>、<code>TryInto</code></h4>
<p>类似于 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>，不过 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto</code></a> 用于易出错的转换，他们的返回值类型是 <code>Result</code> 类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::convert::&#123;TryFrom, TryInto&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EvenNumber</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TryFrom</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">EvenNumber</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = ();</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_from</span>(item: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNumber</span>(item))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// try from</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(EvenNumber::<span class="title function_ invoke__">try_from</span>(<span class="number">8</span>), <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNumber</span>(<span class="number">8</span>)));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(EvenNumber::<span class="title function_ invoke__">try_from</span>(<span class="number">5</span>), <span class="title function_ invoke__">Err</span>(()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;EvenNumber, ()&gt; = <span class="number">8i32</span>.<span class="title function_ invoke__">try_into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNumber</span>(<span class="number">8</span>)), result);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;EvenNumber, ()&gt; = <span class="number">5i32</span>.<span class="title function_ invoke__">try_into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Err</span>(()), result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tostring-fromstr"><a class="markdownIt-Anchor" href="#tostring-fromstr"></a> <code>ToString</code>、<code>FromStr</code></h4>
<p>在我们需要将类型转换成字符串类型时，我们只需实现 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>，但是最好的是实现 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>fmt::Display</code></a>，它会自动提供 <code>to_string()</code> 方法。</p>
<p>另外，我们也经常需要将字符串转换成我们需要的目标类型，只要目标类型实现了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>，我们就可以使用字符串的 <code>parse</code> 方法解析，不过我们得提供要转换到的目标类型，或者使用涡轮鱼（turbo fish）语法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;Display, Formatter, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    radius: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Display</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Circle(&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.radius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle</span> = Circle &#123; radius: <span class="number">12</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, circle.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">i32</span> = <span class="string">&quot;45&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num1</span> = <span class="string">&quot;55&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;num: &#123;&#125;, num1: &#123;&#125;&quot;</span>, num, num1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h3>
<p>泛型可以极大地降低代码重复度，我们可以定义泛型结构体，泛型函数，泛型方法，泛型枚举等。但是我们不用担心泛型的性能，Rust 通过在编译时进行泛型代码的单态化(monomorphization)来保证效率。<strong>单态化</strong>是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<div class="tabs" id="泛型种类"><ul class="nav-tabs"><li class="tab active"><a href="#泛型种类-1">枚举</a></li><li class="tab"><a href="#泛型种类-2">结构体和方法</a></li><li class="tab"><a href="#泛型种类-3">函数</a></li><li class="tab"><a href="#泛型种类-4">trait</a></li></ul><div class="tab-content"><div class="tab-pane active" id="泛型种类-1"><p>泛型枚举我们最常见的应该是：<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="泛型种类-2"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) <span class="punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="泛型种类-3"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="泛型种类-4"><p>也可以参考： <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/rust-by-example/generics/gen_trait.html#traits">https://doc.rust-lang.org/stable/rust-by-example/generics/gen_trait.html#traits</a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Mul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Area</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&lt;T&gt; &#123;</span><br><span class="line">    width: T,</span><br><span class="line">    height: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Copy</span> + Mul&lt;Output = T&gt;&gt; Area&lt;T&gt; <span class="keyword">for</span> <span class="title class_">Rectangle</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rec</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">2</span>,</span><br><span class="line">        height: <span class="number">4</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rec.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h3>
<p><strong>指针</strong>是一个包含内存地址变量的通用概念，rust 中使用 <code>&amp;</code> 或者 <code>ref</code> 引用一个变量。<strong>智能指针</strong>是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针拥有他们指向的数据。</p>
<p>本节介绍几个常见的智能指针类型。</p>
<h4 id="boxt-指向堆上的数据"><a class="markdownIt-Anchor" href="#boxt-指向堆上的数据"></a> Box<T> 指向堆上的数据</h4>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> 将数据存储在堆上，留在栈上的仅仅是数据的指针，除此之外，box 没有性能损失。它们多用于如下场景：</p>
<ul>
<li>当在编译时不确定类型大小，又想在需要确切大小的上下文中使用时，例如，使用 <code>Box&lt;dyn error:Error&gt;</code> 动态分发；</li>
<li>当有大量数据并希望在转移所有权的时候，不发生数据拷贝；</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候；</li>
</ul>
<h5 id="数据存储在堆上"><a class="markdownIt-Anchor" href="#数据存储在堆上"></a> 数据存储在堆上</h5>
<p>如下示例，定义了变量 <code>b</code>，其值是一个指向被分配在堆上的值 <code>5</code> 的 <code>Box</code>。我们可以像数据是储存在栈上的那样访问 <code>box</code> 中的数据，正如任何拥有数据所有权的值那样，当像 <code>b</code> 这样的 <code>box</code> 在 <code>main</code> 的末尾离开作用域时，它将被释放。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建递归类型"><a class="markdownIt-Anchor" href="#创建递归类型"></a> 创建递归类型</h5>
<p>Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 递归类型（recursive type），其值的一部分可以是相同类型的另一个值。我们探索一下 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cons">cons list</a>，一个函数式编程语言中的常见类型，来展示这个（递归类型）概念。</p>
<p><code>cons list</code> 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 <code>Nil</code> 的值且没有下一项。<code>cons list</code> 通过递归调用 <code>cons</code> 函数产生。代表递归的终止条件（base case）的规范名称是 <code>Nil</code>，它宣布列表的终止。</p>
<p>下面这段代码是<mark class="label danger">不能编译通过</mark>的，编译提示我们这个类型大小<mark class="label danger">无限大</mark>：</p>
<p><img data-src="recursive-list.png" alt="错误递归类型" /></p>
<p>另外编译器还提醒我们，不能直接存储一个值，而是应该存储一个指向这个值的指针，还提示我们应该用 <code>Box&lt;List&gt;</code>：</p>
<pre><code>= help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
make `List` representable
</code></pre>
<p>因为 <code>Box&lt;T&gt;</code> 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变，我们对上面的程序做出修改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rct-引用计数"><a class="markdownIt-Anchor" href="#rct-引用计数"></a> Rc<T> 引用计数</h4>
<p>大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的节点，而这个节点从概念上讲为所有指向它的边所拥有。节点直到没有任何边指向它之前都不应该被清理。</p>
<p>为了启用多所有权，Rust 有一个叫做 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> 的类型。其名称为 引用计数（reference counting）的缩写。引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p>
<p>可以将其想象为客厅中的电视。当一个人进来看电视时，他打开电视。其他人也可以进来看电视。当最后一个人离开房间时，他关掉电视因为它不再被使用了。如果某人在其他人还在看的时候就关掉了电视，正在看电视的人肯定会抓狂的！</p>
<p><code>Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。</p>
<blockquote>
<p><code>Rc&lt;T&gt;</code> 只能用于单线程场景</p>
</blockquote>
<h5 id="使用-rct-共享数据"><a class="markdownIt-Anchor" href="#使用-rct-共享数据"></a> 使用 <code>Rc&lt;T&gt;</code> 共享数据</h5>
<p>我们继续看上面的例子，这一次，我们希望创建两个共享第三个列表所有权的列表，其概念将会看起来如下图所示：</p>
<p><img data-src="rct-example.svg" alt="Rc共享数据" /></p>
<p>我们使用之前的 <code>Box&lt;List&gt;</code> 尝试时，发现<mark class="label danger">编译失败</mark>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>,</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>,</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="rct-example-failed.png" alt="RcBox例子失败" /></p>
<p>我们修改 <code>List</code> 的定义为使用 <code>Rc&lt;T&gt;</code> 代替 <code>Box&lt;T&gt;</code>，现在每一个 <code>Cons</code> 变量都包含一个值和一个指向 <code>List</code> 的 <code>Rc&lt;T&gt;</code>。当创建 <code>b</code> 时，不同于获取 <code>a</code> 的所有权，这里会克隆 <code>a</code> 所包含的 <code>Rc&lt;List&gt;</code>，这会将引用计数从 <code>1</code> 增加到 <code>2</code> 并允许 <code>a</code> 和 <code>b</code> 共享 <code>Rc&lt;List&gt;</code> 中数据的所有权。创建 <code>c</code> 时也会克隆 <code>a</code>，这会将引用计数从 <code>2</code> 增加为 <code>3</code>。每次调用 <code>Rc::clone</code>，<code>Rc&lt;List&gt;</code> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b: &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="rcstrong_count"><a class="markdownIt-Anchor" href="#rcstrong_count"></a> Rc::strong_count</h5>
<p>可以使用 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/alloc/rc/struct.Rc.html#method.strong_count"><code>Rc::strong_count</code></a> 查看 <code>Rc&lt;T&gt;</code> 的引用计数值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将输出：</p>
<pre><code>count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<h4 id="refcell"><a class="markdownIt-Anchor" href="#refcell"></a> RefCell</h4>
<p>内部可变性（Interior mutability）是 Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。不同于 <code>Rc&lt;T&gt;</code>，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> 代表其数据的唯一的所有权。我们之前学习的借用规则是这样的：</p>
<ul>
<li>在任意给定时刻，只能拥有一个可变引用或任意数量的不可变引用之一（而不是两者）。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>对于引用和 <code>Box&lt;T&gt;</code>，借用规则的不可变性作用于编译时。对于 <code>RefCell&lt;T&gt;</code>，这些不可变性作用于运行时。对于引用，如果违反这些规则，会得到一个编译错误。而对于 <code>RefCell&lt;T&gt;</code>，如果违反这些规则程序会 <code>panic</code> 并退出。</p>
<p>在编译时检查借用规则的优势是这些错误将在开发过程的早期被捕获，同时对运行时没有性能影响，因为所有的分析都提前完成了。为此，在编译时检查借用规则是大部分情况的最佳选择，这也正是其为何是 Rust 的默认行为。相反在运行时检查借用规则的好处则是允许出现特定内存安全的场景，而它们在编译时检查中是不允许的。静态分析，正如 Rust 编译器，是天生保守的。</p>
<p>因为一些分析是不可能的，如果 Rust 编译器不能通过所有权规则编译，它可能会拒绝一个正确的程序；从这种角度考虑它是保守的。如果 Rust 接受不正确的程序，那么用户也就不会相信 Rust 所做的保证了。然而，如果 Rust 拒绝正确的程序，虽然会给程序员带来不便，但不会带来灾难。<code>RefCell&lt;T&gt;</code> 正是用于当你确信代码遵守借用规则，而编译器不能理解和确定的时候。</p>
<p>如下为选择 <code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由：</p>
<ul>
<li><code>Rc&lt;T&gt;</code> 允许相同数据有多个所有者；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 有单一所有者。</li>
<li><code>Box&lt;T&gt;</code> 允许在编译时执行不可变或可变借用检查；<code>Rc&lt;T&gt;</code> 仅允许在编译时执行不可变借用检查；<code>RefCell&lt;T&gt;</code> 允许在运行时执行不可变或可变借用检查。</li>
<li>因为 <code>RefCell&lt;T&gt;</code> 允许在运行时执行可变借用检查，所以我们可以在即便 <code>RefCell&lt;T&gt;</code> 自身是不可变的情况下修改其内部的值。</li>
</ul>
<blockquote>
<p><code>RefCell&lt;T&gt;</code> 只能用于单线程场景</p>
</blockquote>
<p>来看一个例子，我们定义了 <code>Messenger</code> 用于发送消息，真实场景可能是发送短信或者发送邮件，注意它的 <code>receiver</code> 是 <code>&amp;ref</code>；然后我们定义结构体 <code>LimitTracker</code>，它用来实现我们的业务功能，当调用它的 <code>set_value</code> 方法时，根据业务逻辑发送不同的消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">LimitTracker</span>&lt;<span class="symbol">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    value: <span class="type">usize</span>,</span><br><span class="line">    max: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Messenger &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(messenger: &amp;T, max: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">percentage_of_max</span> = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">             <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们对 <code>LimitTracker</code> 的功能进行测试，但是肯定不能真正实现 <code>Messenger</code>，所以需要对其打桩，计划是对其进行 <code>Mock</code>，记录发送的消息，初步计划是这样的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        sent_messages: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: <span class="built_in">vec!</span>[] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mock_messenger</span> = MockMessenger::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">limit_tracker</span> = LimitTracker::<span class="title function_ invoke__">new</span>(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.<span class="title function_ invoke__">set_value</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不出意外，<mark class="label danger">编译失败</mark>，不能对不可变引用做修改：</p>
<p><img data-src="refcell-mock-failed.png" alt="编译失败" /></p>
<p>按照编译器的提示，改成这样，依然编译失败，<code>receiver</code> 类型不匹配：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="refcell-mock-failed-again.png" alt="编译失败" /></p>
<p>然后我们引出我们今天的大招，<code>RefCell</code>，看下面的修改，我们使用 <code>borrow_mut</code> 和 <code>borrow</code> 分别在运行时进行可变借用和不可变借用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="comment">// Vec&lt;String&gt; -&gt; RefCell&lt;Vec&lt;String&gt;&gt;</span></span><br><span class="line">        sent_messages: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="comment">// borrow_mut，可变借用</span></span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mock_messenger</span> = MockMessenger::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">limit_tracker</span> = LimitTracker::<span class="title function_ invoke__">new</span>(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.<span class="title function_ invoke__">set_value</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// borrow，不可变借用</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="refcell-mock-pass.png" alt="测试通过" /></p>
<h5 id="结合-rct-和-rccellt"><a class="markdownIt-Anchor" href="#结合-rct-和-rccellt"></a> 结合 Rc<code>&lt;</code>T<code>&gt;</code> 和 RcCell<code>&lt;</code>T<code>&gt;</code></h5>
<p><code>Rc&lt;T&gt;</code> 通过引用计数的方式可以让一个值有多个所有者，<code>RcCell&lt;T&gt;</code> 可以在运行时获取值的可变引用对其修改。下面的例子中，通过对 <code>value</code> 的修改，<code>a</code>，<code>b</code>，<code>c</code> 都改了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">6</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">10</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b: &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c: &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="rct-and-refcellt.png" alt="一处修改处处改" /></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="MichaelFu 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="MichaelFu 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>MichaelFu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/" title="【Rust】实战突破">https://blog.fudenglong.site/2021/09/05/Rust/【Rust】实战突破/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/rust%E5%9F%BA%E7%A1%80/" rel="tag"># rust基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/14/Rust/%E3%80%90Rust%E3%80%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="next" title="【Rust】生命周期">
                  【Rust】生命周期 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">辽ICP备15012817号-2 </a>
  </div>
  <div class="copyright">
    &copy; 2020 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MichaelFu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">21:31</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/gamelife1314" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/bookmark.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/search/local-search.min.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js"},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/tags/pdf.min.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"dark","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js"}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/tags/mermaid.min.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/fancybox.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/pace.min.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":false,"delay":true,"timeout":5000,"priority":true,"url":"https://blog.fudenglong.site/2021/09/05/Rust/%E3%80%90Rust%E3%80%91%E5%AE%9E%E6%88%98%E7%AA%81%E7%A0%B4/"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/quicklink.min.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"gamelife1314/gamelife1314.github.io","issue_term":"title","theme":"github-light"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/comments/utterances.min.js"></script>

</body>
</html>
