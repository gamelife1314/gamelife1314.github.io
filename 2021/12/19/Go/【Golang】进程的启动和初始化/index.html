<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta name="google-site-verification" content="lk2gSYFP_NyLNFob-fFnt7fm-I_n1ZYws-WZll7mshg">
  <meta name="msvalidate.01" content="6Jdc01DjYOLguhS5">
  <meta name="baidu-site-verification" content="code-NR10G09zww">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7Ccursive:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/yellow/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.fudenglong.site","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":800},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/local-search.xml","localsearch":{"enable":true,"top_n_per_article":10,"unescape":false,"preload":true,"trigger":"auto"}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script>

    <meta name="description" content="本篇文章记录 Go 进程的启动和初始化过程，从程序入口开始调试，探索 Go 的各个组件初始化，以最简单的 hello world 为示例。">
<meta property="og:type" content="article">
<meta property="og:title" content="【Golang】进程初始化和调度系统">
<meta property="og:url" content="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/index.html">
<meta property="og:site_name" content="MichaelFu">
<meta property="og:description" content="本篇文章记录 Go 进程的启动和初始化过程，从程序入口开始调试，探索 Go 的各个组件初始化，以最简单的 hello world 为示例。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/image.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/go%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/p-status.png">
<meta property="og:image" content="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF.jpg">
<meta property="article:published_time" content="2021-12-19T12:36:34.000Z">
<meta property="article:modified_time" content="2021-12-19T12:36:34.000Z">
<meta property="article:author" content="MichaelFu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/image.png">


<link rel="canonical" href="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/","path":"2021/12/19/Go/【Golang】进程的启动和初始化/","title":"【Golang】进程初始化和调度系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>【Golang】进程初始化和调度系统 | MichaelFu</title>
  







<script async src="/lib/fireworks.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MichaelFu</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好记性不如烂笔头</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-云-&nbsp;&nbsp;原-&nbsp;&nbsp;生"><a href="/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="section"><i class="fa fa-cloud fa-fw"></i>云 &nbsp;&nbsp;原 &nbsp;&nbsp;生</a></li><li class="menu-item menu-item-rust-编程"><a href="/Programming-Rust/" rel="section"><i class="fa fa-cat fa-fw"></i>Rust 编程</a></li><li class="menu-item menu-item-go-&nbsp;&nbsp;&nbsp;编程"><a href="/Programming-Go/" rel="section"><i class="fa fa-hippo fa-fw"></i>Go &nbsp;&nbsp;&nbsp;编程</a></li><li class="menu-item menu-item-前端知识"><a href="https://wshuhua.github.io/" rel="section" target="_blank"><i class="fa fa-sun fa-fw"></i>前端知识</a></li><li class="menu-item menu-item-leetcode-rust"><a href="/Leetcode-Rust/" rel="section"><i class="fa fa-book fa-fw"></i>Leetcode-Rust</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text"> 程序入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text"> 启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#g0-%E5%92%8C-m0"><span class="nav-number">2.1.</span> <span class="nav-text"> g0 和 m0</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6"><span class="nav-number">3.</span> <span class="nav-text"> 并发调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#gpm"><span class="nav-number">3.1.</span> <span class="nav-text"> GPM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#m"><span class="nav-number">3.1.1.</span> <span class="nav-text"> M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#p"><span class="nav-number">3.1.2.</span> <span class="nav-text"> P</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#gomaxprocs"><span class="nav-number">3.1.2.1.</span> <span class="nav-text"> GOMAXPROCS</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#g"><span class="nav-number">3.1.3.</span> <span class="nav-text"> G</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sched"><span class="nav-number">3.1.4.</span> <span class="nav-text"> sched</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.2.</span> <span class="nav-text"> 调度循环</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#m-%E5%92%8C-p-%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="nav-number">3.2.1.</span> <span class="nav-text"> M 和 P 的绑定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#m-%E7%9A%84%E6%9A%82%E6%AD%A2%E5%92%8C%E5%A4%8D%E5%A7%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text"> M 的暂止和复始</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E8%B0%83%E5%BA%A6"><span class="nav-number">3.2.3.</span> <span class="nav-text"> 核心调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%81%B7%E5%8F%96-goroutine"><span class="nav-number">3.2.4.</span> <span class="nav-text"> 偷取 Goroutine</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%94%A4%E9%86%92m"><span class="nav-number">3.2.5.</span> <span class="nav-text"> 唤醒M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B0%E5%BB%BAm"><span class="nav-number">3.2.6.</span> <span class="nav-text"> 新建M</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mg-%E8%A7%A3%E7%BB%91"><span class="nav-number">3.2.7.</span> <span class="nav-text"> M&#x2F;G 解绑</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7"><span class="nav-number">3.3.</span> <span class="nav-text"> 系统监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text"> 线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lockosthread"><span class="nav-number">3.4.1.</span> <span class="nav-text"> LockOSThread</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unlockosthread"><span class="nav-number">3.4.2.</span> <span class="nav-text"> UnlockOSThread</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">4.</span> <span class="nav-text"> 参考链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MichaelFu"
      src="/avatar.jpeg">
  <p class="site-author-name" itemprop="name">MichaelFu</p>
  <div class="site-description" itemprop="description">实践能让记忆更深刻</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gamelife1314" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gamelife1314" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:michael.fudenglong@qq.com" title="E-Mail → mailto:michael.fudenglong@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://www.rust-lang.org/zh-CN/" title="https:&#x2F;&#x2F;www.rust-lang.org&#x2F;zh-CN&#x2F;" rel="noopener" target="_blank">Rust</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://go.dev/" title="https:&#x2F;&#x2F;go.dev&#x2F;" rel="noopener" target="_blank">Golang</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.python.org/" title="https:&#x2F;&#x2F;www.python.org&#x2F;" rel="noopener" target="_blank">Python</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://doc.rust-lang.org/cargo/index.html" title="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;index.html" rel="noopener" target="_blank">Cargo</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://gist.github.com/rxaviers/7360908" title="https:&#x2F;&#x2F;gist.github.com&#x2F;rxaviers&#x2F;7360908" rel="noopener" target="_blank">Emoji</a>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpeg">
      <meta itemprop="name" content="MichaelFu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MichaelFu">
      <meta itemprop="description" content="实践能让记忆更深刻">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="【Golang】进程初始化和调度系统 | MichaelFu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Golang】进程初始化和调度系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-19 20:36:34" itemprop="dateCreated datePublished" datetime="2021-12-19T20:36:34+08:00">2021-12-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:01</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本篇文章记录 <code>Go</code> 进程的启动和初始化过程，从程序入口开始调试，探索 <code>Go</code> 的各个组件初始化，以最简单的 <code>hello world</code> 为示例。</p>
<img data-src="/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/image.png" class="">
<span id="more"></span>
<h3 id="程序入口"><a class="markdownIt-Anchor" href="#程序入口"></a> 程序入口</h3>
<p>以 <code>linux</code> 操作系统为例，程序编译之后生成可执行文件，可执行文件的格式在 <code>linux</code> 上是 <code>ELF</code>，<code>Windows</code> 上是 <code>PE</code>，<code>linux</code> 通过 <code>readelf</code> 工具查看程序的入口地址，操作系统执行可执行文件的时候，首先解析 <code>ELF Header</code>，然后从 <code>entry point</code> 开始执行代码，通过 <a target="_blank" rel="noopener" href="https://github.com/go-delve/delve"><code>delve</code></a> 执行程序，在入口处打断点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@b89af2baca14:/WORKDIR/gostudy/hello# readelf -h main</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x701d0            // 程序入口地址</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          456 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         7</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         23</span><br><span class="line">  Section header string table index: 3</span><br><span class="line">root@b89af2baca14:/WORKDIR/gostudy/hello#</span><br><span class="line">root@b89af2baca14:/WORKDIR/gostudy/hello# dlv exec ./main</span><br><span class="line">Type &#x27;help&#x27; for list of commands.</span><br><span class="line">(dlv) b *0x701d0</span><br><span class="line">Breakpoint 1 set at 0x701d0 for _rt0_arm64_linux() /usr/local/go/src/runtime/rt0_linux_arm64.s:8</span><br><span class="line">(dlv)</span><br></pre></td></tr></table></figure>
<p>关于 <code>ELF</code> 可执行文件的描述可以参考下面的<a target="_blank" rel="noopener" href="https://github.com/corkami/pics/blob/28cb0226093ed57b348723bc473cea0162dad366/binary/elf101/elf101.pdf"><code>pdf</code>文件</a>。当然还可以通过 <a target="_blank" rel="noopener" href="https://visualgdb.com/gdbreference/commands/info_files"><code>GDB</code></a> 获得程序的入口地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info files</span><br><span class="line">Symbols from &quot;/WORKDIR/gostudy/hello/main&quot;.</span><br><span class="line">Local exec file:</span><br><span class="line">	`/WORKDIR/gostudy/hello/main&#x27;, file type elf64-littleaarch64.</span><br><span class="line">	Entry point: 0x701d0                            // 程序入口地址</span><br><span class="line">	0x0000000000011000 - 0x0000000000094220 is .text</span><br><span class="line">	0x00000000000a0000 - 0x00000000000d51a3 is .rodata</span><br><span class="line">	0x00000000000d5340 - 0x00000000000d5824 is .typelink</span><br><span class="line">	0x00000000000d5840 - 0x00000000000d5898 is .itablink</span><br><span class="line">	0x00000000000d5898 - 0x00000000000d5898 is .gosymtab</span><br><span class="line">	0x00000000000d58a0 - 0x000000000012a160 is .gopclntab</span><br><span class="line">	0x0000000000130000 - 0x0000000000130020 is .go.buildinfo</span><br><span class="line">	0x0000000000130020 - 0x0000000000140580 is .noptrdata</span><br><span class="line">	0x0000000000140580 - 0x0000000000147d50 is .data</span><br><span class="line">	0x0000000000147d60 - 0x0000000000176b48 is .bss</span><br><span class="line">	0x0000000000176b60 - 0x000000000017bde0 is .noptrbss</span><br><span class="line">	0x0000000000010f9c - 0x0000000000011000 is .note.go.buildid</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<h3 id="启动流程"><a class="markdownIt-Anchor" href="#启动流程"></a> 启动流程</h3>
<p>实验环境信息如下：</p>
<ul>
<li>
<p>Darwin fudenglongdeMacBook-Pro.local 21.2.0 Darwin Kernel Version 21.2.0: Sun Nov 28 20:28:41 PST 2021; root:xnu-8019.61.5~1/RELEASE_ARM64_T6000 arm64</p>
</li>
<li>
<p>go version go1.17.5 linux/arm64</p>
</li>
</ul>
<p>通过单步调试，将程序从启动到执行 <code>main.main</code> 函数的全部流程全部总结如下：</p>
<p><img data-src="go%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="" /></p>
<h4 id="g0-和-m0"><a class="markdownIt-Anchor" href="#g0-和-m0"></a> <code>g0</code> 和 <code>m0</code></h4>
<p>在进程启动的开始就完成了 <code>g0</code> 和 <code>m0</code> 的初始化，这两个是运行时的全局变量，定义在 <code>proc.go</code> 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc.go</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  m0           m</span><br><span class="line">  g0           g</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>m0</strong>，<code>m0</code> 表示进程启动的第一个线程，也叫主线程。它和其他的 <code>m</code> 没有什么区别，进程启动通过汇编直接赋值；</p>
</li>
<li>
<p><strong>g0</strong>，每个 <code>m</code> 都有一个 <code>g0</code>，因为每个线程有一个系统堆栈，g0的主要作用是提供一个栈供 <code>runtime</code> 代码执行，调度器就运行在 <code>g0</code> 上；</p>
</li>
</ul>
<p>其中全局 <code>g0</code> 的初始化如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// asm_am664.s</span><br><span class="line">// create istack out of the given (operating system) stack.</span><br><span class="line">// _cgo_init may update stackguard.</span><br><span class="line">MOVQ   $runtime·g0(SB), DI      //g0的地址放入DI寄存器</span><br><span class="line">LEAQ   (-64*1024+104)(SP), BX   //BX = SP - 64*1024 + 104</span><br><span class="line">MOVQ   BX, g_stackguard0(DI)    //g0.stackguard0 = SP - 64*1024 + 104</span><br><span class="line">MOVQ   BX, g_stackguard1(DI)     //g0.stackguard1 = SP - 64*1024 + 104</span><br><span class="line">MOVQ   BX, (g_stack+stack_lo)(DI)  //g0.stack.lo = SP - 64*1024 + 104</span><br><span class="line">MOVQ   SP, (g_stack+stack_hi)(DI)  //g0.stack.hi = SP</span><br></pre></td></tr></table></figure>
<p>设置好 <code>g0</code> 相关的信息之后，在 <code>x86</code> 系统上还会设置线程的 <code>Fs_base</code> 寄存器，但是在 <code>arm64</code> 上，仅仅完成了 <code>m0</code> 和 <code>g0</code> 的相互绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// set the per-goroutine and per-mach &quot;registers&quot;</span><br><span class="line">MOVD	$runtime·m0(SB), R0</span><br><span class="line"></span><br><span class="line">// save m-&gt;g0 = g0</span><br><span class="line">MOVD	g, m_g0(R0)</span><br><span class="line">// save m0 to g0-&gt;m</span><br><span class="line">MOVD	R0, g_m(g)</span><br></pre></td></tr></table></figure>
<h3 id="并发调度"><a class="markdownIt-Anchor" href="#并发调度"></a> 并发调度</h3>
<p>相比其他语言复杂的并发系统设计，Go语言中在面向用户时，仅提供一个 <code>go</code> 关键字即可实现异步任务和并发调度，但是因其简单，所以在一般系统中，百万级别的 <code>g</code> 也是常有的，为了保证这些 <code>goroutine</code> 的公平调度，不饿死也不撑死，所以得有一套公平的调度系统，在经历了初期几代的发展之后，现在逐渐形成了当前的 <code>GPM</code> 模型。</p>
<h4 id="gpm"><a class="markdownIt-Anchor" href="#gpm"></a> <code>GPM</code></h4>
<p>理解调度器首先要理解三个主要概念：</p>
<ul>
<li><code>G</code>: <code>Goroutine</code>，即我们在 <code>Go</code> 程序中使用 <code>go</code> 关键字创建的执行体；</li>
<li><code>M</code>: <code>Machine</code>，或 worker thread，即传统意义上进程的线程；</li>
<li><code>P</code>: <code>Processor</code>，即一种人为抽象的、用于执行 <code>Go</code> 代码被要求的局部资源。只有当 <code>M</code> 与一个 <code>P</code> 关联后才能执行 <code>Go</code> 代码。<code>M</code> 发生阻塞或在进行系统调用时间过长时，是没有与之关联的 <code>P</code>；</li>
</ul>
<p>在这种GPM模型中，数量相对固定的是 <code>P</code>，大多数情况下都是和 <code>CPU</code> 数量相等，多了也没有意义。而 <code>M</code> 和 <code>G</code> 的数量是动态的，在调度初始化中，只设置了 <code>M</code> 的上限是 <code>10000</code>；对于<code>G</code>而言浮动范围就相对较大，少则数百，多则可能达到百万级别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sched.maxmcount = <span class="number">10000</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="m"><a class="markdownIt-Anchor" href="#m"></a> <code>M</code></h5>
<p><code>M</code> 是 <code>OS</code> 线程的实体，它的结构体字段有60多个，定义在 <code>runtime2.go</code> 文件中，但是它有一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go </span></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0          *g          <span class="comment">// 执行调度器指令的Goroutine，每个M都有一个g0</span></span><br><span class="line">    gsignal     *g          <span class="comment">// 处理信号的G</span></span><br><span class="line">    tls         [<span class="number">6</span>]<span class="type">uintptr</span>	<span class="comment">// 线程本地存储，在ARM64处理器上貌似没有用到</span></span><br><span class="line">    curg        *g			<span class="comment">// 当前运行的用户 Goroutine</span></span><br><span class="line">    p           puintptr	<span class="comment">// 执行 go 代码时持有的 p (如果没有执行则为 nil)</span></span><br><span class="line">    spinning    <span class="type">bool</span>		<span class="comment">// m 当前没有运行 work 且正处于寻找 work 的活跃状态</span></span><br><span class="line">    cgoCallers  *cgoCallers	<span class="comment">// cgo 调用崩溃的 cgo 回溯</span></span><br><span class="line">    alllink     *m			<span class="comment">// 在 allm 上</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Go</code>中<code>M</code>只有两个状态：自旋还是非自旋。M的初始化是在 <code>mcommoninit</code> 函数中进行，不管是系统刚运行起来时，主线 <code>m0</code> 的初始化还是新建 <code>M</code> 的初始化都会调用这个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mcommoninit</span><span class="params">(mp *m, id <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// g0 stack won&#x27;t make sense for user (and is not necessary unwindable).</span></span><br><span class="line">  <span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">    callers(<span class="number">1</span>, mp.createstack[:])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置ID</span></span><br><span class="line">  <span class="keyword">if</span> id &gt;= <span class="number">0</span> &#123;</span><br><span class="line">    mp.id = id</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mp.id = mReserveID()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mp.fastrand[<span class="number">0</span>] = <span class="type">uint32</span>(int64Hash(<span class="type">uint64</span>(mp.id), fastrandseed))</span><br><span class="line">  mp.fastrand[<span class="number">1</span>] = <span class="type">uint32</span>(int64Hash(<span class="type">uint64</span>(cputicks()), ^fastrandseed))</span><br><span class="line">  <span class="keyword">if</span> mp.fastrand[<span class="number">0</span>]|mp.fastrand[<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">    mp.fastrand[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// func mpreinit(mp *m) &#123;</span></span><br><span class="line">    <span class="comment">//     mp.gsignal = malg(32 * 1024) // OS X wants &gt;= 8K</span></span><br><span class="line">    <span class="comment">//     mp.gsignal.m = mp</span></span><br><span class="line">    <span class="comment">//     if GOOS == &quot;darwin&quot; &amp;&amp; GOARCH == &quot;arm64&quot; &#123;</span></span><br><span class="line">    <span class="comment">//         // mlock the signal stack to work around a kernel bug where it may</span></span><br><span class="line">    <span class="comment">//         // SIGILL when the signal stack is not faulted in while a signal</span></span><br><span class="line">    <span class="comment">//         // arrives. See issue 42774.</span></span><br><span class="line">    <span class="comment">//         mlock(unsafe.Pointer(mp.gsignal.stack.hi-physPageSize), physPageSize)</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 创建信号处理的Goroutine</span></span><br><span class="line">  mpreinit(mp)</span><br><span class="line">  <span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">    mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加到 allm 中，从而当它刚保存到寄存器或本地线程存储时候 GC 不会释放 g.m</span></span><br><span class="line">  mp.alllink = allm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NumCgoCall() iterates over allm w/o schedlock,</span></span><br><span class="line">  <span class="comment">// so we need to publish it safely.</span></span><br><span class="line">  atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</span><br><span class="line">  unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate memory to hold a cgo traceback if the cgo call crashes.</span></span><br><span class="line">  <span class="keyword">if</span> iscgo || GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">    mp.cgoCallers = <span class="built_in">new</span>(cgoCallers)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="p"><a class="markdownIt-Anchor" href="#p"></a> <code>P</code></h5>
<p><code>P</code> 只是处理器的一种抽象，而并非真正的处理器，它是可以通过 <code>runtime</code> 提供的方法动态调整的，用来实现 work stealing，每个 <code>P</code> 都持有一个<code>G</code>的本地队列。如果没有<code>P</code>的存在，所有的<code>G</code>只能放在全局的队列中，当<code>M</code>执行完一个<code>G</code>，必须锁住全局队列然后取下一个<code>G</code>拿来运行，这会严重降低运行效率。当有了 <code>P</code> 之后，每个<code>P</code>都有一个存储 <code>G</code> 的本地队列，当和 <code>P</code> 关联的 <code>M</code> 运行完一个 <code>G</code> 之后，它会按照：当前P的本地队列、全局、网络、偷取的方式获取一个可运行的 <code>G</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	id          <span class="type">int32</span></span><br><span class="line">	status      <span class="type">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">	link        puintptr</span><br><span class="line">	schedtick   <span class="type">uint32</span>     <span class="comment">// incremented on every scheduler call</span></span><br><span class="line">	syscalltick <span class="type">uint32</span>     <span class="comment">// incremented on every system call</span></span><br><span class="line">	sysmontick  sysmontick <span class="comment">// last tick observed by sysmon</span></span><br><span class="line">	m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line">	mcache      *mcache</span><br><span class="line">	pcache      pageCache</span><br><span class="line">	raceprocctx <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	deferpool    [<span class="number">5</span>][]*_defer <span class="comment">// pool of available defer structs of different sizes (see panic.go)</span></span><br><span class="line">	deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">	goidcache    <span class="type">uint64</span></span><br><span class="line">	goidcacheend <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 无锁访问可运行G队列</span></span><br><span class="line">	runqhead <span class="type">uint32</span></span><br><span class="line">	runqtail <span class="type">uint32</span></span><br><span class="line">	runq     [<span class="number">256</span>]guintptr</span><br><span class="line">	<span class="comment">// runnext, if non-nil, is a runnable G that was ready&#x27;d by</span></span><br><span class="line">	<span class="comment">// the current G and should be run next instead of what&#x27;s in</span></span><br><span class="line">	<span class="comment">// runq if there&#x27;s time remaining in the running G&#x27;s time</span></span><br><span class="line">	<span class="comment">// slice. It will inherit the time left in the current time</span></span><br><span class="line">	<span class="comment">// slice. If a set of goroutines is locked in a</span></span><br><span class="line">	<span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">	<span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">	<span class="comment">// latency that otherwise arises from adding the ready&#x27;d</span></span><br><span class="line">	<span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Note that while other P&#x27;s may atomically CAS this to zero,</span></span><br><span class="line">	<span class="comment">// only the owner P can CAS it to a valid G.</span></span><br><span class="line">	runnext guintptr</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可用的G，状态都是 _Gdead，可以用来复用</span></span><br><span class="line">	gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">		gList</span><br><span class="line">		n <span class="type">int32</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sudogcache []*sudog</span><br><span class="line">	sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache of mspan objects from the heap.</span></span><br><span class="line">	mspancache <span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="comment">// We need an explicit length here because this field is used</span></span><br><span class="line">		<span class="comment">// in allocation codepaths where write barriers are not allowed,</span></span><br><span class="line">		<span class="comment">// and eliminating the write barrier/keeping it eliminated from</span></span><br><span class="line">		<span class="comment">// slice updates is tricky, moreso than just managing the length</span></span><br><span class="line">		<span class="comment">// ourselves.</span></span><br><span class="line">		<span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">		buf [<span class="number">128</span>]*mspan</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tracebuf traceBufPtr</span><br><span class="line"></span><br><span class="line">	<span class="comment">// traceSweep indicates the sweep events should be traced.</span></span><br><span class="line">	<span class="comment">// This is used to defer the sweep start event until a span</span></span><br><span class="line">	<span class="comment">// has actually been swept.</span></span><br><span class="line">	traceSweep <span class="type">bool</span></span><br><span class="line">	<span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span><br><span class="line">	<span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span><br><span class="line">	traceSwept, traceReclaimed <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">	_ <span class="type">uint32</span> <span class="comment">// Alignment for atomic fields below</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The when field of the first entry on the timer heap.</span></span><br><span class="line">	<span class="comment">// This is updated using atomic functions.</span></span><br><span class="line">	<span class="comment">// This is 0 if the timer heap is empty.</span></span><br><span class="line">	timer0When <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The earliest known nextwhen field of a timer with</span></span><br><span class="line">	<span class="comment">// timerModifiedEarlier status. Because the timer may have been</span></span><br><span class="line">	<span class="comment">// modified again, there need not be any timer with this value.</span></span><br><span class="line">	<span class="comment">// This is updated using atomic functions.</span></span><br><span class="line">	<span class="comment">// This is 0 if there are no timerModifiedEarlier timers.</span></span><br><span class="line">	timerModifiedEarliest <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-P GC state</span></span><br><span class="line">	gcAssistTime         <span class="type">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">	gcFractionalMarkTime <span class="type">int64</span> <span class="comment">// Nanoseconds in fractional mark worker (atomic)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcMarkWorkerMode is the mode for the next mark worker to run in.</span></span><br><span class="line">	<span class="comment">// That is, this is used to communicate with the worker goroutine</span></span><br><span class="line">	<span class="comment">// selected for immediate execution by</span></span><br><span class="line">	<span class="comment">// gcController.findRunnableGCWorker. When scheduling other goroutines,</span></span><br><span class="line">	<span class="comment">// this field must be set to gcMarkWorkerNotWorker.</span></span><br><span class="line">	gcMarkWorkerMode gcMarkWorkerMode</span><br><span class="line">	<span class="comment">// gcMarkWorkerStartTime is the nanotime() at which the most recent</span></span><br><span class="line">	<span class="comment">// mark worker started.</span></span><br><span class="line">	gcMarkWorkerStartTime <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcw is this P&#x27;s GC work buffer cache. The work buffer is</span></span><br><span class="line">	<span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">	<span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">	gcw gcWork</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wbBuf is this P&#x27;s GC write barrier buffer.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line">	wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">	runSafePointFn <span class="type">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// statsSeq is a counter indicating whether this P is currently</span></span><br><span class="line">	<span class="comment">// writing any stats. Its value is even when not, odd when it is.</span></span><br><span class="line">	statsSeq <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lock for timers. We normally access the timers while running</span></span><br><span class="line">	<span class="comment">// on this P, but the scheduler can also do it from a different P.</span></span><br><span class="line">	timersLock mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Actions to take at some time. This is used to implement the</span></span><br><span class="line">	<span class="comment">// standard library&#x27;s time package.</span></span><br><span class="line">	<span class="comment">// Must hold timersLock to access.</span></span><br><span class="line">	timers []*timer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of timers in P&#x27;s heap.</span></span><br><span class="line">	<span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">	numTimers <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of timerDeleted timers in P&#x27;s heap.</span></span><br><span class="line">	<span class="comment">// Modified using atomic instructions.</span></span><br><span class="line">	deletedTimers <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Race context used while executing timer functions.</span></span><br><span class="line">	timerRaceCtx <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// preempt is set to indicate that this P should be enter the</span></span><br><span class="line">	<span class="comment">// scheduler ASAP (regardless of what G is running on it).</span></span><br><span class="line">	preempt <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Padding is no longer needed. False sharing is now not a worry because p is large enough</span></span><br><span class="line">	<span class="comment">// that its size class is an integer multiple of the cache line size (for any of our architectures).</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前情况下，<code>P</code> 一共有四种状态，<code>_Pidle</code>，<code>_Prunning</code>，<code>_Psyscall</code>，<code>_Pgcstop</code> 和 <code>_Pdead</code>：</p>
<ul>
<li>
<p><code>_Pidle</code>：表示没有使用 <code>P</code> 来运行用户代码或调度程序。通常，它位于空闲 <code>P</code> 列表中并且可供调度程序使用，但它可能只是在其他状态之间转换，空闲状态下它的 <code>runq</code> 队列是空的。</p>
</li>
<li>
<p><code>_Prunning</code>：表示 <code>P</code>正在被 <code>M</code> 持有运行用户代码或者调度器。只有当 <code>M</code> 持有 <code>P</code> 时，它的状态才被允许修改到 <code>_Prunning</code>。如果没有活干，那么<code>P</code>将切换到 <code>_Pidle</code> 状态；当进行系统调用的时候会切换到 <code>_Psyscall</code>；<code>GC</code> 期间会切换到 <code>_Pgcstop</code>；<code>M</code> 也可以将 <code>P</code> 的所有权直接交给另一个 <code>M</code>（例如，调度到锁定的 <code>G</code>）；</p>
</li>
<li>
<p><code>_Psyscall</code>：说明 <code>P</code> 没有在运行用户代码，它与系统调用中的 <code>M</code> 有亲和关系，但不属于它，并且可能被另一个 <code>M</code> 窃取。这与 <code>_Pidle</code> 类似，但使用轻量级转换并保持 <code>M</code> 亲缘关系;</p>
</li>
<li>
<p><code>_Pgcstop</code>：这意味着P由于STW而暂停并且被触发STW的M拥有；STW 的 <code>M</code> 会继续使用 <code>P</code>；从 <code>_Prunning</code> 转换到 <code>_Pgcstop</code> 会导致M释放它的P并且停止；<code>P</code> 会保留它的运行队列，starttheworld 将在具有非空运行队列的P上重启调度程序；</p>
</li>
<li>
<p><code>_Pdead</code>：这个状态说明P将不再被使用；如果 <code>GOMAXPROCS</code> 增加，这个P还将被重新使用；一个死的 P 大部分资源都会被剥夺。</p>
</li>
</ul>
<p>如果用一张图来说明 <code>P</code> 的状态转换，那么就如下所示：</p>
<p><img data-src="p-status.png" alt="" /></p>
<p>通常情况下（在程序运行时不调整<code>P</code>的个数），<code>P</code>只会在四种状态下进行切换。 当程序刚开始运行进行初始化时，所有的 <code>P</code> 都处于 <code>_Pgcstop</code> 状态， 随着<code>P</code>的初始化（在<code>runtime.procresize</code>），会被置于 <code>_Pidle</code>。</p>
<p>当<code>M</code>需要运行时，会<code>runtime.acquirep</code>，并通过<code>runtime.releasep</code>来释放。 当<code>G</code>执行时需要进入系统调用时，<code>P</code>会被设置为<code>_Psyscall</code>， 如果这个时候被系统监控抢夺（<code>runtime.retake</code>），则<code>P</code>会被重新修改为<code>_Pidle</code>。 如果在程序运行中发生<code>GC</code>，则<code>P</code>会被设置为<code>_Pgcstop</code>， 并在<code>runtime.startTheWorld</code> 时重新调整为<code>_Pidle</code>或者<code>_Prunning</code>。</p>
<p><code>P</code>的初始化是在 <code>runtime.procresize</code> 函数中进行的，位于 <code>proc.go</code> 文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="type">int32</span>)</span></span> *p &#123;</span><br><span class="line">  assertLockHeld(&amp;sched.lock)</span><br><span class="line">  assertWorldStopped()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取先前的 P 个数</span></span><br><span class="line">  old := gomaxprocs</span><br><span class="line">  <span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;procresize: invalid arg&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">    traceGomaxprocs(nprocs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新统计信息，记录此次修改 gomaxprocs 的时间</span></span><br><span class="line">  now := nanotime()</span><br><span class="line">  <span class="keyword">if</span> sched.procresizetime != <span class="number">0</span> &#123;</span><br><span class="line">    sched.totaltime += <span class="type">int64</span>(old) * (now - sched.procresizetime)</span><br><span class="line">  &#125;</span><br><span class="line">  sched.procresizetime = now</span><br><span class="line"></span><br><span class="line">  maskWords := (nprocs + <span class="number">31</span>) / <span class="number">32</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 必要时增加 allp</span></span><br><span class="line">   <span class="comment">// 这个时候本质上是在检查用户代码是否有调用过 runtime.MAXGOPROCS 调整 p 的数量</span></span><br><span class="line">   <span class="comment">// 此处多一步检查是为了避免内部的锁，如果 nprocs 明显小于 allp 的可见数量（因为 len）</span></span><br><span class="line">   <span class="comment">// 则不需要进行加锁</span></span><br><span class="line">  <span class="keyword">if</span> nprocs &gt; <span class="type">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line">    <span class="comment">// 此处与 retake 同步，它可以同时运行，因为它不会在 P 上运行。</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">if</span> nprocs &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">        <span class="comment">// 如果 nprocs 被调小了，扔掉多余的 p</span></span><br><span class="line">      allp = allp[:nprocs]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则（调大了）创建更多的 p</span></span><br><span class="line">      nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line">      <span class="comment">// 将原有的 p 复制到新创建的 new all p 中，不浪费旧的 p</span></span><br><span class="line">      <span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">      allp = nallp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> maskWords &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(idlepMask)) &#123;</span><br><span class="line">      idlepMask = idlepMask[:maskWords]</span><br><span class="line">      timerpMask = timerpMask[:maskWords]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nidlepMask := <span class="built_in">make</span>([]<span class="type">uint32</span>, maskWords)</span><br><span class="line">      <span class="comment">// No need to copy beyond len, old Ps are irrelevant.</span></span><br><span class="line">      <span class="built_in">copy</span>(nidlepMask, idlepMask)</span><br><span class="line">      idlepMask = nidlepMask</span><br><span class="line"></span><br><span class="line">      ntimerpMask := <span class="built_in">make</span>([]<span class="type">uint32</span>, maskWords)</span><br><span class="line">      <span class="built_in">copy</span>(ntimerpMask, timerpMask)</span><br><span class="line">      timerpMask = ntimerpMask</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化新的 P</span></span><br><span class="line">  <span class="keyword">for</span> i := old; i &lt; nprocs; i++ &#123;</span><br><span class="line">    pp := allp[i]</span><br><span class="line">    <span class="comment">// 如果 p 是新创建的(新创建的 p 在数组中为 nil)，则申请新的 P 对象</span></span><br><span class="line">    <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">      pp = <span class="built_in">new</span>(p)</span><br><span class="line">    &#125;</span><br><span class="line">    pp.init(i)</span><br><span class="line">    atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _g_ := getg()</span><br><span class="line">  <span class="comment">// 如果当前正在使用的 P 应该被释放，则更换为 allp[0]</span></span><br><span class="line">  <span class="comment">// 否则是初始化阶段，没有 P 绑定当前 P allp[0]</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;</span><br><span class="line">    <span class="comment">// 继续使用当前 P</span></span><br><span class="line">    _g_.m.p.ptr().status = _Prunning</span><br><span class="line">    _g_.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 释放当前 P，因为已失效</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        <span class="comment">// Pretend that we were descheduled</span></span><br><span class="line">        <span class="comment">// and then scheduled again to keep</span></span><br><span class="line">        <span class="comment">// the trace sane.</span></span><br><span class="line">        traceGoSched()</span><br><span class="line">        traceProcStop(_g_.m.p.ptr())</span><br><span class="line">      &#125;</span><br><span class="line">      _g_.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更换到 allp[0]</span></span><br><span class="line">    _g_.m.p = <span class="number">0</span></span><br><span class="line">    p := allp[<span class="number">0</span>]</span><br><span class="line">    p.m = <span class="number">0</span></span><br><span class="line">    p.status = _Pidle</span><br><span class="line">    <span class="comment">// 直接将 allp[0] 绑定到当前的 M</span></span><br><span class="line">    acquirep(p)</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">      traceGoStart()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mcache0 是在进程启动期间的mallocinit中初始化的，用于引导程序启动；</span></span><br><span class="line">  <span class="comment">// 到这里它就必要继续存在了，因为 gpm 已经关联，申请内存可以从每个P的mcache中进行了</span></span><br><span class="line">  mcache0 = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用不到的P就释放资源把</span></span><br><span class="line">  <span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">    p := allp[i]</span><br><span class="line">    p.destroy()</span><br><span class="line">    <span class="comment">// 不能释放 p 本身，因为他可能在 m 进入系统调用时被引用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trim allp.</span></span><br><span class="line">  <span class="keyword">if</span> <span class="type">int32</span>(<span class="built_in">len</span>(allp)) != nprocs &#123;</span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    allp = allp[:nprocs]</span><br><span class="line">    idlepMask = idlepMask[:maskWords]</span><br><span class="line">    timerpMask = timerpMask[:maskWords]</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将没有本地任务的 P 放到空闲链表中</span></span><br><span class="line">  <span class="keyword">var</span> runnablePs *p</span><br><span class="line">  <span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    p := allp[i]</span><br><span class="line">    <span class="comment">// 确保不是当前正在使用的 P</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放入 idle 链表</span></span><br><span class="line">    p.status = _Pidle</span><br><span class="line">    <span class="keyword">if</span> runqempty(p) &#123;</span><br><span class="line">      pidleput(p)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果有本地任务，则为其绑定一个 M</span></span><br><span class="line">      p.m.set(mget())</span><br><span class="line">      <span class="comment">// 第一个循环为 nil，后续则为上一个 p</span></span><br><span class="line">	  <span class="comment">// 此处即为构建可运行的 p 链表</span></span><br><span class="line">      p.link.set(runnablePs)</span><br><span class="line">      runnablePs = p</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stealOrder.reset(<span class="type">uint32</span>(nprocs))</span><br><span class="line">  <span class="keyword">var</span> int32p *<span class="type">int32</span> = &amp;gomaxprocs <span class="comment">// make compiler check that gomaxprocs is an int32</span></span><br><span class="line">  atomic.Store((*<span class="type">uint32</span>)(unsafe.Pointer(int32p)), <span class="type">uint32</span>(nprocs))</span><br><span class="line">  <span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P 的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span></span> init(id <span class="type">int32</span>) &#123;</span><br><span class="line">  <span class="comment">// p 的 id 就是它在 allp 中的索引</span></span><br><span class="line">  pp.id = id</span><br><span class="line">  <span class="comment">// 新创建的 p 处于 _Pgcstop 状态</span></span><br><span class="line">  pp.status = _Pgcstop</span><br><span class="line">  pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">    pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  pp.wbBuf.reset()</span><br><span class="line">  <span class="comment">// 为 P 分配 cache 对象</span></span><br><span class="line">  <span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> id == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> mcache0 == <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;missing mcache?&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Use the bootstrap mcache0. Only one P will get</span></span><br><span class="line">      <span class="comment">// mcache0: the one with ID 0.</span></span><br><span class="line">      pp.mcache = mcache0</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pp.mcache = allocmcache()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> raceenabled &amp;&amp; pp.raceprocctx == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> id == <span class="number">0</span> &#123;</span><br><span class="line">      pp.raceprocctx = raceprocctx0</span><br><span class="line">      raceprocctx0 = <span class="number">0</span> <span class="comment">// bootstrap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pp.raceprocctx = raceproccreate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lockInit(&amp;pp.timersLock, lockRankTimers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This P may get timers when it starts running. Set the mask here</span></span><br><span class="line">  <span class="comment">// since the P may not go through pidleget (notably P 0 on startup).</span></span><br><span class="line">  timerpMask.set(id)</span><br><span class="line">  <span class="comment">// Similarly, we may not go through pidleget before this P starts</span></span><br><span class="line">  <span class="comment">// running if it is P 0 on startup.</span></span><br><span class="line">  idlepMask.clear(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有和P关联的资源并且讲的状态切换到 _Pdead</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *p)</span></span> destroy() &#123;</span><br><span class="line">  assertLockHeld(&amp;sched.lock)</span><br><span class="line">  assertWorldStopped()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runq队列中的G移动到全局队列</span></span><br><span class="line">  <span class="keyword">for</span> pp.runqhead != pp.runqtail &#123;</span><br><span class="line">    <span class="comment">// 从本地队列中 pop</span></span><br><span class="line">    pp.runqtail--</span><br><span class="line">    gp := pp.runq[pp.runqtail%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">    <span class="comment">// push 到全局队列中</span></span><br><span class="line">    globrunqputhead(gp)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// runnext 移动到全局队列</span></span><br><span class="line">  <span class="keyword">if</span> pp.runnext != <span class="number">0</span> &#123;</span><br><span class="line">    globrunqputhead(pp.runnext.ptr())</span><br><span class="line">    pp.runnext = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(pp.timers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    plocal := getg().m.p.ptr()</span><br><span class="line">    <span class="comment">// The world is stopped, but we acquire timersLock to</span></span><br><span class="line">    <span class="comment">// protect against sysmon calling timeSleepUntil.</span></span><br><span class="line">    <span class="comment">// This is the only case where we hold the timersLock of</span></span><br><span class="line">    <span class="comment">// more than one P, so there are no deadlock concerns.</span></span><br><span class="line">    lock(&amp;plocal.timersLock)</span><br><span class="line">    lock(&amp;pp.timersLock)</span><br><span class="line">    moveTimers(plocal, pp.timers)</span><br><span class="line">    pp.timers = <span class="literal">nil</span></span><br><span class="line">    pp.numTimers = <span class="number">0</span></span><br><span class="line">    pp.deletedTimers = <span class="number">0</span></span><br><span class="line">    atomic.Store64(&amp;pp.timer0When, <span class="number">0</span>)</span><br><span class="line">    unlock(&amp;pp.timersLock)</span><br><span class="line">    unlock(&amp;plocal.timersLock)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Flush p&#x27;s write barrier buffer.</span></span><br><span class="line">  <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">    wbBufFlush1(pp)</span><br><span class="line">    pp.gcw.dispose()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> pp.sudogbuf &#123;</span><br><span class="line">    pp.sudogbuf[i] = <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> pp.deferpoolbuf[i] &#123;</span><br><span class="line">      pp.deferpoolbuf[i][j] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; pp.mspancache.<span class="built_in">len</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// Safe to call since the world is stopped.</span></span><br><span class="line">      mheap_.spanalloc.free(unsafe.Pointer(pp.mspancache.buf[i]))</span><br><span class="line">    &#125;</span><br><span class="line">    pp.mspancache.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">    lock(&amp;mheap_.lock)</span><br><span class="line">    pp.pcache.flush(&amp;mheap_.pages)</span><br><span class="line">    unlock(&amp;mheap_.lock)</span><br><span class="line">  &#125;)</span><br><span class="line">  freemcache(pp.mcache)</span><br><span class="line">  pp.mcache = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 将当前 P 的空闲的 G 复链转移到全局</span></span><br><span class="line">  gfpurge(pp)</span><br><span class="line">  traceProcFree(pp)</span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    <span class="keyword">if</span> pp.timerRaceCtx != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// The race detector code uses a callback to fetch</span></span><br><span class="line">      <span class="comment">// the proc context, so arrange for that callback</span></span><br><span class="line">      <span class="comment">// to see the right thing.</span></span><br><span class="line">      <span class="comment">// This hack only works because we are the only</span></span><br><span class="line">      <span class="comment">// thread running.</span></span><br><span class="line">      mp := getg().m</span><br><span class="line">      phold := mp.p.ptr()</span><br><span class="line">      mp.p.set(pp)</span><br><span class="line"></span><br><span class="line">      racectxend(pp.timerRaceCtx)</span><br><span class="line">      pp.timerRaceCtx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      mp.p.set(phold)</span><br><span class="line">    &#125;</span><br><span class="line">    raceprocdestroy(pp.raceprocctx)</span><br><span class="line">    pp.raceprocctx = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  pp.gcAssistTime = <span class="number">0</span></span><br><span class="line">  pp.status = _Pdead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>procresize 这个函数相对较长，我们来总结一下它主要干了什么事情：</p>
<ul>
<li>调用时已经 <code>STW</code>，记录调整 <code>P</code> 的时间；</li>
<li>按需调整 <code>allp</code> 的大小；</li>
<li>按需初始化 <code>allp</code> 中的 P；</li>
<li>如果当前的 <code>P</code> 还可以继续使用（没有被移除），则将 <code>P</code> 设置为 <code>_Prunning</code>；</li>
<li>否则将第一个 <code>P</code> 抢过来给当前 <code>G</code> 的 <code>M</code> 进行绑定；</li>
<li>从 <code>allp</code> 移除不需要的 <code>P</code>，将释放的 <code>P</code> 队列中的任务扔进全局队列；</li>
<li>最后挨个检查 <code>P</code>，将没有任务的 <code>P</code> 放入 <code>idle</code> 队列；</li>
<li>除去当前 <code>P</code> 之外，将有任务的 <code>P</code> 彼此串联成链表，将没有任务的 <code>P</code> 放回到 <code>idle</code> 链表中；</li>
</ul>
<h6 id="gomaxprocs"><a class="markdownIt-Anchor" href="#gomaxprocs"></a> <code>GOMAXPROCS</code></h6>
<p>一般情况下没有人会动态调整P的数量，都是跟CPU的数量保持相同的；为了达到某些测试目的或者其他情况下，可能会对P的数量进行调整，运行时系统向用户层提供了 <code>runtime.GOMAXPROCS</code> 来处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/debug.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GOMAXPROCS sets the maximum number of CPUs that can be executing</span></span><br><span class="line"><span class="comment">// simultaneously and returns the previous setting. It defaults to</span></span><br><span class="line"><span class="comment">// the value of runtime.NumCPU. If n &lt; 1, it does not change the current setting.</span></span><br><span class="line"><span class="comment">// This call will go away when the scheduler improves.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &amp;&amp; n &gt; <span class="number">1</span> &#123;</span><br><span class="line">		n = <span class="number">1</span> <span class="comment">// WebAssembly has no threads yet, so only one CPU is possible.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	ret := <span class="type">int</span>(gomaxprocs)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">0</span> || n == ret &#123;</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stopTheWorldGC(<span class="string">&quot;GOMAXPROCS&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// newprocs will be processed by startTheWorld</span></span><br><span class="line">	newprocs = <span class="type">int32</span>(n)</span><br><span class="line"></span><br><span class="line">	startTheWorldGC()</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数会STW，并且更新全局变量 <code>newprocs</code>，在 <code>startTheWorldGC()</code> 中会调用 <code>startTheWorldWithSema</code> 函数，对P的数量重新调整：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldWithSema</span><span class="params">(emitTraceEvent <span class="type">bool</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">  assertWorldStopped()</span><br><span class="line">  ...</span><br><span class="line">  procs := gomaxprocs</span><br><span class="line">  <span class="keyword">if</span> newprocs != <span class="number">0</span> &#123;</span><br><span class="line">    procs = newprocs</span><br><span class="line">    newprocs = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  p1 := procresize(procs)</span><br><span class="line">  ...</span><br><span class="line">  worldStarted()</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> startTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="g"><a class="markdownIt-Anchor" href="#g"></a> <code>G</code></h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack 描述Goroutine的执行栈，栈的边界范围是 [lo, hi)</span></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">	lo <span class="type">uintptr</span></span><br><span class="line">	hi <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Stack parameters.</span></span><br><span class="line">	<span class="comment">// stack describes the actual stack memory: [stack.lo, stack.hi).</span></span><br><span class="line">	<span class="comment">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span></span><br><span class="line">	<span class="comment">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span></span><br><span class="line">	<span class="comment">// stackguard1 is the stack pointer compared in the C stack growth prologue.</span></span><br><span class="line">	<span class="comment">// It is stack.lo+StackGuard on g0 and gsignal stacks.</span></span><br><span class="line">	<span class="comment">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).</span></span><br><span class="line">	stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line">	stackguard0 <span class="type">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">	stackguard1 <span class="type">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line"></span><br><span class="line">	_panic    *_panic <span class="comment">// innermost panic - offset known to liblink</span></span><br><span class="line">	_defer    *_defer <span class="comment">// innermost defer</span></span><br><span class="line">	m         *m      <span class="comment">// current m; offset known to arm liblink</span></span><br><span class="line">	sched     gobuf</span><br><span class="line">	syscallsp <span class="type">uintptr</span> <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">	syscallpc <span class="type">uintptr</span> <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">	stktopsp  <span class="type">uintptr</span> <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">	<span class="comment">// param is a generic pointer parameter field used to pass</span></span><br><span class="line">	<span class="comment">// values in particular contexts where other storage for the</span></span><br><span class="line">	<span class="comment">// parameter would be difficult to find. It is currently used</span></span><br><span class="line">	<span class="comment">// in three ways:</span></span><br><span class="line">	<span class="comment">// 1. When a channel operation wakes up a blocked goroutine, it sets param to</span></span><br><span class="line">	<span class="comment">//    point to the sudog of the completed blocking operation.</span></span><br><span class="line">	<span class="comment">// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed</span></span><br><span class="line">	<span class="comment">//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&#x27;s</span></span><br><span class="line">	<span class="comment">//    stack may have moved in the meantime.</span></span><br><span class="line">	<span class="comment">// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a</span></span><br><span class="line">	<span class="comment">//    closure in the runtime is forbidden.</span></span><br><span class="line">	param        unsafe.Pointer</span><br><span class="line">	atomicstatus <span class="type">uint32</span></span><br><span class="line">	stackLock    <span class="type">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span><br><span class="line">	goid         <span class="type">int64</span></span><br><span class="line">	schedlink    guintptr</span><br><span class="line">	waitsince    <span class="type">int64</span>      <span class="comment">// approx time when the g become blocked</span></span><br><span class="line">	waitreason   waitReason <span class="comment">// if status==Gwaiting</span></span><br><span class="line"></span><br><span class="line">	preempt       <span class="type">bool</span> <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line">	preemptStop   <span class="type">bool</span> <span class="comment">// transition to _Gpreempted on preemption; otherwise, just deschedule</span></span><br><span class="line">	preemptShrink <span class="type">bool</span> <span class="comment">// shrink stack at synchronous safe point</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// asyncSafePoint is set if g is stopped at an asynchronous</span></span><br><span class="line">	<span class="comment">// safe point. This means there are frames on the stack</span></span><br><span class="line">	<span class="comment">// without precise pointer information.</span></span><br><span class="line">	asyncSafePoint <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	paniconfault <span class="type">bool</span> <span class="comment">// panic (instead of crash) on unexpected fault address</span></span><br><span class="line">	gcscandone   <span class="type">bool</span> <span class="comment">// g has scanned stack; protected by _Gscan bit in status</span></span><br><span class="line">	throwsplit   <span class="type">bool</span> <span class="comment">// must not split stack</span></span><br><span class="line">	<span class="comment">// activeStackChans indicates that there are unlocked channels</span></span><br><span class="line">	<span class="comment">// pointing into this goroutine&#x27;s stack. If true, stack</span></span><br><span class="line">	<span class="comment">// copying needs to acquire channel locks to protect these</span></span><br><span class="line">	<span class="comment">// areas of the stack.</span></span><br><span class="line">	activeStackChans <span class="type">bool</span></span><br><span class="line">	<span class="comment">// parkingOnChan indicates that the goroutine is about to</span></span><br><span class="line">	<span class="comment">// park on a chansend or chanrecv. Used to signal an unsafe point</span></span><br><span class="line">	<span class="comment">// for stack shrinking. It&#x27;s a boolean value, but is updated atomically.</span></span><br><span class="line">	parkingOnChan <span class="type">uint8</span></span><br><span class="line"></span><br><span class="line">	raceignore     <span class="type">int8</span>     <span class="comment">// ignore race detection events</span></span><br><span class="line">	sysblocktraced <span class="type">bool</span>     <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span></span><br><span class="line">	tracking       <span class="type">bool</span>     <span class="comment">// whether we&#x27;re tracking this G for sched latency statistics</span></span><br><span class="line">	trackingSeq    <span class="type">uint8</span>    <span class="comment">// used to decide whether to track this G</span></span><br><span class="line">	runnableStamp  <span class="type">int64</span>    <span class="comment">// timestamp of when the G last became runnable, only used when tracking</span></span><br><span class="line">	runnableTime   <span class="type">int64</span>    <span class="comment">// the amount of time spent runnable, cleared when running, only used when tracking</span></span><br><span class="line">	sysexitticks   <span class="type">int64</span>    <span class="comment">// cputicks when syscall has returned (for tracing)</span></span><br><span class="line">	traceseq       <span class="type">uint64</span>   <span class="comment">// trace event sequencer</span></span><br><span class="line">	tracelastp     puintptr <span class="comment">// last P emitted an event for this goroutine</span></span><br><span class="line">	lockedm        muintptr</span><br><span class="line">	sig            <span class="type">uint32</span></span><br><span class="line">	writebuf       []<span class="type">byte</span></span><br><span class="line">	sigcode0       <span class="type">uintptr</span></span><br><span class="line">	sigcode1       <span class="type">uintptr</span></span><br><span class="line">	sigpc          <span class="type">uintptr</span></span><br><span class="line">	gopc           <span class="type">uintptr</span>         <span class="comment">// pc of go statement that created this goroutine</span></span><br><span class="line">	ancestors      *[]ancestorInfo <span class="comment">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)</span></span><br><span class="line">	startpc        <span class="type">uintptr</span>         <span class="comment">// pc of goroutine function</span></span><br><span class="line">	racectx        <span class="type">uintptr</span></span><br><span class="line">	waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line">	cgoCtxt        []<span class="type">uintptr</span>      <span class="comment">// cgo traceback context</span></span><br><span class="line">	labels         unsafe.Pointer <span class="comment">// profiler labels</span></span><br><span class="line">	timer          *timer         <span class="comment">// cached timer for time.Sleep</span></span><br><span class="line">	selectDone     <span class="type">uint32</span>         <span class="comment">// are we participating in a select and did someone win the race?</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-G GC state</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcAssistBytes is this G&#x27;s GC assist credit in terms of</span></span><br><span class="line">	<span class="comment">// bytes allocated. If this is positive, then the G has credit</span></span><br><span class="line">	<span class="comment">// to allocate gcAssistBytes bytes without assisting. If this</span></span><br><span class="line">	<span class="comment">// is negative, then the G must correct this by performing</span></span><br><span class="line">	<span class="comment">// scan work. We track this in bytes to make it fast to update</span></span><br><span class="line">	<span class="comment">// and check for debt in the malloc hot path. The assist ratio</span></span><br><span class="line">	<span class="comment">// determines how this corresponds to scan work debt.</span></span><br><span class="line">	gcAssistBytes <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>G</code> 其实就是用户函数体，里面保存了要执行的函数参数，函数体的入口。相比于 <code>P</code>，<code>G</code> 的状态相对较多，主要有以下这些：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"><span class="comment">// defined constants</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// G status</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Beyond indicating the general state of a G, the G status</span></span><br><span class="line">	<span class="comment">// acts like a lock on the goroutine&#x27;s stack (and hence its</span></span><br><span class="line">	<span class="comment">// ability to execute user code).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If you add to this list, add to the list</span></span><br><span class="line">	<span class="comment">// of &quot;okay during garbage collection&quot; status</span></span><br><span class="line">	<span class="comment">// in mgcmark.go too.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// TODO(austin): The _Gscan bit could be much lighter-weight.</span></span><br><span class="line">	<span class="comment">// For example, we could choose not to run _Gscanrunnable</span></span><br><span class="line">	<span class="comment">// goroutines found in the run queue, rather than CAS-looping</span></span><br><span class="line">	<span class="comment">// until they become _Grunnable. And transitions like</span></span><br><span class="line">	<span class="comment">// _Gscanwaiting -&gt; _Gscanrunnable are actually okay because</span></span><br><span class="line">	<span class="comment">// they don&#x27;t affect stack ownership.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gidle 表示这个 Goroutine 刚刚被分配，还没有被初始化。</span></span><br><span class="line">	_Gidle = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Grunnable 意味着这个 Goroutine 在一个可运行队列中，还没有</span></span><br><span class="line">    <span class="comment">// 执行用户代码，也没有堆栈；</span></span><br><span class="line">	_Grunnable <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Grunning 意味着这个 Goroutine 正在执行用户代码，拥有运行代码</span></span><br><span class="line">    <span class="comment">// 必要的堆栈。它不再可运行队列中，当前正在和 m 以及 p 关联。也就是</span></span><br><span class="line">    <span class="comment">// 说 g.m 以及 g.m.p 都是有效的；</span></span><br><span class="line">	_Grunning <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gsyscall 表示这个 Goroutine 正在执行一个系统调用，没有执行用户代码。拥有堆栈</span></span><br><span class="line">    <span class="comment">// 并且分配了M，所以它不在运行队列中；</span></span><br><span class="line">	_Gsyscall <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _Gwaiting 表示这个 goroutine 在运行时被阻塞。它没有执行用户代码。</span></span><br><span class="line">    <span class="comment">// 它不在运行队列中，但应记录在某处，例如，因为channel的等待队列，所以</span></span><br><span class="line">    <span class="comment">// 它可以在必要时被唤醒就绪。除了通道操作可以在适当的在通道锁下读取或者</span></span><br><span class="line">    <span class="comment">// 写入部分堆栈，其他情况下访问堆栈是不安全的；</span></span><br><span class="line">	_Gwaiting <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gmoribund_unused 目前没用的一个状态；</span></span><br><span class="line">	_Gmoribund_unused <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _Gdead 意味着这个 Goroutine 当前没被使用，他可能刚刚退出在一个空闲列表</span></span><br><span class="line">    <span class="comment">// 中，或者刚刚初始化。它可能有也可能没有分配堆栈。G 及其堆栈由退出 G 或从空</span></span><br><span class="line">    <span class="comment">// 闲列表中获得 G 的 M 所有。</span></span><br><span class="line">	_Gdead <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Genqueue_unused 目前没用；</span></span><br><span class="line">	_Genqueue_unused <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _Gcopystack 意味着这个 Goroutine 的栈正在被移动，它没有执行用户代码</span></span><br><span class="line">    <span class="comment">// 也没有在可运行队列中。该堆栈由将其放入 _Gcopystack 的Goroutine所有。</span></span><br><span class="line">	_Gcopystack <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _Gpreempted 意味着这个Goroutine被强制抢占，它很像 _Gwaiting，但</span></span><br><span class="line">    <span class="comment">// 目前没有什么负责将它就绪。</span></span><br><span class="line">	_Gpreempted <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// _Gscan combined with one of the above states other than</span></span><br><span class="line">	<span class="comment">// _Grunning indicates that GC is scanning the stack. The</span></span><br><span class="line">	<span class="comment">// goroutine is not executing user code and the stack is owned</span></span><br><span class="line">	<span class="comment">// by the goroutine that set the _Gscan bit.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// _Gscanrunning is different: it is used to briefly block</span></span><br><span class="line">	<span class="comment">// state transitions while GC signals the G to scan its own</span></span><br><span class="line">	<span class="comment">// stack. This is otherwise like _Grunning.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// atomicstatus&amp;~Gscan gives the state the goroutine will</span></span><br><span class="line">	<span class="comment">// return to when the scan completes.</span></span><br><span class="line">	_Gscan          = <span class="number">0x1000</span></span><br><span class="line">	_Gscanrunnable  = _Gscan + _Grunnable  <span class="comment">// 0x1001</span></span><br><span class="line">	_Gscanrunning   = _Gscan + _Grunning   <span class="comment">// 0x1002</span></span><br><span class="line">	_Gscansyscall   = _Gscan + _Gsyscall   <span class="comment">// 0x1003</span></span><br><span class="line">	_Gscanwaiting   = _Gscan + _Gwaiting   <span class="comment">// 0x1004</span></span><br><span class="line">	_Gscanpreempted = _Gscan + _Gpreempted <span class="comment">// 0x1009</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>G</code> 的初始化是在 <code>runtime.newproc</code> 函数中完成的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go </span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从 fn 的地址增加一个指针的长度，从而获取第一参数地址</span></span><br><span class="line">  argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">  gp := getg()</span><br><span class="line">  pc := getcallerpc() <span class="comment">// 获取调用方 PC/IP 寄存器值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用 g0 系统栈创建 Goroutine 对象</span></span><br><span class="line">  <span class="comment">// 传递的参数包括 fn 函数入口地址, argp 参数起始地址, siz 参数长度, gp（g0），调用方 pc（goroutine）</span></span><br><span class="line">  systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newg := newproc1(fn, argp, siz, gp, pc)</span><br><span class="line"></span><br><span class="line">    _p_ := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将这里新创建的 g 放入 p 的本地队列或直接放入全局队列</span></span><br><span class="line">	<span class="comment">// true 表示放入执行队列的下一个，false 表示放入队尾</span></span><br><span class="line">    runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有空闲的 P、且 spinning 的 M 数量为 0，且主 Goroutine 已经开始运行，则进行唤醒 p</span></span><br><span class="line">	<span class="comment">// 初始化阶段 mainStarted 为 false，所以 p 不会被唤醒</span></span><br><span class="line">    <span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">      wakep()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="type">uintptr</span></span><br><span class="line">	<span class="comment">// 变长大小，fn 的数据在应在 fn 之后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getcallerpc 返回它调用方的调用方程序计数器 PC program conter</span></span><br><span class="line"><span class="comment">//go:noescape</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getcallerpc</span><span class="params">()</span></span> <span class="type">uintptr</span></span><br></pre></td></tr></table></figure>
<p>详细的参数获取过程需要编译器的配合，也是实现 Goroutine 的关键，下面是 X86 上面一个简单的事例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> hello(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>LEAQ go.string.*+1874(SB), AX // 将 &quot;hello world&quot; 的地址给 AX
MOVQ AX, 0x10(SP)             // 将 AX 的值放到 0x10
MOVL $0x10, 0(SP)             // 将最后一个参数的位置存到栈顶 0x00
LEAQ go.func.*+67(SB), AX     // 将 go 语句调用的函数入口地址给 AX
MOVQ AX, 0x8(SP)              // 将 AX 存入 0x08
CALL runtime.newproc(SB)      // 调用 newproc
</code></pre>
<p>这个时候栈的布局如下图所示：</p>
<pre><code>            栈布局
    |                 |       高地址
    |                 |
    +-----------------+ 
    | &amp;&quot;hello world&quot;  |
0x10  +-----------------+ &lt;--- fn + sys.PtrSize
    |      hello      |
0x08  +-----------------+ &lt;--- fn
    |       size      |
0x00  +-----------------+ SP
    |    newproc PC   |  
    +-----------------+ callerpc: 要运行的 Goroutine 的 PC
    |                 |
    |                 |       低地址
</code></pre>
<p>从而当 <code>newproc</code> 开始运行时，先获得 <code>size</code> 作为第一个参数，再获得 <code>fn</code> 作为第二个参数， 然后通过 <code>add</code> 计算出 <code>fn</code> 参数开始的位置。现在我们知道 <code>newproc</code> 会获取需要执行的 <code>Goroutine</code> 要执行的函数体的地址、 参数起始地址、参数长度、以及 <code>Goroutine</code> 的调用地址。 然后在 <code>g0</code> 系统栈上通过 <code>newproc1</code> 创建并初始化新的 <code>Goroutine</code> ，下面我们来看 <code>newproc1</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个运行 fn 的新 g，具有 narg 字节大小的参数，从 argp 开始。</span></span><br><span class="line"><span class="comment">// callerps 是 go 语句的起始地址。新创建的 g 会被放入 g 的队列中等待运行。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must run on the system stack because it&#x27;s the continuation of</span></span><br><span class="line"><span class="comment">// newproc, which cannot split the stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:systemstack</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp unsafe.Pointer, narg <span class="type">int32</span>, callergp *g, callerpc <span class="type">uintptr</span>)</span></span> *g &#123;</span><br><span class="line">  <span class="keyword">if</span> goexperiment.RegabiDefer &amp;&amp; narg != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> When we commit to GOEXPERIMENT=regabidefer,</span></span><br><span class="line">    <span class="comment">// rewrite the comments for newproc and newproc1.</span></span><br><span class="line">    <span class="comment">// newproc will no longer have a funny stack layout or</span></span><br><span class="line">    <span class="comment">// need to be nosplit.</span></span><br><span class="line">    throw(<span class="string">&quot;go with non-empty frame&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _g_ := getg()  <span class="comment">// 因为是在系统栈运行所以此时的 g 为 g0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">    _g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">    throw(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  acquirem() <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">  siz := narg</span><br><span class="line">  siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We could allocate a larger initial stack if necessary.</span></span><br><span class="line">  <span class="comment">// Not worth it: this is almost always an error.</span></span><br><span class="line">  <span class="comment">// 4*PtrSize: extra space added below</span></span><br><span class="line">  <span class="comment">// PtrSize: caller&#x27;s LR (arm) or return address (x86, in gostartcall).</span></span><br><span class="line">  <span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.PtrSize-sys.PtrSize &#123;</span><br><span class="line">    throw(<span class="string">&quot;newproc: function arguments too large for new goroutine&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得 p</span></span><br><span class="line">  _p_ := _g_.m.p.ptr()</span><br><span class="line">  <span class="comment">// 根据 p 获得一个新的 g</span></span><br><span class="line">  newg := gfget(_p_)</span><br><span class="line">  <span class="comment">// 初始化阶段，gfget 是不可能找到 g 的</span></span><br><span class="line">  <span class="comment">// 也可能运行中本来就已经耗尽了</span></span><br><span class="line">  <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">    newg = malg(_StackMin)  <span class="comment">// 创建一个拥有 _StackMin 大小的栈的 g，_StackMin 是 2048</span></span><br><span class="line">    <span class="comment">// 将新创建的 g 从 _Gidle 更新为 _Gdead 状态</span></span><br><span class="line">    casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">    allgadd(newg) <span class="comment">// 将 Gdead 状态的 g 添加到 allg，这样 GC 不会扫描未初始化的栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">    throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算运行空间大小，对齐</span></span><br><span class="line">  totalSize := <span class="number">4</span>*sys.PtrSize + <span class="type">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">  totalSize += -totalSize &amp; (sys.StackAlign - <span class="number">1</span>)               <span class="comment">// align to StackAlign</span></span><br><span class="line">  <span class="comment">// 确定 sp 和参数入栈位置</span></span><br><span class="line">  sp := newg.stack.hi - totalSize</span><br><span class="line">  spArg := sp</span><br><span class="line">  <span class="keyword">if</span> usesLR &#123;</span><br><span class="line">    <span class="comment">// caller&#x27;s LR</span></span><br><span class="line">    *(*<span class="type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">    prepGoExitFrame(sp)</span><br><span class="line">    spArg += sys.MinFrameSize</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理参数，当有参数时，将参数拷贝到 Goroutine 的执行栈中</span></span><br><span class="line">  <span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 从 argp 参数开始的位置，复制 narg 个字节到 spArg（参数拷贝）</span></span><br><span class="line">    memmove(unsafe.Pointer(spArg), argp, <span class="type">uintptr</span>(narg))</span><br><span class="line">    <span class="comment">// 栈到栈的拷贝。</span></span><br><span class="line">    <span class="comment">// 如果启用了 write barrier 并且 源栈为灰色（目标始终为黑色），</span></span><br><span class="line">    <span class="comment">// 则执行 barrier 拷贝。</span></span><br><span class="line">    <span class="comment">// 因为目标栈上可能有垃圾，我们在 memmove 之后执行此操作。</span></span><br><span class="line">    <span class="keyword">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class="line">      f := findfunc(fn.fn)</span><br><span class="line">      stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class="line">      <span class="keyword">if</span> stkmap.nbit &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 我们正位于序言部分，因此栈 map 索引总是 0</span></span><br><span class="line">        bv := stackmapdata(stkmap, <span class="number">0</span>)</span><br><span class="line">        bulkBarrierBitmap(spArg, spArg, <span class="type">uintptr</span>(bv.n)*sys.PtrSize, <span class="number">0</span>, bv.bytedata)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理、创建并初始化的 g 的运行现场</span></span><br><span class="line">  memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">  newg.sched.sp = sp</span><br><span class="line">  newg.stktopsp = sp</span><br><span class="line">  newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">  newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">  gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">  <span class="comment">// 初始化 g 的基本状态</span></span><br><span class="line">  newg.gopc = callerpc</span><br><span class="line">  newg.ancestors = saveAncestors(callergp)</span><br><span class="line">  newg.startpc = fn.fn <span class="comment">// 入口 pc</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">    newg.labels = _g_.m.curg.labels</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">    atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Track initial transition?</span></span><br><span class="line">  newg.trackingSeq = <span class="type">uint8</span>(fastrand())</span><br><span class="line">  <span class="keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="number">0</span> &#123;</span><br><span class="line">    newg.tracking = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 现在将 g 更换为 _Grunnable 状态</span></span><br><span class="line">  casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配 goid</span></span><br><span class="line">  <span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line">    <span class="comment">// Sched.goidgen 为最后一个分配的 id，相当于一个全局计数器</span></span><br><span class="line">    <span class="comment">// 这一批必须为 [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line">    <span class="comment">// 启动时 sched.goidgen=0, 因此主 Goroutine 的 goid 为 1</span></span><br><span class="line">    _p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">    _p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">    _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">  &#125;</span><br><span class="line">  newg.goid = <span class="type">int64</span>(_p_.goidcache)</span><br><span class="line">  _p_.goidcache++</span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    newg.racectx = racegostart(callerpc)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">    traceGoCreate(newg, newg.startpc)</span><br><span class="line">  &#125;</span><br><span class="line">  releasem(_g_.m)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了证明创建新的goroutine是在系统栈运行，可以<code>debug</code>程序，在 <code>newproc1</code> 函数中断点，查看此时的<code>goroutine</code>是哪个：</p>
<pre><code>(dlv) c
&gt; runtime.newproc1() /usr/local/go/src/runtime/proc.go:4286 (hits total:1) (PC: 0x4de9c)
Warning: debugging optimized function
4281:			throw(&quot;go with non-empty frame&quot;)
4282:		&#125;
4283:
4284:		_g_ := getg()
4285:
=&gt;4286:		if fn == nil &#123;
4287:			_g_.m.throwing = -1 // do not dump full stacks
4288:			throw(&quot;go of nil func value&quot;)
4289:		&#125;
4290:		acquirem() // disable preemption because it can be holding p in a local var
4291:		siz := narg
(dlv) p _g_.m.g0.goid
0
(dlv) p _g_.goid
0  // 当前g关联的m的g0ID和当前g的id相同，说明是在g0栈上运行
(dlv)
</code></pre>
<p>由于执行 newproc1 是在 systemstack() 函数中，我们来看这个函数的描述：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// systemstack runs fn on a system stack.</span></span><br><span class="line"><span class="comment">// If systemstack is called from the per-OS-thread (g0) stack, or</span></span><br><span class="line"><span class="comment">// if systemstack is called from the signal handling (gsignal) stack,</span></span><br><span class="line"><span class="comment">// systemstack calls fn directly and returns.</span></span><br><span class="line"><span class="comment">// Otherwise, systemstack is being called from the limited stack</span></span><br><span class="line"><span class="comment">// of an ordinary goroutine. In this case, systemstack switches</span></span><br><span class="line"><span class="comment">// to the per-OS-thread stack, calls fn, and switches back.</span></span><br><span class="line"><span class="comment">// It is common to use a func literal as the argument, in order</span></span><br><span class="line"><span class="comment">// to share inputs and outputs with the code around the call</span></span><br><span class="line"><span class="comment">// to system stack:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	... set up y ...</span></span><br><span class="line"><span class="comment">//	systemstack(func() &#123;</span></span><br><span class="line"><span class="comment">//		x = bigcall(y)</span></span><br><span class="line"><span class="comment">//	&#125;)</span></span><br><span class="line"><span class="comment">//	... use x ...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:noescape</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">systemstack</span><span class="params">(fn <span class="keyword">func</span>()</span></span>)</span><br></pre></td></tr></table></figure>
<p>创建 G 的过程也是相对比较复杂的，我们来总结一下这个过程：</p>
<ol>
<li>首先尝试从 <code>P</code> 本地 <code>gfree</code> 链表或全局 <code>gfree</code> 队列获取已经执行过的 <code>g</code></li>
<li>初始化过程中程序无论是本地队列还是全局队列都不可能获取到 <code>g</code>，因此创建一个新的 <code>g</code>，并为其分配运行线程（执行栈），这时 <code>g</code> 处于 <code>_Gidle</code> 状态</li>
<li>创建完成后，<code>g</code> 被更改为 <code>_Gdead</code> 状态，并根据要执行函数的入口地址和参数，初始化执行栈的 <code>SP</code> 和参数的入栈位置，并将需要的参数拷贝一份存入执行栈中</li>
<li>根据 <code>SP</code>、参数，在 <code>g.sched</code> 中保存 <code>SP</code> 和 <code>PC</code> 指针来初始化 <code>g</code> 的运行现场</li>
<li>将调用方、要执行的函数的入口 <code>PC</code> 进行保存，并将 <code>g</code> 的状态更改为 <code>_Grunnable</code></li>
<li>给 <code>Goroutine</code> 分配 <code>id</code>，并将其放入 <code>P</code> 本地队列的队头或全局队列（初始化阶段队列肯定不是满的，因此不可能放入全局队列）</li>
<li>检查空闲的 <code>P</code>，将其唤醒，准备执行 <code>G</code>，但我们目前处于初始化阶段，主 <code>Goroutine</code> 尚未开始执行，因此这里不会唤醒 <code>P</code>。</li>
</ol>
<h5 id="sched"><a class="markdownIt-Anchor" href="#sched"></a> <code>sched</code></h5>
<p><code>runtime2.go</code> 文件中结束位置定义了很多全局变量，其中有一个 <code>sched</code>，它包含了很多全局资源，访问这些全局资源一般需要锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 原子访问，确保在32位系统上对齐</span></span><br><span class="line">	goidgen   <span class="type">uint64</span> <span class="comment">// 全局goid生成器，newproc1 函数中有使用到</span></span><br><span class="line">	lastpoll  <span class="type">uint64</span> <span class="comment">// time of last network poll, 0 if currently polling</span></span><br><span class="line">	pollUntil <span class="type">uint64</span> <span class="comment">// time to which current poll is sleeping</span></span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当增加 nmidle，nmidlelocked，nmsys 或者 nmfreed时，确保调用 checkdead()</span></span><br><span class="line">    <span class="comment">// 这个函数在 src/runtime/proc.go 中，检查运行的M，如果数量是0，则 deadlock</span></span><br><span class="line">	midle        muintptr <span class="comment">// 等待工作的空闲m列表</span></span><br><span class="line">	nmidle       <span class="type">int32</span>    <span class="comment">// 空闲M的数量</span></span><br><span class="line">	nmidlelocked <span class="type">int32</span>    <span class="comment">// number of locked m&#x27;s waiting for work</span></span><br><span class="line">	mnext        <span class="type">int64</span>    <span class="comment">// 已经创建的M的数量用于记录M的ID</span></span><br><span class="line">	maxmcount    <span class="type">int32</span>    <span class="comment">// 最大允许的m的数量，10000</span></span><br><span class="line">	nmsys        <span class="type">int32</span>    <span class="comment">// 系统线程数量不用于死锁检查</span></span><br><span class="line">	nmfreed      <span class="type">int64</span>    <span class="comment">// 累计已经释放的M的数量</span></span><br><span class="line"></span><br><span class="line">	ngsys <span class="type">uint32</span> <span class="comment">// 系统goroutine的数量，原子更新</span></span><br><span class="line"></span><br><span class="line">	pidle      puintptr <span class="comment">// 空闲p列表</span></span><br><span class="line">	npidle     <span class="type">uint32</span></span><br><span class="line">	nmspinning <span class="type">uint32</span> <span class="comment">// See &quot;Worker thread parking/unparking&quot; comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 全局的可运行G队列</span></span><br><span class="line">	runq     gQueue</span><br><span class="line">	runqsize <span class="type">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// disable controls selective disabling of the scheduler.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Use schedEnableUser to control this.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// disable is protected by sched.lock.</span></span><br><span class="line">	disable <span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="comment">// user disables scheduling of user goroutines.</span></span><br><span class="line">		user     <span class="type">bool</span></span><br><span class="line">		runnable gQueue <span class="comment">// pending runnable Gs</span></span><br><span class="line">		n        <span class="type">int32</span>  <span class="comment">// length of runnable</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 全局_Gdead状态的G</span></span><br><span class="line">	gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">		lock    mutex</span><br><span class="line">		stack   gList <span class="comment">// Gs with stacks</span></span><br><span class="line">		noStack gList <span class="comment">// Gs without stacks</span></span><br><span class="line">		n       <span class="type">int32</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sudog 结构体的全局缓存</span></span><br><span class="line">	sudoglock  mutex</span><br><span class="line">	sudogcache *sudog</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Central pool of available defer structs of different sizes.</span></span><br><span class="line">	deferlock mutex</span><br><span class="line">	deferpool [<span class="number">5</span>]*_defer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// freem is the list of m&#x27;s waiting to be freed when their</span></span><br><span class="line">	<span class="comment">// m.exited is set. Linked through m.freelink.</span></span><br><span class="line">	freem *m</span><br><span class="line"></span><br><span class="line">	gcwaiting  <span class="type">uint32</span> <span class="comment">// gc is waiting to run</span></span><br><span class="line">	stopwait   <span class="type">int32</span></span><br><span class="line">	stopnote   note</span><br><span class="line">	sysmonwait <span class="type">uint32</span></span><br><span class="line">	sysmonnote note</span><br><span class="line"></span><br><span class="line">	<span class="comment">// While true, sysmon not ready for mFixup calls.</span></span><br><span class="line">	<span class="comment">// Accessed atomically.</span></span><br><span class="line">	sysmonStarting <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// safepointFn should be called on each P at the next GC</span></span><br><span class="line">	<span class="comment">// safepoint if p.runSafePointFn is set.</span></span><br><span class="line">	safePointFn   <span class="function"><span class="keyword">func</span><span class="params">(*p)</span></span></span><br><span class="line">	safePointWait <span class="type">int32</span></span><br><span class="line">	safePointNote note</span><br><span class="line"></span><br><span class="line">	profilehz <span class="type">int32</span> <span class="comment">// cpu profiling rate</span></span><br><span class="line"></span><br><span class="line">	procresizetime <span class="type">int64</span> <span class="comment">// nanotime() of last change to gomaxprocs</span></span><br><span class="line">	totaltime      <span class="type">int64</span> <span class="comment">// ∫gomaxprocs dt up to procresizetime</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// sysmonlock protects sysmon&#x27;s actions on the runtime.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Acquire and hold this mutex to block sysmon from interacting</span></span><br><span class="line">	<span class="comment">// with the rest of the runtime.</span></span><br><span class="line">	sysmonlock mutex</span><br><span class="line"></span><br><span class="line">	_ <span class="type">uint32</span> <span class="comment">// ensure timeToRun has 8-byte alignment</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// timeToRun is a distribution of scheduling latencies, defined</span></span><br><span class="line">	<span class="comment">// as the sum of time a G spends in the _Grunnable state before</span></span><br><span class="line">	<span class="comment">// it transitions to _Grunning.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// timeToRun is protected by sched.lock.</span></span><br><span class="line">	timeToRun timeHistogram</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	allm       *m</span><br><span class="line">	gomaxprocs <span class="type">int32</span></span><br><span class="line">	ncpu       <span class="type">int32</span></span><br><span class="line">	forcegc    forcegcstate</span><br><span class="line">	sched      schedt</span><br><span class="line">    ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们再来看看 <code>schedinit</code> 函数，了解下 <code>GPM</code> 的初始化流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line">    mcommoninit(_g_.m, <span class="number">-1</span>)  <span class="comment">// M初始化</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.lastpoll = <span class="type">uint64</span>(nanotime())</span><br><span class="line">    procs := ncpu</span><br><span class="line">    <span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        procs = n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// P 初始化</span></span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>TEXT runtime·rt0_go(SB),NOSPLIT,$0
    ...
    MOVW	8(RSP), R0	// copy argc
    MOVW	R0, -8(RSP)
    MOVD	16(RSP), R0		// copy argv
    MOVD	R0, 0(RSP)
    BL	runtime·args(SB)
    BL	runtime·osinit(SB)
    BL	runtime·schedinit(SB)

    // create a new goroutine to start program
    MOVD	$runtime·mainPC(SB), R0		// entry
    MOVD	RSP, R7
    MOVD.W	$0, -8(R7)
    MOVD.W	R0, -8(R7)
    MOVD.W	$0, -8(R7)
    MOVD.W	$0, -8(R7)
    MOVD	R7, RSP
    BL	runtime·newproc(SB)   //G 的初始化
    ADD	$32, RSP

DATA	runtime·mainPC+0(SB)/8,$runtime·main(SB)
GLOBL	runtime·mainPC(SB),RODATA,$8
</code></pre>
<p>M/P/G 彼此的初始化顺序遵循：<code>mcommoninit</code>、<code>procresize</code>、<code>newproc</code>，他们分别负责初始化 <code>M</code> 资源池（<code>allm</code>）、<code>P</code> 资源池（<code>allp</code>）、<code>G</code> 的运行现场（<code>g.sched</code>）以及调度队列（<code>p.runq</code>）。</p>
<h4 id="调度循环"><a class="markdownIt-Anchor" href="#调度循环"></a> 调度循环</h4>
<p>当所有准备工作都就绪之后，也就是调度器初始化，主<code>Goroutine</code>也创建好之后，就是启动调度器调度我们的主<code>Goroutine</code>开始运行了，在我们的<code>Go</code>程序引导启动的最后一步有如下的过程，其中 <code>mstart</code> 就是启动调度的入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// src/runtime/asm_arm64.s</span><br><span class="line"></span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    // create a new goroutine to start program</span><br><span class="line">	MOVQ	$runtime·mainPC(SB), AX		// entry</span><br><span class="line">	PUSHQ	AX</span><br><span class="line">	PUSHQ	$0			// arg size</span><br><span class="line">	CALL	runtime·newproc(SB)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	POPQ	AX</span><br><span class="line"></span><br><span class="line">    // start this M</span><br><span class="line">	CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">	CALL	runtime·abort(SB)	// mstart should never return</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">	// Prevent dead-code elimination of debugCallV2, which is</span><br><span class="line">	// intended to be called by debuggers.</span><br><span class="line">	MOVQ	$runtime·debugCallV2&lt;ABIInternal&gt;(SB), AX</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">TEXT runtime·mstart(SB),NOSPLIT|TOPFRAME,$0</span><br><span class="line">	CALL	runtime·mstart0(SB)</span><br><span class="line">	RET // not reached</span><br><span class="line"></span><br><span class="line">// mainPC is a function value for runtime.main, to be passed to newproc.</span><br><span class="line">// The reference to runtime.main is made via ABIInternal, since the</span><br><span class="line">// actual function (not the ABI0 wrapper) is needed by newproc.</span><br><span class="line">DATA	runtime·mainPC+0(SB)/8,$runtime·main&lt;ABIInternal&gt;(SB)</span><br><span class="line">GLOBL	runtime·mainPC(SB),RODATA,$8</span><br></pre></td></tr></table></figure>
<p><code>mstart</code> 是新创建的M的入口，由汇编完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mstart is the entry-point for new Ms.</span></span><br><span class="line"><span class="comment">// It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>从汇编代码中可以看到，<code>mstart</code> 仅仅调用了 <code>mstart0</code>，而且它不会返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="comment">// mstart0 is the Go entry-point for new Ms.</span></span><br><span class="line"><span class="comment">// This must not split the stack because we may not even have stack</span></span><br><span class="line"><span class="comment">// bounds set up yet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// May run during STW (because it doesn&#x27;t have a P yet), so write</span></span><br><span class="line"><span class="comment">// barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart0</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定执行栈的边界，通过检查G执行栈的边界确定是否为系统栈</span></span><br><span class="line">  osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> osStack &#123;</span><br><span class="line">    <span class="comment">// Initialize stack bounds from system stack.</span></span><br><span class="line">    <span class="comment">// Cgo may have left stack size in stack.hi.</span></span><br><span class="line">    <span class="comment">// minit may update the stack bounds.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note: these bounds may not be very accurate.</span></span><br><span class="line">    <span class="comment">// We set hi to &amp;size, but there are things above</span></span><br><span class="line">    <span class="comment">// it. The 1024 is supposed to compensate this,</span></span><br><span class="line">    <span class="comment">// but is somewhat arbitrary.</span></span><br><span class="line">    size := _g_.stack.hi</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">      size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">    &#125;</span><br><span class="line">    _g_.stack.hi = <span class="type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">    _g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Initialize stack guard so that we can start calling regular</span></span><br><span class="line">  <span class="comment">// Go code.</span></span><br><span class="line">  _g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">  <span class="comment">// This is the g0, so we can also call go:systemstack</span></span><br><span class="line">  <span class="comment">// functions, which check stackguard1.</span></span><br><span class="line">  _g_.stackguard1 = _g_.stackguard0</span><br><span class="line">  mstart1()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exit this thread.</span></span><br><span class="line">  <span class="keyword">if</span> mStackIsSystemAllocated() &#123;</span><br><span class="line">    <span class="comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span></span><br><span class="line">    <span class="comment">// the stack, but put it in _g_.stack before mstart,</span></span><br><span class="line">    <span class="comment">// so the logic above hasn&#x27;t set osStack yet.</span></span><br><span class="line">    osStack = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看 <code>mstart1</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,</span></span><br><span class="line"><span class="comment">// so that we can set up g0.sched to return to the call of mstart1 above.</span></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定当前的G是g0</span></span><br><span class="line">  <span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">    throw(<span class="string">&quot;bad runtime·mstart&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up m.g0.sched as a label returning to just</span></span><br><span class="line">  <span class="comment">// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.</span></span><br><span class="line">  <span class="comment">// We&#x27;re never coming back to mstart1 after we call schedule,</span></span><br><span class="line">  <span class="comment">// so other calls can reuse the current frame.</span></span><br><span class="line">  <span class="comment">// And goexit0 does a gogo that needs to return from mstart1</span></span><br><span class="line">  <span class="comment">// and let mstart0 exit the thread.</span></span><br><span class="line">  <span class="comment">// 将 m.g0.sched 设置为在上面 mstart0 中的 mstart1 调用之后返回的标签，</span></span><br><span class="line">  <span class="comment">// 供 goexit0 和 mcall 使用。在调用 schedule 之后，我们永远不会回到 mstart1，</span></span><br><span class="line">  <span class="comment">// 因此其他调用可以重用当前帧。而goexit0做了一个gogo，需要从mstart1返回，让mstart0退出线程。</span></span><br><span class="line">  _g_.sched.g = guintptr(unsafe.Pointer(_g_))</span><br><span class="line">  _g_.sched.pc = getcallerpc()</span><br><span class="line">  _g_.sched.sp = getcallersp()</span><br><span class="line"></span><br><span class="line">  asminit()</span><br><span class="line">  minit()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install signal handlers; after minit so that minit can</span></span><br><span class="line">  <span class="comment">// prepare the thread to be able to handle the signals.</span></span><br><span class="line">  <span class="comment">// 如果是 m0，设置信号处理器，</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line">    mstartm0()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行启动函数</span></span><br><span class="line">  <span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">    fn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前 m 并非 m0，则要求绑定 p</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">    acquirep(_g_.m.nextp.ptr())</span><br><span class="line">    _g_.m.nextp = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="m-和-p-的绑定"><a class="markdownIt-Anchor" href="#m-和-p-的绑定"></a> <code>M</code> 和 <code>P</code> 的绑定</h5>
<p><code>M</code> 与 <code>P</code> 的绑定过程只是简单的将 <code>P</code> 链表中的 <code>P</code> ，保存到 <code>M</code> 中的 <code>P</code> 指针上。 绑定前，<code>P</code> 的状态一定是 <code>_Pidle</code>，绑定后 <code>P</code> 的状态一定为 <code>_Prunning</code>，具体实现是在 <code>acquirep</code> 中处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate p and the current m.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is allowed to have write barriers even if the caller</span></span><br><span class="line"><span class="comment">// isn&#x27;t because it immediately acquires _p_.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquirep</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Do the part that isn&#x27;t allowed to have write barriers.</span></span><br><span class="line">  wirep(_p_)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Have p; write barriers now allowed.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform deferred mcache flush before this P can allocate</span></span><br><span class="line">  <span class="comment">// from a potentially stale mcache.</span></span><br><span class="line">  _p_.mcache.prepareForSweep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">    traceProcStart()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wirep is the first step of acquirep, which actually associates the</span></span><br><span class="line"><span class="comment">// current M to _p_. This is broken out so we can disallow write</span></span><br><span class="line"><span class="comment">// barriers for this part, since we don&#x27;t yet have a P.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wirep</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查m是否已经绑定p</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;wirep: already in go&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查p是否已经绑定M或者P的状态不是_Pidle</span></span><br><span class="line">  <span class="keyword">if</span> _p_.m != <span class="number">0</span> || _p_.status != _Pidle &#123;</span><br><span class="line">    id := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> _p_.m != <span class="number">0</span> &#123;</span><br><span class="line">      id = _p_.m.ptr().id</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wirep: p-&gt;m=&quot;</span>, _p_.m, <span class="string">&quot;(&quot;</span>, id, <span class="string">&quot;) p-&gt;status=&quot;</span>, _p_.status, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    throw(<span class="string">&quot;wirep: invalid p state&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定关系，并且更新P的状态</span></span><br><span class="line">  _g_.m.p.set(_p_)</span><br><span class="line">  _p_.m.set(_g_.m)</span><br><span class="line">  _p_.status = _Prunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="m-的暂止和复始"><a class="markdownIt-Anchor" href="#m-的暂止和复始"></a> <code>M</code> 的暂止和复始</h5>
<p><code>M</code> 是系统线程的抽象，它只有两种状态：<code>park</code> 和 <code>unpark</code>。无论出于什么原因，当 <code>M</code> 需要被暂止时，会调用 <code>stopm</code> 将 <code>M</code> 进行暂止，并阻塞到它被复始时，这一过程就是工作线程的暂止和复始。它的流程也非常简单，将 <code>M</code> 放回至空闲列表中，而后使用 <code>note</code> 注册一个暂止通知， 阻塞到它重新被复始。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stops execution of the current m until new work is available.</span></span><br><span class="line"><span class="comment">// Returns with acquired P.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;stopm holding locks&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;stopm holding p&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">    throw(<span class="string">&quot;stopm spinning&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock(&amp;sched.lock)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 m 放回到 空闲列表中，因为我们马上就要暂止了</span></span><br><span class="line">  mput(_g_.m)</span><br><span class="line">  unlock(&amp;sched.lock)</span><br><span class="line">  mPark()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此时已经被复始，说明有任务要执行</span></span><br><span class="line">  <span class="comment">// 立即 acquire P</span></span><br><span class="line">  acquirep(_g_.m.nextp.ptr())</span><br><span class="line">  _g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mPark causes a thread to park itself - temporarily waking for</span></span><br><span class="line"><span class="comment">// fixups but otherwise waiting to be fully woken. This is the</span></span><br><span class="line"><span class="comment">// only way that m&#x27;s should park themselves.</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mPark</span><span class="params">()</span></span> &#123;</span><br><span class="line">  g := getg()</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 暂止当前的 M，在此阻塞，直到被唤醒</span></span><br><span class="line">    notesleep(&amp;g.m.park)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note, because of signal handling by this parked m,</span></span><br><span class="line">    <span class="comment">// a preemptive mDoFixup() may actually occur via</span></span><br><span class="line">    <span class="comment">// mDoFixupAndOSYield(). (See golang.org/issue/44193)</span></span><br><span class="line">    noteclear(&amp;g.m.park)</span><br><span class="line">    <span class="keyword">if</span> !mDoFixup() &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="核心调度"><a class="markdownIt-Anchor" href="#核心调度"></a> 核心调度</h5>
<p>核心调度是在 <code>shedule</code> 函数中进行的，目的就是找到一个可运行的G去运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;schedule: holding locks&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// m.lockedg 会在 LockOSThread 下变为非零</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">    stoplockedm()</span><br><span class="line">    execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们不应该将正在执行cgo调用的g给调度走，因为cgo调用是在m的g0栈上</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">    throw(<span class="string">&quot;schedule: in cgo&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">  pp := _g_.m.p.ptr()</span><br><span class="line">  pp.preempt = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要 GC，不再进行调度</span></span><br><span class="line">  <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">    gcstopm()</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> pp.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">    runSafePointFn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sanity check: if we are spinning, the run queue should be empty.</span></span><br><span class="line">  <span class="comment">// Check this before calling checkTimers, as that might call</span></span><br><span class="line">  <span class="comment">// goready to put a ready goroutine on the local run queue.</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m.spinning &amp;&amp; (pp.runnext != <span class="number">0</span> || pp.runqhead != pp.runqtail) &#123;</span><br><span class="line">    throw(<span class="string">&quot;schedule: spinning with local work&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkTimers(pp, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> gp *g</span><br><span class="line">  <span class="keyword">var</span> inheritTime <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Normal goroutines will check for need to wakeP in ready,</span></span><br><span class="line">  <span class="comment">// but GCworkers and tracereaders will not, so the check must</span></span><br><span class="line">  <span class="comment">// be done here instead.</span></span><br><span class="line">  tryWakeP := <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">    gp = traceReader()</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">      casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">      traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">      tryWakeP = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果正在GC，那就去找GC的g</span></span><br><span class="line">  <span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">    gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">      tryWakeP = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line">    <span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line">    <span class="comment">// by constantly respawning each other.</span></span><br><span class="line">    <span class="comment">// 每调度P上的G61次，就去全局队列找一找</span></span><br><span class="line">    <span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">      lock(&amp;sched.lock)</span><br><span class="line">      gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">      unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从当前P的 runnext 或者 runq 中查找</span></span><br><span class="line">  <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">    gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">    <span class="comment">// We can see gp != nil here even if the M is spinning,</span></span><br><span class="line">    <span class="comment">// if checkTimers added a local goroutine via goready.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从其他P中偷取</span></span><br><span class="line">  <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// findrunnable 挺长的，主要实现是从其他P偷取，查看 netpool 或者全局队列</span></span><br><span class="line">    <span class="comment">// 如果都找不到那么会调用 stopm 函数进行休眠，指导找到一个可运行的G</span></span><br><span class="line">    gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到G了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This thread is going to run a goroutine and is not spinning anymore,</span></span><br><span class="line">  <span class="comment">// so if it was marked as spinning we need to reset it now and potentially</span></span><br><span class="line">  <span class="comment">// start a new spinning M.</span></span><br><span class="line">  <span class="comment">// 这个线程将去运行一个G，所以它不能再自旋了，所以如果它是自旋状态我们需要重置。</span></span><br><span class="line">  <span class="comment">// 并且在这中间可能创建新的M。</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">    resetspinning()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">    <span class="comment">// Scheduling of this goroutine is disabled. Put it on</span></span><br><span class="line">    <span class="comment">// the list of pending runnable goroutines for when we</span></span><br><span class="line">    <span class="comment">// re-enable user scheduling and look again.</span></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">      <span class="comment">// Something re-enabled scheduling while we</span></span><br><span class="line">      <span class="comment">// were acquiring the lock.</span></span><br><span class="line">      unlock(&amp;sched.lock)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sched.disable.runnable.pushBack(gp)</span><br><span class="line">      sched.disable.n++</span><br><span class="line">      unlock(&amp;sched.lock)</span><br><span class="line">      <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If about to schedule a not-normal goroutine (a GCworker or tracereader),</span></span><br><span class="line">  <span class="comment">// wake a P if there is one.</span></span><br><span class="line">  <span class="keyword">if</span> tryWakeP &#123;</span><br><span class="line">    wakep()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 g 需要 lock 到 m 上，则会将当前的 p， 给这个要 lock 的 g</span></span><br><span class="line">	<span class="comment">// 然后阻塞等待一个新的 p</span></span><br><span class="line">    startlockedm(gp)</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始执行</span></span><br><span class="line">  execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接着看 <code>execute</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schedules gp to run on the current M.</span></span><br><span class="line"><span class="comment">// If inheritTime is true, gp inherits the remaining time in the</span></span><br><span class="line"><span class="comment">// current time slice. Otherwise, it starts a new time slice.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write barriers are allowed because this is called immediately after</span></span><br><span class="line"><span class="comment">// acquiring a P in several places.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 g 正式切换为 _Grunning 状态</span></span><br><span class="line">  _g_.m.curg = gp</span><br><span class="line">  gp.m = _g_.m</span><br><span class="line">  casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">  gp.waitsince = <span class="number">0</span></span><br><span class="line">  gp.preempt = <span class="literal">false</span></span><br><span class="line">  gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 inheritTime 为 true，则 gp 继承剩余的时间片。否则从一个新的时间片开始</span></span><br><span class="line">  <span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">    _g_.m.p.ptr().schedtick++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// profiling 相关</span></span><br><span class="line">  hz := sched.profilehz</span><br><span class="line">  <span class="keyword">if</span> _g_.m.profilehz != hz &#123;</span><br><span class="line">    setThreadCPUProfiler(hz)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">    <span class="comment">// GoSysExit has to happen when we have a P, but before GoStart.</span></span><br><span class="line">    <span class="comment">// So we emit it here.</span></span><br><span class="line">    <span class="keyword">if</span> gp.syscallsp != <span class="number">0</span> &amp;&amp; gp.sysblocktraced &#123;</span><br><span class="line">      traceGoSysExit(gp.sysexitticks)</span><br><span class="line">    &#125;</span><br><span class="line">    traceGoStart()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置了一些必要的东西之后开始执行了</span></span><br><span class="line">  gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当开始执行 <code>execute</code> 后，<code>g</code> 会被切换到 <code>_Grunning</code> 状态。 设置自身的抢占信号，将 <code>m</code> 和 <code>g</code> 进行绑定。 最终调用 <code>gogo</code> 开始执行，<code>gogo</code> 使用汇编实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// func gogo(buf *gobuf)</span><br><span class="line">// restore state from Gobuf; longjmp</span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $0-8</span><br><span class="line">	MOVQ	buf+0(FP), BX		/// 运行现场</span><br><span class="line">	MOVQ	gobuf_g(BX), DX</span><br><span class="line">	MOVQ	0(DX), CX		// 确认 g != nil</span><br><span class="line">	JMP	gogo&lt;&gt;(SB)</span><br><span class="line"></span><br><span class="line">TEXT gogo&lt;&gt;(SB), NOSPLIT, $0</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	DX, g(CX)</span><br><span class="line">	MOVQ	DX, R14		// set the g register</span><br><span class="line">	MOVQ	gobuf_sp(BX), SP	// 恢复 SP</span><br><span class="line">	MOVQ	gobuf_ret(BX), AX</span><br><span class="line">	MOVQ	gobuf_ctxt(BX), DX</span><br><span class="line">	MOVQ	gobuf_bp(BX), BP</span><br><span class="line">	MOVQ	$0, gobuf_sp(BX)	// 清理，辅助 GC</span><br><span class="line">	MOVQ	$0, gobuf_ret(BX)</span><br><span class="line">	MOVQ	$0, gobuf_ctxt(BX)</span><br><span class="line">	MOVQ	$0, gobuf_bp(BX)</span><br><span class="line">	MOVQ	gobuf_pc(BX), BX  // 获取 g 要执行的函数的入口地址</span><br><span class="line">	JMP	BX</span><br></pre></td></tr></table></figure>
<p>使用 <code>JMP BX</code> 指令执行G（里面的过程着实有点复杂），在执行结束之后会调用 <code>runtime.goexit</code> 函数进行运行现场的清理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// The top-most function running on a goroutine</span><br><span class="line">// returns to goexit+PCQuantum.</span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT|NOFRAME|TOPFRAME,$0-0</span><br><span class="line">	MOVD	R0, R0	// NOP</span><br><span class="line">	BL	runtime·goexit1(SB)	// does not return</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mcall switches from the g to the g0 stack and invokes fn(g),</span></span><br><span class="line"><span class="comment">// where g is the goroutine that made the call.</span></span><br><span class="line"><span class="comment">// mcall saves g&#x27;s current PC/SP in g-&gt;sched so that it can be restored later.</span></span><br><span class="line"><span class="comment">// It is up to fn to arrange for that later execution, typically by recording</span></span><br><span class="line"><span class="comment">// g in a data structure, causing something to call ready(g) later.</span></span><br><span class="line"><span class="comment">// mcall returns to the original goroutine g later, when g has been rescheduled.</span></span><br><span class="line"><span class="comment">// fn must not return at all; typically it ends by calling schedule, to let the m</span></span><br><span class="line"><span class="comment">// run other goroutines.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mcall can only be called from g stacks (not g0, not gsignal).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This must NOT be go:noescape: if fn is a stack-allocated closure,</span></span><br><span class="line"><span class="comment">// fn puts g on a run queue, and g executes before fn returns, the</span></span><br><span class="line"><span class="comment">// closure will be invalidated while it is still executing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mcall</span><span class="params">(fn <span class="keyword">func</span>(*g)</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finishes execution of the current goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">    racegoend()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">    traceGoEnd()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 切换到 m-&gt;g0 栈, 并调用 fn(g).</span></span><br><span class="line">  <span class="comment">// 通过 mcall 完成 goexit0 的调用</span></span><br><span class="line">  mcall(goexit0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goexit continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// // 切换当前的 g 为 _Gdead</span></span><br><span class="line">  casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">  <span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">    atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理</span></span><br><span class="line">  gp.m = <span class="literal">nil</span></span><br><span class="line">  locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">  gp.lockedm = <span class="number">0</span></span><br><span class="line">  _g_.m.lockedg = <span class="number">0</span></span><br><span class="line">  gp.preemptStop = <span class="literal">false</span></span><br><span class="line">  gp.paniconfault = <span class="literal">false</span></span><br><span class="line">  gp._defer = <span class="literal">nil</span> <span class="comment">// 应该已经为 true，但以防万一</span></span><br><span class="line">  gp._panic = <span class="literal">nil</span> <span class="comment">// Goexit 中 panic 则不为 nil， 指向栈分配的数据</span></span><br><span class="line">  gp.writebuf = <span class="literal">nil</span></span><br><span class="line">  gp.waitreason = <span class="number">0</span></span><br><span class="line">  gp.param = <span class="literal">nil</span></span><br><span class="line">  gp.labels = <span class="literal">nil</span></span><br><span class="line">  gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 刷新 assist credit 到全局池。</span></span><br><span class="line">	<span class="comment">// 如果应用在快速创建 Goroutine，这可以为 pacing 提供更好的信息。</span></span><br><span class="line">    assistWorkPerByte := float64frombits(atomic.Load64(&amp;gcController.assistWorkPerByte))</span><br><span class="line">    scanCredit := <span class="type">int64</span>(assistWorkPerByte * <span class="type">float64</span>(gp.gcAssistBytes))</span><br><span class="line">    atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class="line">    gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解绑 m 和 g</span></span><br><span class="line">  dropg()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123; <span class="comment">// no threads yet on wasm</span></span><br><span class="line">    gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">    schedule() <span class="comment">// never returns</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _g_.m.lockedInt != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;invalid m-&gt;lockedInt = &quot;</span>, _g_.m.lockedInt, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    throw(<span class="string">&quot;internal lockOSThread error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// // 将 g 扔进 gfree 链表中等待复用</span></span><br><span class="line">  gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">  <span class="keyword">if</span> locked &#123;</span><br><span class="line">    <span class="comment">// The goroutine may have locked this thread because</span></span><br><span class="line">    <span class="comment">// it put it in an unusual kernel state. Kill it</span></span><br><span class="line">    <span class="comment">// rather than returning it to the thread pool.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return to mstart, which will release the P and exit</span></span><br><span class="line">    <span class="comment">// the thread.</span></span><br><span class="line">    <span class="keyword">if</span> GOOS != <span class="string">&quot;plan9&quot;</span> &#123; <span class="comment">// See golang.org/issue/22227.</span></span><br><span class="line">      gogo(&amp;_g_.m.g0.sched)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Clear lockedExt on plan9 since we may end up re-using</span></span><br><span class="line">      <span class="comment">// this thread.</span></span><br><span class="line">      _g_.m.lockedExt = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 再次进行调度</span></span><br><span class="line">  schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="偷取-goroutine"><a class="markdownIt-Anchor" href="#偷取-goroutine"></a> 偷取 <code>Goroutine</code></h5>
<p>全局 <code>g</code> 链式队列中取 max 个 <code>g</code>，其中第一个用于执行，max-1 个放入本地队列。 如果放不下，则只在本地队列中放下能放的。过程比较简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从全局可运行队列中获取可运行G时必须持有 sched.lock</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqget</span><span class="params">(_p_ *p, max <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">  assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果全局队列中没有 g 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> sched.runqsize == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个P应该从全局队列偷多少</span></span><br><span class="line">  n := sched.runqsize/gomaxprocs + <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> n &gt; sched.runqsize &#123;</span><br><span class="line">    n = sched.runqsize</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不能超过取的最大个数</span></span><br><span class="line">  <span class="keyword">if</span> max &gt; <span class="number">0</span> &amp;&amp; n &gt; max &#123;</span><br><span class="line">    n = max</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算能不能在本地队列中放下 n 个</span></span><br><span class="line">  <span class="keyword">if</span> n &gt; <span class="type">int32</span>(<span class="built_in">len</span>(_p_.runq))/<span class="number">2</span> &#123;</span><br><span class="line">    n = <span class="type">int32</span>(<span class="built_in">len</span>(_p_.runq)) / <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改本地队列的剩余空间</span></span><br><span class="line">  sched.runqsize -= n</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到全局队列队头 g</span></span><br><span class="line">  gp := sched.runq.pop()</span><br><span class="line">  n--</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继续取剩下的 n-1 个全局队列放入本地队列</span></span><br><span class="line">  <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">    gp1 := sched.runq.pop()</span><br><span class="line">    runqput(_p_, gp1, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从本地队列中取，首先看 next 是否有已经安排要运行的 <code>g</code> ，如果有，则返回下一个要运行的 <code>g</code> 否则，以 <code>cas</code> 的方式从本地队列中取一个 <code>g</code>。如果是已经安排要运行的 <code>g</code>，则继承剩余的可运行时间片进行运行，否则以一个新的时间片来运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从本地可运行队列中获取 g</span></span><br><span class="line"><span class="comment">// 如果 inheritTime 为 true，则 g 继承剩余的时间片</span></span><br><span class="line"><span class="comment">// 否则开始一个新的时间片。在所有者 P 上执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqget</span><span class="params">(_p_ *p)</span></span> (gp *g, inheritTime <span class="type">bool</span>) &#123;</span><br><span class="line">  <span class="comment">// If there&#x27;s a runnext, it&#x27;s the next G to run.</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    next := _p_.runnext</span><br><span class="line">    <span class="keyword">if</span> next == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 cas 成功，则 g 继承剩余时间片执行</span></span><br><span class="line">    <span class="keyword">if</span> _p_.runnext.cas(next, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> next.ptr(), <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    h := atomic.LoadAcq(&amp;_p_.runqhead) <span class="comment">// load-acquire, synchronize with other consumers</span></span><br><span class="line">    t := _p_.runqtail</span><br><span class="line">    <span class="comment">// 本地队列是空，返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> t == h &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从本地队列中以 cas 方式拿一个</span></span><br><span class="line">    gp := _p_.runq[h%<span class="type">uint32</span>(<span class="built_in">len</span>(_p_.runq))].ptr()</span><br><span class="line">    <span class="keyword">if</span> atomic.CasRel(&amp;_p_.runqhead, h, h+<span class="number">1</span>) &#123; <span class="comment">// cas-release, commits consume</span></span><br><span class="line">      <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偷取（<code>steal</code>）的实现是一个非常复杂的过程。这个过程来源于我们 需要仔细的思考什么时候对调度器进行加锁、什么时候对 <code>m</code> 进行暂止、 什么时候将 <code>m</code> 从自旋向非自旋切换等等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找一个可运行的 Goroutine 来执行。</span></span><br><span class="line"><span class="comment">// 尝试从其他的 P 偷取、从全局队列中获取、poll 网络</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span></span> (gp *g, inheritTime <span class="type">bool</span>) &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的条件与 handoffp 中的条件必须一致：</span></span><br><span class="line">  <span class="comment">// 如果 findrunnable 将返回 G 运行，handoffp 必须启动 M.</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">  _p_ := _g_.m.p.ptr()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果在 gc，则暂止当前 m，直到复始后回到 top</span></span><br><span class="line">  <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">    gcstopm()</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">    runSafePointFn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  now, pollUntil, _ := checkTimers(_p_, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">    <span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">      ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cgo 调用被终止，继续进入</span></span><br><span class="line">  <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">    asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取本地队列 local runq，如果已经拿到，立刻返回</span></span><br><span class="line">  <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gp, inheritTime</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局队列 global runq，如果已经拿到，立刻返回</span></span><br><span class="line">  <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Poll 网络，优先级比从其他 P 中偷要高。</span></span><br><span class="line">  <span class="comment">// 在我们尝试去其他 P 偷之前，这个 netpoll 只是一个优化。</span></span><br><span class="line">  <span class="comment">// 如果没有 waiter 或 netpoll 中的线程已被阻塞，则可以安全地跳过它。</span></span><br><span class="line">  <span class="comment">// 如果有任何类型的逻辑竞争与被阻塞的线程（例如它已经从 netpoll 返回，但尚未设置 lastpoll）</span></span><br><span class="line">  <span class="comment">// 该线程无论如何都将阻塞 netpoll。</span></span><br><span class="line">  <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">      gp := list.pop()</span><br><span class="line">      injectglist(&amp;list)</span><br><span class="line">      casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">      <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Spinning Ms: steal work from other Ps.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Limit the number of spinning Ms to half the number of busy Ps.</span></span><br><span class="line">  <span class="comment">// This is necessary to prevent excessive CPU consumption when</span></span><br><span class="line">  <span class="comment">// GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span></span><br><span class="line">  procs := <span class="type">uint32</span>(gomaxprocs)</span><br><span class="line">  <span class="keyword">if</span> _g_.m.spinning || <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &lt; procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">      _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">      atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">    now = tnow</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 偷取成功</span></span><br><span class="line">      <span class="keyword">return</span> gp, inheritTime</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> newWork &#123;</span><br><span class="line">      <span class="comment">// There may be new timer or GC work; restart to</span></span><br><span class="line">      <span class="comment">// discover.</span></span><br><span class="line">      <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">      <span class="comment">// Earlier timer to wait for.</span></span><br><span class="line">      pollUntil = w</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有任何 work 可做。</span></span><br><span class="line">  <span class="comment">// 如果我们在 GC mark 阶段，则可以安全的扫描并 blacken 对象</span></span><br><span class="line">  <span class="comment">// 然后便有 work 可做，运行 idle-time 标记而非直接放弃当前的 P。</span></span><br><span class="line">  <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">    node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">    <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">      _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">      gp := node.gp.ptr()</span><br><span class="line">      casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">      <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅限于 wasm</span></span><br><span class="line">  <span class="comment">// 如果一个回调返回后没有其他 Goroutine 是苏醒的</span></span><br><span class="line">  <span class="comment">// 则暂停执行直到回调被触发。</span></span><br><span class="line">  gp, otherReady := beforeIdle(now, pollUntil)</span><br><span class="line">  <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">    casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">      traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> otherReady &#123;</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 放弃当前的 P 之前，对 allp 做一个快照</span></span><br><span class="line">  <span class="comment">// 一旦我们不再阻塞在 safe-point 时候，可以立刻在下面进行修改</span></span><br><span class="line">  allpSnapshot := allp</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Also snapshot masks. Value changes are OK, but we can&#x27;t allow</span></span><br><span class="line">  <span class="comment">// len to change out from under us.</span></span><br><span class="line">  idlepMaskSnapshot := idlepMask</span><br><span class="line">  timerpMaskSnapshot := timerpMask</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备归还 p，对调度器加锁</span></span><br><span class="line">  lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入了 gc，回到顶部暂止 m</span></span><br><span class="line">  <span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">goto</span> top</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局队列中又发现了任务</span></span><br><span class="line">  <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">    gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 归还当前的 p</span></span><br><span class="line">  <span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">    throw(<span class="string">&quot;findrunnable: wrong p&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 p 放入 idle 链表</span></span><br><span class="line">  pidleput(_p_)</span><br><span class="line">  unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里要非常小心:</span></span><br><span class="line">  <span class="comment">// 线程从自旋到非自旋状态的转换，可能与新 Goroutine 的提交同时发生。</span></span><br><span class="line">  <span class="comment">// 我们必须首先丢弃 nmspinning，然后再次检查所有的 per-P 队列（并在期间伴随 #StoreLoad 内存屏障）</span></span><br><span class="line">  <span class="comment">// 如果反过来，其他线程可以在我们检查了所有的队列、然后提交一个 Goroutine、再丢弃了 nmspinning</span></span><br><span class="line">  <span class="comment">// 进而导致无法复始一个线程来运行那个 Goroutine 了。</span></span><br><span class="line">  <span class="comment">// 如果我们发现下面的新 work，我们需要恢复 m.spinning 作为重置的信号，</span></span><br><span class="line">  <span class="comment">// 以取消暂止新的工作线程（因为可能有多个 starving 的 Goroutine）。</span></span><br><span class="line">  <span class="comment">// 但是，如果在发现新 work 后我们也观察到没有空闲 P，可以暂停当前线程</span></span><br><span class="line">  <span class="comment">// 因为系统已满载，因此不需要自旋线程。</span></span><br><span class="line">  wasSpinning := _g_.m.spinning</span><br><span class="line">  <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">    _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;findrunnable: negative nmspinning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note the for correctness, only the last M transitioning from</span></span><br><span class="line">    <span class="comment">// spinning to non-spinning must perform these rechecks to</span></span><br><span class="line">    <span class="comment">// ensure no missed work. We are performing it on every M that</span></span><br><span class="line">    <span class="comment">// transitions as a conservative change to monitor effects on</span></span><br><span class="line">    <span class="comment">// latency. See golang.org/issue/43997.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查所有的 runqueue</span></span><br><span class="line">    _p_ = checkRunqsNoP(allpSnapshot, idlepMaskSnapshot)</span><br><span class="line">    <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">      acquirep(_p_)</span><br><span class="line">      _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">      atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查 idle-priority GC work</span></span><br><span class="line">    _p_, gp = checkIdleGCNoP()</span><br><span class="line">    <span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">      acquirep(_p_)</span><br><span class="line">      _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">      atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Run the idle worker.</span></span><br><span class="line">      _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">      casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">      <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, check for timer creation or expiry concurrently with</span></span><br><span class="line">    <span class="comment">// transitioning from spinning to non-spinning.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that we cannot use checkTimers here because it calls</span></span><br><span class="line">    <span class="comment">// adjusttimers which may need to allocate memory, and that isn&#x27;t</span></span><br><span class="line">    <span class="comment">// allowed when we don&#x27;t have an active P.</span></span><br><span class="line">    pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Poll network until next timer.</span></span><br><span class="line">  <span class="keyword">if</span> netpollinited() &amp;&amp; (atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> || pollUntil != <span class="number">0</span>) &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">    atomic.Store64(&amp;sched.pollUntil, <span class="type">uint64</span>(pollUntil))</span><br><span class="line">    <span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;findrunnable: netpoll with p&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">      throw(<span class="string">&quot;findrunnable: netpoll with spinning&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    delay := <span class="type">int64</span>(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> pollUntil != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">        now = nanotime()</span><br><span class="line">      &#125;</span><br><span class="line">      delay = pollUntil - now</span><br><span class="line">      <span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line">        delay = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> faketime != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// When using fake time, just poll.</span></span><br><span class="line">      delay = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    list := netpoll(delay) <span class="comment">// block until new work is available</span></span><br><span class="line">    atomic.Store64(&amp;sched.pollUntil, <span class="number">0</span>)</span><br><span class="line">    atomic.Store64(&amp;sched.lastpoll, <span class="type">uint64</span>(nanotime()))</span><br><span class="line">    <span class="keyword">if</span> faketime != <span class="number">0</span> &amp;&amp; list.empty() &#123;</span><br><span class="line">      <span class="comment">// Using fake time and nothing is ready; stop M.</span></span><br><span class="line">      <span class="comment">// When all M&#x27;s stop, checkdead will call timejump.</span></span><br><span class="line">      stopm()</span><br><span class="line">      <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    _p_ = pidleget()</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">      injectglist(&amp;list)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      acquirep(_p_)</span><br><span class="line">      <span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">        gp := list.pop()</span><br><span class="line">        injectglist(&amp;list)</span><br><span class="line">        casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">        <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">          traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">        _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">        atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> top</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> pollUntil != <span class="number">0</span> &amp;&amp; netpollinited() &#123;</span><br><span class="line">    pollerPollUntil := <span class="type">int64</span>(atomic.Load64(&amp;sched.pollUntil))</span><br><span class="line">    <span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; pollUntil &#123;</span><br><span class="line">      netpollBreak()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stopm()</span><br><span class="line">  <span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="唤醒m"><a class="markdownIt-Anchor" href="#唤醒m"></a> 唤醒<code>M</code></h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetspinning</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line">  <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">    throw(<span class="string">&quot;resetspinning: not a spinning m&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  _g_.m.spinning = <span class="literal">false</span></span><br><span class="line">  nmspinning := atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="type">int32</span>(nmspinning) &lt; <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;findrunnable: negative nmspinning&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// M wakeup policy is deliberately somewhat conservative, so check if we</span></span><br><span class="line">  <span class="comment">// need to wakeup another P here. See &quot;Worker thread parking/unparking&quot;</span></span><br><span class="line">  <span class="comment">// comment at the top of the file for details.</span></span><br><span class="line">  wakep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将一个或多个 P 唤醒来执行 G</span></span><br><span class="line"><span class="comment">// 当 G 可能运行时（newproc, ready）时调用该函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// be conservative about spinning threads</span></span><br><span class="line">  <span class="keyword">if</span> atomic.Load(&amp;sched.nmspinning) != <span class="number">0</span> || !atomic.Cas(&amp;sched.nmspinning, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  startm(<span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedules some M to run the p (creates an M if necessary).</span></span><br><span class="line"><span class="comment">// If p==nil, tries to get an idle P, if no idle P&#x27;s does nothing.</span></span><br><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">// If spinning is set, the caller has incremented nmspinning and startm will</span></span><br><span class="line"><span class="comment">// either decrement nmspinning or set m.spinning in the newly started M.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Callers passing a non-nil P must call from a non-preemptible context. See</span></span><br><span class="line"><span class="comment">// comment on acquirem below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Must not have write barriers because this may be called without a P.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Disable preemption.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Every owned P must have an owner that will eventually stop it in the</span></span><br><span class="line">  <span class="comment">// event of a GC stop request. startm takes transient ownership of a P</span></span><br><span class="line">  <span class="comment">// (either from argument or pidleget below) and transfers ownership to</span></span><br><span class="line">  <span class="comment">// a started M, which will be responsible for performing the stop.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Preemption must be disabled during this transient ownership,</span></span><br><span class="line">  <span class="comment">// otherwise the P this is running on may enter GC stop while still</span></span><br><span class="line">  <span class="comment">// holding the transient P, leaving that P in limbo and deadlocking the</span></span><br><span class="line">  <span class="comment">// STW.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Callers passing a non-nil P must already be in non-preemptible</span></span><br><span class="line">  <span class="comment">// context, otherwise such preemption could occur on function entry to</span></span><br><span class="line">  <span class="comment">// startm. Callers passing a nil P may be preemptible, so we must</span></span><br><span class="line">  <span class="comment">// disable preemption before acquiring a P from pidleget below.</span></span><br><span class="line">  mp := acquirem()</span><br><span class="line">  lock(&amp;sched.lock)</span><br><span class="line">  <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">    _p_ = pidleget()</span><br><span class="line">    <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">      unlock(&amp;sched.lock)</span><br><span class="line">      <span class="keyword">if</span> spinning &#123;</span><br><span class="line">        <span class="comment">// The caller incremented nmspinning, but there are no idle Ps,</span></span><br><span class="line">        <span class="comment">// so it&#x27;s okay to just undo the increment and give up.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="type">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">          throw(<span class="string">&quot;startm: negative nmspinning&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      releasem(mp)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nmp := mget()</span><br><span class="line">  <span class="keyword">if</span> nmp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// No M is available, we must drop sched.lock and call newm.</span></span><br><span class="line">    <span class="comment">// However, we already own a P to assign to the M.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Once sched.lock is released, another G (e.g., in a syscall),</span></span><br><span class="line">    <span class="comment">// could find no idle P while checkdead finds a runnable G but</span></span><br><span class="line">    <span class="comment">// no running M&#x27;s because this new M hasn&#x27;t started yet, thus</span></span><br><span class="line">    <span class="comment">// throwing in an apparent deadlock.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Avoid this situation by pre-allocating the ID for the new M,</span></span><br><span class="line">    <span class="comment">// thus marking it as &#x27;running&#x27; before we drop sched.lock. This</span></span><br><span class="line">    <span class="comment">// new M will eventually run the scheduler to execute any</span></span><br><span class="line">    <span class="comment">// queued G&#x27;s.</span></span><br><span class="line">    id := mReserveID()</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> spinning &#123;</span><br><span class="line">      <span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">      fn = mspinning</span><br><span class="line">    &#125;</span><br><span class="line">    newm(fn, _p_, id)</span><br><span class="line">    <span class="comment">// Ownership transfer of _p_ committed by start in newm.</span></span><br><span class="line">    <span class="comment">// Preemption is now safe.</span></span><br><span class="line">    releasem(mp)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  unlock(&amp;sched.lock)</span><br><span class="line">  <span class="keyword">if</span> nmp.spinning &#123;</span><br><span class="line">    throw(<span class="string">&quot;startm: m is spinning&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> nmp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;startm: m has p&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> spinning &amp;&amp; !runqempty(_p_) &#123;</span><br><span class="line">    throw(<span class="string">&quot;startm: p has runnable gs&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">  nmp.spinning = spinning</span><br><span class="line">  nmp.nextp.set(_p_)</span><br><span class="line">  notewakeup(&amp;nmp.park)</span><br><span class="line">  <span class="comment">// Ownership transfer of _p_ committed by wakeup. Preemption is now</span></span><br><span class="line">  <span class="comment">// safe.</span></span><br><span class="line">  releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从 midel 列表中获取一个 M</span></span><br><span class="line"><span class="comment">// 调度器必须锁住</span></span><br><span class="line"><span class="comment">// 可能在 STW 期间运行，故不允许 write barrier</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mget</span><span class="params">()</span></span> *m &#123;</span><br><span class="line">  assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">  mp := sched.midle.ptr()</span><br><span class="line">  <span class="keyword">if</span> mp != <span class="literal">nil</span> &#123;</span><br><span class="line">    sched.midle = mp.schedlink</span><br><span class="line">    sched.nmidle--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="新建m"><a class="markdownIt-Anchor" href="#新建m"></a> 新建<code>M</code></h5>
<p><code>M</code> 是通过 <code>newm</code> 来创生的，一般情况下，能够非常简单的创建， 某些特殊情况（线程状态被污染），<code>M</code> 的创建需要一个叫做模板线程的功能加以配合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 m. 它会启动并调用 fn 或调度器</span></span><br><span class="line"><span class="comment">// fn 必须是静态、非堆上分配的闭包</span></span><br><span class="line"><span class="comment">// 它可能在 m.p==nil 时运行，因此不允许 write barrier</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// id is optional pre-allocated m ID. Omit by passing -1.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span></span>, _p_ *p, id <span class="type">int64</span>) &#123;</span><br><span class="line">  <span class="comment">// 分配一个 m</span></span><br><span class="line">  mp := allocm(_p_, fn, id)</span><br><span class="line">  mp.doesPark = (_p_ != <span class="literal">nil</span>)</span><br><span class="line">  <span class="comment">// 设置 p 用于后续绑定</span></span><br><span class="line">  mp.nextp.set(_p_)</span><br><span class="line">  <span class="comment">// 设置 signal mask</span></span><br><span class="line">  mp.sigmask = initSigmask</span><br><span class="line">  <span class="keyword">if</span> gp := getg(); gp != <span class="literal">nil</span> &amp;&amp; gp.m != <span class="literal">nil</span> &amp;&amp; (gp.m.lockedExt != <span class="number">0</span> || gp.m.incgo) &amp;&amp; GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// We&#x27;re on a locked M or a thread that may have been</span></span><br><span class="line">    <span class="comment">// started by C. The kernel state of this thread may</span></span><br><span class="line">    <span class="comment">// be strange (the user may have locked it for that</span></span><br><span class="line">    <span class="comment">// purpose). We don&#x27;t want to clone that into another</span></span><br><span class="line">    <span class="comment">// thread. Instead, ask a known-good thread to create</span></span><br><span class="line">    <span class="comment">// the thread for us.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is disabled on Plan 9. See golang.org/issue/22227.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> This may be unnecessary on Windows, which</span></span><br><span class="line">    <span class="comment">// doesn&#x27;t model thread creation off fork.</span></span><br><span class="line">    lock(&amp;newmHandoff.lock)</span><br><span class="line">    <span class="keyword">if</span> newmHandoff.haveTemplateThread == <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;on a locked thread with no template thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mp.schedlink = newmHandoff.newm</span><br><span class="line">    newmHandoff.newm.set(mp)</span><br><span class="line">    <span class="keyword">if</span> newmHandoff.waiting &#123;</span><br><span class="line">      newmHandoff.waiting = <span class="literal">false</span></span><br><span class="line">      <span class="comment">// 唤醒 m, 自旋到非自旋</span></span><br><span class="line">      notewakeup(&amp;newmHandoff.wake)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;newmHandoff.lock)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  newm1(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new m unassociated with any thread.</span></span><br><span class="line"><span class="comment">// Can use p for allocation context if needed.</span></span><br><span class="line"><span class="comment">// fn is recorded as the new m&#x27;s m.mstartfn.</span></span><br><span class="line"><span class="comment">// id is optional pre-allocated m ID. Omit by passing -1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is allowed to have write barriers even if the caller</span></span><br><span class="line"><span class="comment">// isn&#x27;t because it borrows _p_.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:yeswritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocm</span><span class="params">(_p_ *p, fn <span class="keyword">func</span>()</span></span>, id <span class="type">int64</span>) *m &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line">  acquirem() <span class="comment">// disable GC because it can be called from sysmon</span></span><br><span class="line">  <span class="keyword">if</span> _g_.m.p == <span class="number">0</span> &#123;</span><br><span class="line">    acquirep(_p_) <span class="comment">// temporarily borrow p for mallocs in this function</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the free M list. We need to do this somewhere and</span></span><br><span class="line">  <span class="comment">// this may free up a stack we can use.</span></span><br><span class="line">  <span class="keyword">if</span> sched.freem != <span class="literal">nil</span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">var</span> newList *m</span><br><span class="line">    <span class="keyword">for</span> freem := sched.freem; freem != <span class="literal">nil</span>; &#123;</span><br><span class="line">      <span class="keyword">if</span> freem.freeWait != <span class="number">0</span> &#123;</span><br><span class="line">        next := freem.freelink</span><br><span class="line">        freem.freelink = newList</span><br><span class="line">        newList = freem</span><br><span class="line">        freem = next</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// stackfree must be on the system stack, but allocm is</span></span><br><span class="line">      <span class="comment">// reachable off the system stack transitively from</span></span><br><span class="line">      <span class="comment">// startm.</span></span><br><span class="line">      systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stackfree(freem.g0.stack)</span><br><span class="line">      &#125;)</span><br><span class="line">      freem = freem.freelink</span><br><span class="line">    &#125;</span><br><span class="line">    sched.freem = newList</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mp := <span class="built_in">new</span>(m)</span><br><span class="line">  mp.mstartfn = fn</span><br><span class="line">  mcommoninit(mp, id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.</span></span><br><span class="line">  <span class="comment">// Windows and Plan 9 will layout sched stack on OS stack.</span></span><br><span class="line">  <span class="keyword">if</span> iscgo || mStackIsSystemAllocated() &#123;</span><br><span class="line">    mp.g0 = malg(<span class="number">-1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mp.g0 = malg(<span class="number">8192</span> * sys.StackGuardMultiplier)</span><br><span class="line">  &#125;</span><br><span class="line">  mp.g0.m = mp</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _p_ == _g_.m.p.ptr() &#123;</span><br><span class="line">    releasep()</span><br><span class="line">  &#125;</span><br><span class="line">  releasem(_g_.m)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> iscgo &#123;</span><br><span class="line">    <span class="keyword">var</span> ts cgothreadstart</span><br><span class="line">    <span class="keyword">if</span> _cgo_thread_start == <span class="literal">nil</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;_cgo_thread_start missing&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ts.g.set(mp.g0)</span><br><span class="line">    ts.tls = (*<span class="type">uint64</span>)(unsafe.Pointer(&amp;mp.tls[<span class="number">0</span>]))</span><br><span class="line">    ts.fn = unsafe.Pointer(funcPC(mstart))</span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">      msanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))</span><br><span class="line">    &#125;</span><br><span class="line">    execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">    asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))</span><br><span class="line">    execLock.runlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">  newosproc(mp)</span><br><span class="line">  execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>m</code> 被创建时，会转去运行 <code>mstart</code>：</p>
<ul>
<li>如果当前程序为 <code>cgo</code> 程序，则会通过 <code>asmcgocall</code> 来创建线程并调用 <code>mstart</code></li>
<li>否则会调用 <code>newosproc</code> 来创建线程，从而调用 <code>mstart</code>。</li>
</ul>
<p>既然是 <code>newosproc</code> ，我们此刻仍在 Go 的空间中，那么实现就是操作系统特定的了，以下是linux上的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * note: strace gets confused if we use CLONE_PTRACE here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;newosproc stk=&quot;</span>, stk, <span class="string">&quot; m=&quot;</span>, mp, <span class="string">&quot; g=&quot;</span>, mp.g0, <span class="string">&quot; clone=&quot;</span>, funcPC(clone), <span class="string">&quot; id=&quot;</span>, mp.id, <span class="string">&quot; ostk=&quot;</span>, &amp;mp, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable signals during clone, so that the new thread starts</span></span><br><span class="line">	<span class="comment">// with signals disabled. It will enable them in minit.</span></span><br><span class="line">	<span class="keyword">var</span> oset sigset</span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ret &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: failed to create new OS thread (have &quot;</span>, mcount(), <span class="string">&quot; already; errno=&quot;</span>, -ret, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> ret == -_EAGAIN &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: may need to increase max user processes (ulimit -u)&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		throw(<span class="string">&quot;newosproc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="mg-解绑"><a class="markdownIt-Anchor" href="#mg-解绑"></a> <code>M/G</code> 解绑</h5>
<p>实际上就是指将当前 <code>g</code> 的 <code>m</code> 置空、将当前 <code>m</code> 的 <code>g</code> 置空，从而完成解绑，通过 <code>dropg</code> 完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dropg 移除 m 与当前 Goroutine m-&gt;curg（简称 gp ）之间的关联。</span></span><br><span class="line"><span class="comment">// 通常，调用方将 gp 的状态设置为非 _Grunning 后立即调用 dropg 完成工作。</span></span><br><span class="line"><span class="comment">// 调用方也有责任在 gp 将使用 ready 时重新启动时进行相关安排。</span></span><br><span class="line"><span class="comment">// 在调用 dropg 并安排 gp ready 好后，调用者可以做其他工作，但最终应该</span></span><br><span class="line"><span class="comment">// 调用 schedule 来重新启动此 m 上的 Goroutine 的调度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dropg</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line"></span><br><span class="line">  setMNoWB(&amp;_g_.m.curg.m, <span class="literal">nil</span>)</span><br><span class="line">  setGNoWB(&amp;_g_.m.curg, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setMNoWB 当使用 muintptr 不可行时，在没有 write barrier 下执行 *mp = new</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setMNoWB</span><span class="params">(mp **m, <span class="built_in">new</span> *m)</span></span> &#123;</span><br><span class="line">	(*muintptr)(unsafe.Pointer(mp)).set(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setGNoWB 当使用 guintptr 不可行时，在没有 write barrier 下执行 *gp = new</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//go:nowritebarrier</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setGNoWB</span><span class="params">(gp **g, <span class="built_in">new</span> *g)</span></span> &#123;</span><br><span class="line">	(*guintptr)(unsafe.Pointer(gp)).set(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个调度器循环可以以下面的一张图来描述：</p>
<p><img data-src="%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF.jpg" alt="" /></p>
<h4 id="系统监控"><a class="markdownIt-Anchor" href="#系统监控"></a> 系统监控</h4>
<p>在创建主goroutine的时候，也在系统栈上启动了 <code>sysmon</code>，是时候了解下它的作用了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> GOARCH != <span class="string">&quot;wasm&quot;</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line">        <span class="comment">// For runtime_syscall_doAllThreadsSyscall, we</span></span><br><span class="line">        <span class="comment">// register sysmon is not ready for the world to be</span></span><br><span class="line">        <span class="comment">// stopped.</span></span><br><span class="line">        atomic.Store(&amp;sched.sysmonStarting, <span class="number">1</span>)</span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        newm(sysmon, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统监控在独立的 <code>M</code> 上运行，不需要 <code>P</code>，所以不能出现写屏障：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lock(&amp;sched.lock)</span><br><span class="line">  sched.nmsys++</span><br><span class="line">  checkdead()</span><br><span class="line">  unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For syscall_runtime_doAllThreadsSyscall, sysmon is</span></span><br><span class="line">  <span class="comment">// sufficiently up to participate in fixups.</span></span><br><span class="line">  atomic.Store(&amp;sched.sysmonStarting, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  lasttrace := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">  idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">  delay := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// 每次启动先休眠 20us</span></span><br><span class="line">      delay = <span class="number">20</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// 1ms 后就翻倍休眠时间</span></span><br><span class="line">      delay *= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// 最大10ms</span></span><br><span class="line">      delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">    usleep(delay)</span><br><span class="line">    mDoFixup()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果启用了 schedtrace，sysmon 不应进入深度睡眠，以便它可以在正确的时间打印该信息。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果有任何活动的 P，它也不应该进入深度睡眠，这样它就可以从系统调用中重新获取 P，</span></span><br><span class="line">    <span class="comment">// 抢占长时间运行的 G，并在所有 P 长时间忙碌时轮询网络。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果某个P由于退出系统调用或者定时器到期而重新被激活，那么sysmon应该从深度睡眠中唤醒，</span></span><br><span class="line">    <span class="comment">// 以便它可以继续干自己的活。</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    <span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="type">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">      lock(&amp;sched.lock)</span><br><span class="line">      <span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="type">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">        syscallWake := <span class="literal">false</span></span><br><span class="line">        next, _ := timeSleepUntil()</span><br><span class="line">        <span class="keyword">if</span> next &gt; now &#123;</span><br><span class="line">          atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">          unlock(&amp;sched.lock)</span><br><span class="line">          <span class="comment">// Make wake-up period small enough</span></span><br><span class="line">          <span class="comment">// for the sampling to be correct.</span></span><br><span class="line">          sleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">          <span class="keyword">if</span> next-now &lt; sleep &#123;</span><br><span class="line">            sleep = next - now</span><br><span class="line">          &#125;</span><br><span class="line">          shouldRelax := sleep &gt;= osRelaxMinNS</span><br><span class="line">          <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">            osRelax(<span class="literal">true</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          syscallWake = notetsleep(&amp;sched.sysmonnote, sleep)</span><br><span class="line">          mDoFixup()</span><br><span class="line">          <span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">            osRelax(<span class="literal">false</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          lock(&amp;sched.lock)</span><br><span class="line">          atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">          noteclear(&amp;sched.sysmonnote)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> syscallWake &#123;</span><br><span class="line">          idle = <span class="number">0</span></span><br><span class="line">          delay = <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      unlock(&amp;sched.lock)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;sched.sysmonlock)</span><br><span class="line">    <span class="comment">// Update now in case we blocked on sysmonnote or spent a long time</span></span><br><span class="line">    <span class="comment">// blocked on schedlock or sysmonlock above.</span></span><br><span class="line">    now = nanotime()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger libc interceptors if needed</span></span><br><span class="line">    <span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">      asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果超过 10ms 没有 poll，则 poll 一下网络</span></span><br><span class="line">    lastpoll := <span class="type">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">      atomic.Cas64(&amp;sched.lastpoll, <span class="type">uint64</span>(lastpoll), <span class="type">uint64</span>(now))</span><br><span class="line">      list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">      <span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">        <span class="comment">// 需要在插入 g 列表前减少空闲锁住的 m 的数量（假装有一个正在运行）</span></span><br><span class="line">		<span class="comment">// 否则会导致这些情况：</span></span><br><span class="line">		<span class="comment">// injectglist 会绑定所有的 p，但是在它开始 M 运行 P 之前，另一个 M 从 syscall 返回，</span></span><br><span class="line">		<span class="comment">// 完成运行它的 G ，注意这时候没有 work 要做，且没有其他正在运行 M 的死锁报告。</span></span><br><span class="line">        incidlelocked(<span class="number">-1</span>)</span><br><span class="line">        injectglist(&amp;list)</span><br><span class="line">        incidlelocked(<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mDoFixup()</span><br><span class="line">    <span class="keyword">if</span> GOOS == <span class="string">&quot;netbsd&quot;</span> &#123;</span><br><span class="line">      <span class="comment">// netpoll is responsible for waiting for timer</span></span><br><span class="line">      <span class="comment">// expiration, so we typically don&#x27;t have to worry</span></span><br><span class="line">      <span class="comment">// about starting an M to service timers. (Note that</span></span><br><span class="line">      <span class="comment">// sleep for timeSleepUntil above simply ensures sysmon</span></span><br><span class="line">      <span class="comment">// starts running again when that timer expiration may</span></span><br><span class="line">      <span class="comment">// cause Go code to run again).</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// However, netbsd has a kernel bug that sometimes</span></span><br><span class="line">      <span class="comment">// misses netpollBreak wake-ups, which can lead to</span></span><br><span class="line">      <span class="comment">// unbounded delays servicing timers. If we detect this</span></span><br><span class="line">      <span class="comment">// overrun, then startm to get something to handle the</span></span><br><span class="line">      <span class="comment">// timer.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// See issue 42515 and</span></span><br><span class="line">      <span class="comment">// https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094.</span></span><br><span class="line">      <span class="keyword">if</span> next, _ := timeSleepUntil(); next &lt; now &#123;</span><br><span class="line">        startm(<span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;scavenge.sysmonWake) != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// Kick the scavenger awake if someone requested it.</span></span><br><span class="line">      wakeScavenger()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抢占在 syscall 中阻塞的 P、运行时间过长的 G</span></span><br><span class="line">    <span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">      idle = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      idle++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要强制触发 GC</span></span><br><span class="line">    <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">      lock(&amp;forcegc.lock)</span><br><span class="line">      forcegc.idle = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> list gList</span><br><span class="line">      list.push(forcegc.g)</span><br><span class="line">      injectglist(&amp;list)</span><br><span class="line">      unlock(&amp;forcegc.lock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="type">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">      lasttrace = now</span><br><span class="line">      schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.sysmonlock)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统监控在运行时扮演的角色无需多言， 因为使用的是运行时通知机制，在 Linux 上由 <code>Futex</code> 实现，不依赖调度器， 因此它自身通过 <code>newm</code> 在一个 <code>M</code> 上独立运行， 自身永远保持在一个循环内直到应用结束。休眠有好几种不同的休眠策略：</p>
<ul>
<li>至少休眠 <code>20us</code></li>
<li>如果抢占 <code>P</code> 和 <code>G</code> 失败次数超过50、且没有触发 GC，则说明很闲，翻倍休眠</li>
<li>如果休眠翻倍时间超过 <code>10ms</code>，保持休眠 <code>10ms</code> 不变</li>
<li>休眠结束后，先观察目前的系统状态，如果正在进行 GC，那么继续休眠。 这时的休眠会被设置超时。</li>
</ul>
<p>如果没有超时被唤醒，则说明 <code>GC</code> 已经结束，一切都很好，继续做本职工作。 如果超时，则无关 <code>GC</code>，必须开始进行本职善后：</p>
<ul>
<li>如果 <code>cgo</code> 调用被 <code>libc</code> 拦截，继续触发起调用</li>
<li>如果已经有 <code>10ms</code> 没有 <code>poll</code> 网络数据，则 <code>poll</code> 一下网络数据</li>
<li>抢占在系统调用中阻塞的 <code>P</code> 已经运行时间过长的 <code>G</code></li>
<li>检查是不是该触发 <code>GC</code> 了</li>
<li>如果距离上一次堆清理已经超过了两分半，则执行清理工作</li>
</ul>
<h4 id="线程管理"><a class="markdownIt-Anchor" href="#线程管理"></a> 线程管理</h4>
<p><code>Go</code>语言编程中，用户基本上不会涉及到线程的管理，都是由调度系统完成的，但仍然有一些与线程管理相关的接口。</p>
<h5 id="lockosthread"><a class="markdownIt-Anchor" href="#lockosthread"></a> <code>LockOSThread</code></h5>
<p>该方法在 runtime 包中分别提供了私有和公开方法，私有的方法整个运行时只有在 <code>runtime.main</code> 调用 <code>main.init</code> 、和 <code>cgo</code> 的 <code>C</code> 调用 <code>Go</code> 时候才会使用， 其中 <code>main.init</code> 其实也是为了 <code>cgo</code> 里 <code>Go</code> 调用某些 <code>C</code> 图形库时需要主线程支持才使用的。而用户态的公开方法则不同，还额外增加了一个模板线程的处理。</p>
<div class="tabs" id="lockosthread"><ul class="nav-tabs"><li class="tab active"><a href="#lockosthread-1">私有方法</a></li><li class="tab"><a href="#lockosthread-2">公有方法</a></li><li class="tab"><a href="#lockosthread-3">dolockOSThread</a></li></ul><div class="tab-content"><div class="tab-pane active" id="lockosthread-1"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">  getg().m.lockedInt++</span><br><span class="line">  dolockOSThread()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="lockosthread-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LockOSThread wires the calling goroutine to its current operating system thread.</span></span><br><span class="line"><span class="comment">// The calling goroutine will always execute in that thread,</span></span><br><span class="line"><span class="comment">// and no other goroutine will execute in it,</span></span><br><span class="line"><span class="comment">// until the calling goroutine has made as many calls to</span></span><br><span class="line"><span class="comment">// UnlockOSThread as to LockOSThread.</span></span><br><span class="line"><span class="comment">// If the calling goroutine exits without unlocking the thread,</span></span><br><span class="line"><span class="comment">// the thread will be terminated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All init functions are run on the startup thread. Calling LockOSThread</span></span><br><span class="line"><span class="comment">// from an init function will cause the main function to be invoked on</span></span><br><span class="line"><span class="comment">// that thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A goroutine should call LockOSThread before calling OS services or</span></span><br><span class="line"><span class="comment">// non-Go library functions that depend on per-thread state.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.Load(&amp;newmHandoff.haveTemplateThread) == <span class="number">0</span> &amp;&amp; GOOS != <span class="string">&quot;plan9&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果我们需要从锁定的线程启动一个新线程，我们需要模板线程。</span></span><br><span class="line">    <span class="comment">// 当我们处于一个已知良好的状态时，立即启动它。</span></span><br><span class="line">    startTemplateThread()</span><br><span class="line">  &#125;</span><br><span class="line">  _g_ := getg()</span><br><span class="line">  _g_.m.lockedExt++</span><br><span class="line">  <span class="keyword">if</span> _g_.m.lockedExt == <span class="number">0</span> &#123;</span><br><span class="line">    _g_.m.lockedExt--</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;LockOSThread nesting overflow&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  dolockOSThread()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="lockosthread-3"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dolockOSThread 在修改 m.locked 后由 LockOSThread 和 lockOSThread 调用。</span></span><br><span class="line"><span class="comment">// 在此调用期间不允许抢占，否则此函数中的 m 可能与调用者中的 m 不同。</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dolockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// no threads on wasm yet</span></span><br><span class="line">  &#125;</span><br><span class="line">  _g_ := getg()</span><br><span class="line">  _g_.m.lockedg.set(_g_)</span><br><span class="line">  _g_.lockedm.set(_g_.m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<h5 id="unlockosthread"><a class="markdownIt-Anchor" href="#unlockosthread"></a> <code>UnlockOSThread</code></h5>
<p>Unlock 的部分非常简单，减少计数，再实际 dounlock：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unlockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line">  <span class="keyword">if</span> _g_.m.lockedInt == <span class="number">0</span> &#123;</span><br><span class="line">    systemstack(badunlockosthread)</span><br><span class="line">  &#125;</span><br><span class="line">  _g_.m.lockedInt--</span><br><span class="line">  dounlockOSThread()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnlockOSThread undoes an earlier call to LockOSThread.</span></span><br><span class="line"><span class="comment">// If this drops the number of active LockOSThread calls on the</span></span><br><span class="line"><span class="comment">// calling goroutine to zero, it unwires the calling goroutine from</span></span><br><span class="line"><span class="comment">// its fixed operating system thread.</span></span><br><span class="line"><span class="comment">// If there are no active LockOSThread calls, this is a no-op.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Before calling UnlockOSThread, the caller must ensure that the OS</span></span><br><span class="line"><span class="comment">// thread is suitable for running other goroutines. If the caller made</span></span><br><span class="line"><span class="comment">// any permanent changes to the state of the thread that would affect</span></span><br><span class="line"><span class="comment">// other goroutines, it should not call this function and thus leave</span></span><br><span class="line"><span class="comment">// the goroutine locked to the OS thread until the goroutine (and</span></span><br><span class="line"><span class="comment">// hence the thread) exits.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnlockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _g_ := getg()</span><br><span class="line">  <span class="keyword">if</span> _g_.m.lockedExt == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  _g_.m.lockedExt--</span><br><span class="line">  dounlockOSThread()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dounlockOSThread</code> 只是简单的将 <code>lockedg</code> 和 <code>lockedm</code> 两个字段清零：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dounlockOSThread 在更新 m-&gt;locked 后由 UnlockOSThread 和 unlockOSThread 调用。</span></span><br><span class="line"><span class="comment">// 在此调用期间不允许抢占，否则此函数中的 m 可能与调用者中的 m 不同。</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dounlockOSThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> GOARCH == <span class="string">&quot;wasm&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// no threads on wasm yet</span></span><br><span class="line">	&#125;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedInt != <span class="number">0</span> || _g_.m.lockedExt != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	_g_.m.lockedg = <span class="number">0</span></span><br><span class="line">	_g_.lockedm = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3>
<ol>
<li><a target="_blank" rel="noopener" href="https://visualgdb.com/gdbreference/commands/">GDB 命令帮助文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codepng.app/">https://www.codepng.app/</a></li>
<li><a target="_blank" rel="noopener" href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/">欧神·并发调度</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="MichaelFu 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="MichaelFu 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>MichaelFu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/" title="【Golang】进程初始化和调度系统">https://blog.fudenglong.site/2021/12/19/Go/【Golang】进程的启动和初始化/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/15/Go/%E3%80%90Golang%E3%80%91Mutex-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="【Golang】Mutex 的实现原理">
                  <i class="fa fa-angle-left"></i> 【Golang】Mutex 的实现原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/05/UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/" rel="next" title="UML 统一建模语言">
                  UML 统一建模语言 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">辽ICP备15012817号-2 </a>
  </div>
  <div class="copyright">
    &copy; 2020 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MichaelFu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">465k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">28:11</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/gamelife1314" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/bookmark.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/search/local-search.min.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js"},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/tags/pdf.min.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"dark","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js"}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/tags/mermaid.min.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/fancybox.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/pace.min.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":false,"delay":true,"timeout":5000,"priority":true,"url":"https://blog.fudenglong.site/2021/12/19/Go/%E3%80%90Golang%E3%80%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/quicklink.min.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"gamelife1314/gamelife1314.github.io","issue_term":"title","theme":"github-light"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/comments/utterances.min.js"></script>

</body>
</html>
