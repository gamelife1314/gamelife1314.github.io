<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta name="google-site-verification" content="lk2gSYFP_NyLNFob-fFnt7fm-I_n1ZYws-WZll7mshg">
  <meta name="msvalidate.01" content="6Jdc01DjYOLguhS5">
  <meta name="baidu-site-verification" content="code-NR10G09zww">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7Ccursive:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/yellow/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.fudenglong.site","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":800},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/local-search.xml","localsearch":{"enable":true,"top_n_per_article":10,"unescape":false,"preload":true,"trigger":"auto"}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script>

    <meta name="description" content="汇编语言是最接近机器代码的人类可读语言，通过阅读汇编代码，我们可以了解到自己所编写的高级语言代码最终生成的指令都是什么，以便更好的掌握高级语言和了解计算机系统。Go 语言的汇编器基于 Plan9 汇编器，并且在此基础之上定义了一些创新。">
<meta property="og:type" content="article">
<meta property="og:title" content="【Golang】汇编语言">
<meta property="og:url" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="MichaelFu">
<meta property="og:description" content="汇编语言是最接近机器代码的人类可读语言，通过阅读汇编代码，我们可以了解到自己所编写的高级语言代码最终生成的指令都是什么，以便更好的掌握高级语言和了解计算机系统。Go 语言的汇编器基于 Plan9 汇编器，并且在此基础之上定义了一些创新。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/bg.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/registers.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/pushq_popq.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/stack-frame.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/jump-example-c.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/jump-example-asm.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/dlv_add_asm.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/gdb_add_asm.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/objdump_add_asm.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/compile-process.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/compile-allow-inline.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/compile-disable-inline.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/go-compile-ssa-optimize.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/go-compile-gen-ir-asm.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/go-compile-ssa-unoptimize.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/go-compile-gen-ir-unoptimize-asm.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/go-compile-obj-ir.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/pcallq-goasm-fp.png">
<meta property="og:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/pcallq-goasm-sp.png">
<meta property="article:published_time" content="2022-03-01T03:27:32.000Z">
<meta property="article:modified_time" content="2022-03-01T03:27:32.000Z">
<meta property="article:author" content="MichaelFu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/bg.png">


<link rel="canonical" href="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","path":"2022/03/01/Go/【Golang】汇编语言/","title":"【Golang】汇编语言"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>【Golang】汇编语言 | MichaelFu</title>
  







<script async src="/lib/fireworks.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MichaelFu</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好记性不如烂笔头</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-云-&nbsp;&nbsp;原-&nbsp;&nbsp;生"><a href="/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="section"><i class="fa fa-cloud fa-fw"></i>云 &nbsp;&nbsp;原 &nbsp;&nbsp;生</a></li><li class="menu-item menu-item-rust-编程"><a href="/Programming-Rust/" rel="section"><i class="fa fa-cat fa-fw"></i>Rust 编程</a></li><li class="menu-item menu-item-go-&nbsp;&nbsp;&nbsp;编程"><a href="/Programming-Go/" rel="section"><i class="fa fa-hippo fa-fw"></i>Go &nbsp;&nbsp;&nbsp;编程</a></li><li class="menu-item menu-item-前端知识"><a href="https://wshuhua.github.io/" rel="section" target="_blank"><i class="fa fa-sun fa-fw"></i>前端知识</a></li><li class="menu-item menu-item-leetcode-rust"><a href="/Leetcode-Rust/" rel="section"><i class="fa fa-book fa-fw"></i>Leetcode-Rust</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-64-%E6%B1%87%E7%BC%96"><span class="nav-number">1.</span> <span class="nav-text"> X86-64 汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.</span> <span class="nav-text"> 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text"> 数据格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.3.</span> <span class="nav-text"> 寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text"> 操作数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0"><span class="nav-number">1.4.1.</span> <span class="nav-text"> 立即数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-2"><span class="nav-number">1.4.2.</span> <span class="nav-text"> 寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text"> 内存引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-number">1.5.</span> <span class="nav-text"> 数据传送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88"><span class="nav-number">1.6.</span> <span class="nav-text"> 压栈和出栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.</span> <span class="nav-text"> 算数和逻辑操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80"><span class="nav-number">1.7.1.</span> <span class="nav-text"> 加载有效地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.2.</span> <span class="nav-text"> 一元操作和二元操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.3.</span> <span class="nav-text"> 移位操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.4.</span> <span class="nav-text"> 特殊的算数操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.8.</span> <span class="nav-text"> 函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6"><span class="nav-number">1.8.1.</span> <span class="nav-text"> 转移控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81-2"><span class="nav-number">1.8.2.</span> <span class="nav-text"> 数据传送</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC"><span class="nav-number">1.9.</span> <span class="nav-text"> 跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">1.9.1.</span> <span class="nav-text"> 条件码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">1.9.2.</span> <span class="nav-text"> 访问条件码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cmp-%E5%92%8C-test"><span class="nav-number">1.9.3.</span> <span class="nav-text"> CMP 和 TEST</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.4.</span> <span class="nav-text"> 跳转指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A7%BB%E5%8A%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.5.</span> <span class="nav-text"> 条件移动指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-%E6%B1%87%E7%BC%96"><span class="nav-number">2.</span> <span class="nav-text"> Go 汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.</span> <span class="nav-text"> 汇编示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text"> 编译过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">2.2.1.</span> <span class="nav-text"> 解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8Cast%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.2.</span> <span class="nav-text"> 类型检查和AST转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ssa-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">2.2.3.</span> <span class="nav-text"> SSA 代码生成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.4.</span> <span class="nav-text"> 生成机器代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">2.3.</span> <span class="nav-text"> 汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">2.3.1.</span> <span class="nav-text"> 常量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-3"><span class="nav-number">2.3.2.</span> <span class="nav-text"> 寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#sb"><span class="nav-number">2.3.2.1.</span> <span class="nav-text"> SB</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#fp"><span class="nav-number">2.3.2.2.</span> <span class="nav-text"> FP</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sp"><span class="nav-number">2.3.2.3.</span> <span class="nav-text"> SP</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.3.3.</span> <span class="nav-text"> 常量与结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="nav-number">2.3.4.</span> <span class="nav-text"> 运行时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-number">2.3.5.</span> <span class="nav-text"> 架构相关信息</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#32-bit-intel-386"><span class="nav-number">2.3.5.1.</span> <span class="nav-text"> 32-bit Intel 386</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#64-bit-intel-386-amd64"><span class="nav-number">2.3.5.2.</span> <span class="nav-text"> 64-bit Intel 386 (AMD64)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text"> 参考链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MichaelFu"
      src="/avatar.jpeg">
  <p class="site-author-name" itemprop="name">MichaelFu</p>
  <div class="site-description" itemprop="description">实践能让记忆更深刻</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gamelife1314" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gamelife1314" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:michael.fudenglong@qq.com" title="E-Mail → mailto:michael.fudenglong@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://www.rust-lang.org/zh-CN/" title="https:&#x2F;&#x2F;www.rust-lang.org&#x2F;zh-CN&#x2F;" rel="noopener" target="_blank">Rust</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://go.dev/" title="https:&#x2F;&#x2F;go.dev&#x2F;" rel="noopener" target="_blank">Golang</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.python.org/" title="https:&#x2F;&#x2F;www.python.org&#x2F;" rel="noopener" target="_blank">Python</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://doc.rust-lang.org/cargo/index.html" title="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;index.html" rel="noopener" target="_blank">Cargo</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://gist.github.com/rxaviers/7360908" title="https:&#x2F;&#x2F;gist.github.com&#x2F;rxaviers&#x2F;7360908" rel="noopener" target="_blank">Emoji</a>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpeg">
      <meta itemprop="name" content="MichaelFu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MichaelFu">
      <meta itemprop="description" content="实践能让记忆更深刻">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="【Golang】汇编语言 | MichaelFu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Golang】汇编语言
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 11:27:32" itemprop="dateCreated datePublished" datetime="2022-03-01T11:27:32+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:04</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>汇编语言是最接近机器代码的人类可读语言，通过阅读汇编代码，我们可以了解到自己所编写的高级语言代码最终生成的指令都是什么，以便更好的掌握高级语言和了解计算机系统。Go 语言的汇编器基于 <a target="_blank" rel="noopener" href="https://9p.io/sys/doc/asm.html">Plan9 汇编器</a>，并且在此基础之上定义了一些创新。</p>
<img data-src="/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/bg.png" class="" title="汇编代码">
<span id="more"></span>
<h3 id="x86-64-汇编"><a class="markdownIt-Anchor" href="#x86-64-汇编"></a> X86-64 汇编</h3>
<p>在学习 Go 语言的汇编语法之前，先大致了解下基于 <code>X86-64</code> 系列处理器的汇编语言，<code>X86-64</code> 是最常见的 Intel 处理器系列，普遍应用于桌面电脑和服务器中，本节的内容大都总结于《深入理解计算机系统》这本书。</p>
<h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4>
<p>演示一段简单的C代码生成的汇编指令。假设我们写了一个 C 语言代码文件，<code>mstore.c</code>，它包含如下的函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>, <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> *dest)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下的指令生成汇编代码，汇编代码会保存在 <code>mstore.s</code> 中：</p>
<blockquote>
<p>gcc -Og -S mstore.c</p>
</blockquote>
<p>其内容位：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-335906 ~]# cat mstore.s</span><br><span class="line">	.file	&quot;mstore.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	multstore</span><br><span class="line">	.type	multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 3, -16</span><br><span class="line">	movq	%rdx, %rbx</span><br><span class="line">	call	mult2</span><br><span class="line">	movq	%rax, (%rbx)</span><br><span class="line">	popq	%rbx</span><br><span class="line">	.cfi_def_cfa_offset 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	multstore, .-multstore</span><br><span class="line">	.ident	&quot;GCC: (GNU) 8.5.0 20210514 (Red Hat 8.5.0-4)&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<p>我们也可以使用 <code>-c</code> 命令行选项，编译并汇编该段代码，这会生成一个二进制文件 <code>mstore.o</code>，我们可以使用 <code>GDB</code> 调试工具查看 <code>multstore</code> 生成的汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-335906 ~]# gdb mstore.o</span><br><span class="line">...</span><br><span class="line">(gdb) x/14xb multstore</span><br><span class="line">0x0 &lt;multstore&gt;:	0x53	0x48	0x89	0xd3	0xe8	0x00	0x00	0x00</span><br><span class="line">0x8 &lt;multstore+8&gt;:	0x00	0x48	0x89	0x03	0x5b	0xc3</span><br><span class="line">(gdb) disa</span><br><span class="line">disable      disassemble</span><br><span class="line">(gdb) disassemble multstore</span><br><span class="line">Dump of assembler code for function multstore:</span><br><span class="line">   0x0000000000000000 &lt;+0&gt;:	push   %rbx</span><br><span class="line">   0x0000000000000001 &lt;+1&gt;:	mov    %rdx,%rbx</span><br><span class="line">   0x0000000000000004 &lt;+4&gt;:	callq  0x9 &lt;multstore+9&gt;</span><br><span class="line">   0x0000000000000009 &lt;+9&gt;:	mov    %rax,(%rbx)</span><br><span class="line">   0x000000000000000c &lt;+12&gt;:	pop    %rbx</span><br><span class="line">   0x000000000000000d &lt;+13&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>或者使用反汇编工具将二进制文件翻译成汇编代码格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-335906 ~]# objdump -d mstore.o</span><br><span class="line"></span><br><span class="line">mstore.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;multstore&gt;:</span><br><span class="line">   0:	53                   	push   %rbx</span><br><span class="line">   1:	48 89 d3             	mov    %rdx,%rbx</span><br><span class="line">   4:	e8 00 00 00 00       	callq  9 &lt;multstore+0x9&gt;</span><br><span class="line">   9:	48 89 03             	mov    %rax,(%rbx)</span><br><span class="line">   c:	5b                   	pop    %rbx</span><br><span class="line">   d:	c3                   	retq</span><br><span class="line">[root@ecs-335906 ~]#</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>multstore</code> 函数编译成二进制文件之后，占据了 <code>14</code> 字节，反汇编工具将它们分成了 <code>6</code> 组，每组 <code>1~5</code> 个字节不等，每组都是一条指令，右边是等价的汇编语言。其中一些关于机器代码和它的反汇编表示的特性值得注意：</p>
<ul>
<li>x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的子节数少，而那些不太常用或操作数较多的指令所需字节数较多。</li>
<li>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 <code>pushg %rbx</code> 是以字节值 <code>53</code> 开头的。</li>
<li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</li>
<li>反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的 <code>q</code>。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 <code>call</code> 和 <code>ret</code> 指令添加了 <code>q</code> 后缀，同样，省略这些后缀也没有问题。</li>
</ul>
<p>以 <code>.</code> 开头的都是指导汇编器和链接器工作的伪指令，去除它们之后，我们可以看到 <code>multstore</code> 函数转换成汇编语言之后的指令位：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	movq	%rdx, %rbx</span><br><span class="line">	call	mult2</span><br><span class="line">	movq	%rax, (%rbx)</span><br><span class="line">	popq	%rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>我们常用的 <code>GCC</code>，<code>OBJDUMP</code> 生成的汇编代码是 <code>ATT</code>（根据 <code>AT&amp;T</code> 命名，它是运营贝尔实验室多年的公司） 格式，有些 <code>Microsoft</code> 生成的格式是 <code>Intel</code> 的，这两种格式在许多方面有所不同，例如，我们可以用下面的指令生成 <code>multstore</code> 函数的 Intel 格式的汇编代码：</p>
<blockquote>
<p>gcc -Og -S -masm=intel mstore.c</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">	push	rbx</span><br><span class="line">	mov	rbx, rdx</span><br><span class="line">	call	mult2</span><br><span class="line">	mov	QWORD PTR [rbx], rax</span><br><span class="line">	pop	rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h4 id="数据格式"><a class="markdownIt-Anchor" href="#数据格式"></a> 数据格式</h4>
<p>大多数GCC生成的汇编代码都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种：<code>movb</code>（传送字节），<code>movw</code>（传送字），<code>movl</code>（传送双字） 以及 <code>movq</code>（传送四字）。汇编代使用后缀 <code>l</code>表示4字节整数和8字节双精度浮点数，这不会产生歧义，因为浮点数使用的一组完全不同的指令和寄存器。</p>
<p>Intel 派系中，“字（Word）”表示16位数据类型，因此，32位称之为 “双字”，64位称之为 “四字”。下表给出C语言数据类型和对应的 X86-64 表示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">C声明</th>
<th style="text-align:center">Intel 数据类型</th>
<th style="text-align:center">汇编代码后缀</th>
<th style="text-align:center">大小（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">字节</td>
<td style="text-align:center">b</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">字</td>
<td style="text-align:center">w</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">双字</td>
<td style="text-align:center">l</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">四字</td>
<td style="text-align:center">q</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">char*</td>
<td style="text-align:center">四字</td>
<td style="text-align:center">q</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">单精度</td>
<td style="text-align:center">s</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">双精度</td>
<td style="text-align:center">l</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<h4 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h4>
<p>一个 X86-64 的CPU包含一组16个存储64位值得通用目的寄存器，这些寄存器可以用来存储整数数据和指针。名称都是以 <code>%r</code> 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集烟花而来的。最初 8086 CPU 有8个16位的寄存器，即 <code>%ax ~ %sp</code>，每个寄存器都有特殊的用途。扩展到 IA32架构时，这些寄存器也扩展成32位的，标号从 <code>%eax ~ %esp</code>。扩展到 X86-64 之后，原来的8个寄存器扩展成64位，标号从 <code>%rax ~ %rsp</code>，除此之外，还增加了8个新的寄存器，它们的标号是按照新的命名规则制定的：从 <code>%r8 ~ %r15</code>。</p>
<p>在常见的程序里，不同的寄存器扮演着不同的角色，其中最特别的是栈指针：<code>%rsp</code>，用来指明运行时栈的结束为止，约定的用途如下：</p>
<p><img data-src="registers.png" alt="所有16个寄存器的低位部分都可以作为字节，字（16位），双字（32位），四字（64位）来访问" /></p>
<p>有很多指令能用于复制生成1字节，2字节，4字节和8字节的值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩余的字节会被按照以下两条规则处理：</p>
<ul>
<li>生成1字节和2字节数字的指令，会保持剩下的字节不变；</li>
<li>生成4字节数字的指令，会把高位4字节置为0；</li>
</ul>
<h4 id="操作数"><a class="markdownIt-Anchor" href="#操作数"></a> 操作数</h4>
<p>大多数指令有一个或者多个操作数（operand），指示处执行一个操作中要使用的源数据值，以及放置结果的目标位置。X86-64 支持多种数据格式，源数据可以是常数值，或者从寄存器或者内存中读出，而结果呢可以放在寄存器或者内存中，因此各种不同的操作数可以分为三种类型：<code>立即数</code>，<code>寄存器</code>， <code>内存引用</code>。</p>
<h5 id="立即数"><a class="markdownIt-Anchor" href="#立即数"></a> 立即数</h5>
<p>在ATT密码格式中，立即数的表示是 <code>$</code> 后面跟一个用标准C表示法的表示的整数。比如 <code>%-577</code> 或者 <code>$0x1F</code>。不同的指令允许的立即数范围不同，汇编器会自动选择最紧凑的方式进行数值编码。</p>
<h5 id="寄存器-2"><a class="markdownIt-Anchor" href="#寄存器-2"></a> 寄存器</h5>
<p>寄存器表示寄存器中的内容，所有16个寄存器中的1字节，2字节，4字节或者8字节中一个作为操作数，这些字节数分别对应于8位，16位，32位或者64位。我们用表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">r_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示任意寄存器 <code>a</code>，用引用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[r_a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 表示它的值，这是将寄存器看成一个数组 <code>R</code>，用寄存器标识符作为索引。</p>
<h5 id="内存引用"><a class="markdownIt-Anchor" href="#内存引用"></a> 内存引用</h5>
<p>内存引用根据计算出来的地址（通常称为有效地址）访问某个内存位置。通常情况下，我们将内存看成一个大的字节数组，因此用符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>b</mi></msub><mo stretchy="false">[</mo><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M_b[Addr]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 表示对存储在内存中从地址 <code>Addr</code> 开始的 <code>b</code> 个字节值的引用，为了方便，通常省去下标 <code>b</code>，最常用的内存引用表示形式是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(r_b,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> ，这里的引用有四个组成部分：</p>
<ul>
<li><code>Imm</code>：立即数偏移；</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">r_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：基址寄存器，必须是64位寄存器；</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：变址寄存器，必须是64位寄存器；</li>
<li><code>s</code>：比例因子，必须是 <code>1</code>，<code>2</code>，<code>4</code>，或者 <code>8</code>，编译器根据源代码中数组的类型来确定比例因子，<code>char</code> 类型是 <code>1</code>，<code>int</code> 类型是 <code>4</code>，<code>double</code> 类型是8。</li>
</ul>
<p>有效地址被计算为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">Imm + R[r_b] + R[r_i] · s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span></span></span></span>，引用数组元素时，会用到通用模式，其他形式都是这种通用形式的特殊情况，省略了某些部分而已，有关计算机寻址方式可以查看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%BA%E5%9D%80%E5%8A%A0%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/6686487">基址加变址寻址方式-百度百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F">寻址模式-维基百科</a></li>
</ul>
<p>下面的表格给出常用的操作数类型机器含义：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">操作数值</th>
<th style="text-align:center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">立即数</td>
<td style="text-align:center"><code>$Imm</code></td>
<td style="text-align:center"><code>Imm</code></td>
<td style="text-align:center">立即数值</td>
</tr>
<tr>
<td style="text-align:center">寄存器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">r_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[r_a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">寄存器寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><code>Imm</code></td>
<td style="text-align:center"><code>M[Imm]</code></td>
<td style="text-align:center">绝对寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>a</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[R[r_a]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">间接寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(r_b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm+R[r_b]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">(基址+偏移量)寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_b,r_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[R[r_b]+R[r_i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(r_b,r_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm+R[r_b]+R[r_i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[R[r_i]·s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">比例变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm+R[r_i]·s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">比例变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r_b,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[R[r_b]+R[r_i]·s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">比例变址寻址</td>
</tr>
<tr>
<td style="text-align:center">存储器</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Imm(r_b,r_i,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>b</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo stretchy="false">[</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo separator="true">⋅</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[Imm+R[r_b]+R[r_i]·s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">]</span></span></span></span></td>
<td style="text-align:center">比例变址寻址</td>
</tr>
</tbody>
</table>
<h4 id="数据传送"><a class="markdownIt-Anchor" href="#数据传送"></a> 数据传送</h4>
<p>汇编代码中最常见的就是数据传送指令，经常需要将数据从一个位置复制到另外一个位置。操作数表示的通用性使得一条简单的数据传送指令能够许多机器中好几条不同的指令才能完成的功能。最简单的数据传送指令是 <code>MOV</code> 类，这些指令把数据从源位置复制到目的位置，不能做任何变化。<code>MOV</code> 类指令主要由四条指令组成：<code>movb</code>，<code>movw</code>，<code>movl</code> 以及 <code>movq</code>，这些指令执行同样的操作，区别在于它们传送的数据大小不同，分别是：<code>1</code>，<code>2</code>，<code>4</code> 和 <code>8</code> 字节。</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>MOV S, D</code></td>
<td style="text-align:center"><code>D&lt;-S</code></td>
<td style="text-align:center">传送</td>
</tr>
<tr>
<td style="text-align:center"><code>movb</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">传送字节</td>
</tr>
<tr>
<td style="text-align:center"><code>movw</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">传送字</td>
</tr>
<tr>
<td style="text-align:center"><code>movl</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">传送双字</td>
</tr>
<tr>
<td style="text-align:center"><code>movq</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">传送四字</td>
</tr>
<tr>
<td style="text-align:center"><code>movabsq I, R</code></td>
<td style="text-align:center"><code>R&lt;-I</code></td>
<td style="text-align:center">传送绝对四字</td>
</tr>
</tbody>
</table>
<p>源操作数指定的是一个立即数，存储在寄存器或者内存中，目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。<strong><code>X86-64</code> 添加了一条限制，传送指令两个操作数不能都指向内存地址</strong>，所以要在内存之间传送数据，就需要两次操作。</p>
<p>大多数情况下， <code>MOV</code> 指令大多数情况下，只会更新目的操作数指定的那些寄存器或者内存位置，根据指令最后一个字符指定的大小，例如每次 <code>movb</code> 指令只会更新一个字节，<code>movw</code> 更新双字16个字。有个例外就是 <strong><code>movl</code> 指令以寄存器位目的地址时，它会把寄存器的高4字节置为0（X86-64惯例）</strong>。</p>
<p>下面是几个数据传送的指令：</p>
<ul>
<li><code>movl $0x4050, %eax</code>       立即数-&gt;寄存器，4字节</li>
<li><code>movw %bp, %sp</code>              寄存器-&gt;寄存器，2字节</li>
<li><code>movb (%rdi, %rcx), %al</code>       内  存-&gt;寄存器，1字节</li>
<li><code>movb ($-17, (%rsp))</code>      立即数-&gt;内  存，1字节</li>
<li><code>movq %rax, -12(%rbp)</code>   寄存器-&gt;内  存，8字节</li>
</ul>
<p>除此之外，<strong><code>movq</code> 指令只能以表示32位补码数字的立即数位源操作数，然后把这个值符号扩展到64位的值，放到目的位置</strong>。而 <strong><code>movabsq</code> 指令能够以任何64位立即数值作为源操作数，并且只能以寄存器作为目的</strong>。</p>
<p>还有两类寄存器，在移动数据时能够对符号位进行扩展，<strong><code>MOVZ</code> 类中的指令把目的剩余字节填充位0，而 <code>MOVS</code> 类中的指令通过符号扩展来填充，把源操作数的最高位进行赋值</strong>，这两类指令最后两个字符都是大小指示符，第一个字符指定源操作数的大小，第二个指定目的大小。</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>MOVZ S, R</code></td>
<td style="text-align:center"><code>D&lt;-S（零扩展）</code></td>
<td style="text-align:center">以零扩展进行传送</td>
</tr>
<tr>
<td style="text-align:center"><code>movzbw</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了零扩展的字节传送到字</td>
</tr>
<tr>
<td style="text-align:center"><code>movzbl</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了零扩展的字节传送到双字</td>
</tr>
<tr>
<td style="text-align:center"><code>movzwl</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了零扩展的字传送到双字</td>
</tr>
<tr>
<td style="text-align:center"><code>movzbq</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了零扩展的字节传送到四字</td>
</tr>
<tr>
<td style="text-align:center"><code>movzwq</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了零扩展的字传送到四字</td>
</tr>
</tbody>
</table>
<p>或者</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>MOVZ S, R</code></td>
<td style="text-align:center"><code>D&lt;-S（符号扩展）</code></td>
<td style="text-align:center">以传送符号扩展的字节</td>
</tr>
<tr>
<td style="text-align:center"><code>movsbw</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了符号扩展的字节传送到字</td>
</tr>
<tr>
<td style="text-align:center"><code>movsbl</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了符号扩展的字节传送到双字</td>
</tr>
<tr>
<td style="text-align:center"><code>movswl</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了符号扩展的字传送到双字</td>
</tr>
<tr>
<td style="text-align:center"><code>movsbq</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了符号扩展的字节传送到四字</td>
</tr>
<tr>
<td style="text-align:center"><code>movswq</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">将做了符号扩展的字传送到四字</td>
</tr>
</tbody>
</table>
<p>下面是一段 <code>C</code> 代码的示例生成的汇编代码：</p>
<div class="tabs" id="数据传送指令示例"><ul class="nav-tabs"><li class="tab active"><a href="#数据传送指令示例-1">源代码</a></li><li class="tab"><a href="#数据传送指令示例-2">汇编代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="数据传送指令示例-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span><span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span> &#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="数据传送指令示例-2"><p>根据约定，参数 <code>xp</code> 和 <code>y</code> 分别存储在寄存器 <code>%rdi</code> 和 <code>%rsi</code> 中，返回值存储在 <code>%rax</code> 中。先将 <code>xp</code> 中的值放到 <code>%rax</code> 中返回，然后将 <code>y</code> 的值放到  <code>xp</code> 指向的内存地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exchange:</span><br><span class="line">	movq	(%rdi), %rax</span><br><span class="line">	movq	%rsi, (%rdi)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure></div></div></div>
<h4 id="压栈和出栈"><a class="markdownIt-Anchor" href="#压栈和出栈"></a> 压栈和出栈</h4>
<p>栈在处理函数（过程）调用中起到至关重要的作用，栈是一种数据结构，可以添加或者删除，遵循<strong>后进先出</strong>的原则。通过 <code>push</code> 操作将数据压入栈中，通过 <code>pop</code> 操作删除数据，因此，弹出的值永远是最近被压入而且仍然在栈中的值。</p>
<p>在实现上，栈可以以数组的形式实现，总是从数据的一段插入和删除元素，这一端称为 <strong>栈顶</strong>。在 <code>x86-64</code> 中，程序栈放在内存中的某个区域，栈是从高地址向低地址增长，栈顶元素的地址是所有栈元素地址中最低的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>pushq S</code></td>
<td style="text-align:center"><code>R[%rsp]&lt;-R[%rsp]-8</code>；<code>M[R[%rsp]] &lt;- S</code></td>
<td style="text-align:center">将四字压入栈</td>
</tr>
<tr>
<td style="text-align:center"><code>popq  D</code></td>
<td style="text-align:center"><code>D&lt;-M[R[%rsp]]</code>；<code>R[%rsp]&lt;-R[%rsp]+8</code></td>
<td style="text-align:center">将四字弹出栈</td>
</tr>
</tbody>
</table>
<p><code>pushq</code> 的功能是将数据压入到栈上，而 <code>popq</code> 指令是弹出数据，这些指令都只有一个操作数，压入的数据和弹出的数据目的地。</p>
<p><code>pushq</code> 在压栈之前，首先要将栈指针减8，然后将数据写到栈顶位置，因此，指令 <code>pushq %rbp</code>的行为等于下面两条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq %8, %rsp</span><br><span class="line">movq %rbp, (%rsp)</span><br></pre></td></tr></table></figure>
<p>由于压栈和出栈操作太频繁，所以用一个单独的指令实现，减小最终生成的二进制文件体积。因为，上面两条指令在机器代码中占用8个字节，而 pushq 只需要1个字节。</p>
<p><img data-src="pushq_popq.png" alt="压栈和出栈" /></p>
<p><code>x86-64</code> 中，栈的方向是向低地址增长，所以压栈是减小栈指针（<code>%rsp</code>）的值，并将数据存储到内存中，而出栈是从内存中读取数据，并增加栈的指针。</p>
<h4 id="算数和逻辑操作"><a class="markdownIt-Anchor" href="#算数和逻辑操作"></a> 算数和逻辑操作</h4>
<p>下面的表格列出了一些整数和逻辑操作，大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种。指令类 <code>ADD</code> 由四条加法指令组成：<code>addb</code>，<code>addw</code>，<code>addl</code> 和 <code>addq</code>，下面给出的每个指令都有对这四种不同大小数据的变种（除 <code>leaq</code> 之外），这些指令被分成四组：加载有效地址，一元操作，二元操作和移位。</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>leaq S, D</code></td>
<td style="text-align:center"><code>D&lt;-&amp;S</code></td>
<td style="text-align:center">加载有效地址</td>
</tr>
<tr>
<td style="text-align:center"><code>INC D</code></td>
<td style="text-align:center"><code>D &lt;-  D+1</code></td>
<td style="text-align:center">加1</td>
</tr>
<tr>
<td style="text-align:center"><code>DEC D</code></td>
<td style="text-align:center"><code>D &lt;-  D-1</code></td>
<td style="text-align:center">减1</td>
</tr>
<tr>
<td style="text-align:center"><code>NEG D</code></td>
<td style="text-align:center"><code>D &lt;-  - D</code></td>
<td style="text-align:center">取负</td>
</tr>
<tr>
<td style="text-align:center"><code>NOT D</code></td>
<td style="text-align:center"><code>D &lt;-  ~ D</code></td>
<td style="text-align:center">取补</td>
</tr>
<tr>
<td style="text-align:center"><code>ADD S, D</code></td>
<td style="text-align:center"><code>D &lt;-  D + S</code></td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center"><code>SUB S, D</code></td>
<td style="text-align:center"><code>D &lt;-  D - S</code></td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center"><code>IMUL S, D</code></td>
<td style="text-align:center"><code>D &lt;- D * S</code></td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center"><code>XOR  S, D</code></td>
<td style="text-align:center"><code>D &lt;- D ^ S</code></td>
<td style="text-align:center">异或</td>
</tr>
<tr>
<td style="text-align:center"><code>OR   S, D</code></td>
<td style="text-align:center">`D &lt;- D</td>
<td style="text-align:center">S`</td>
</tr>
<tr>
<td style="text-align:center"><code>AND  S, D</code></td>
<td style="text-align:center"><code>D &lt;- D &amp; S</code></td>
<td style="text-align:center">与</td>
</tr>
<tr>
<td style="text-align:center"><code>SAL  k, D</code></td>
<td style="text-align:center"><code>D &lt;- D &lt;&lt; k</code></td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center"><code>SHL  k, D</code></td>
<td style="text-align:center"><code>D &lt;- D &lt;&lt; k</code></td>
<td style="text-align:center">左移（等同于 <code>SAL</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>SAR  k, D</code></td>
<td style="text-align:center"><code>D &lt;- D &gt;&gt;</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.47833099999999995em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <code>k</code></td>
<td style="text-align:center">算数右移</td>
</tr>
<tr>
<td style="text-align:center"><code>SHR  k, D</code></td>
<td style="text-align:center"><code>D &lt;- D &gt;&gt;</code><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.47833099999999995em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <code>k</code></td>
<td style="text-align:center">逻辑右移</td>
</tr>
</tbody>
</table>
<h5 id="加载有效地址"><a class="markdownIt-Anchor" href="#加载有效地址"></a> 加载有效地址</h5>
<p><code>leaq</code>（加载有效地址）指令实际上是 <code>movq</code> 指令的变形，它的指令形式是从内存读取数据到寄存器，但实际上根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但是该指令实际上并不从指定位置读取数据，而是将有效地址写入到目的操作数。</p>
<p>除此之外，它还可以简单的描述普通的算数操作，例如，如果寄存器 <code>%rdx</code> 的值为 <code>x</code>，那么指令 <code>leaq 7(%rdx, %rdx, 4), %rax</code> 将设置寄存器 <code>%rax</code> 的值为 <code>7 + (x + x * 4) = 5x + 7</code>，编译器经常会使用 <code>leaq</code> 的一些灵活用法，看下面的示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span> &#123;</span><br><span class="line">    <span class="type">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>%rdi = x, %rsi = y, %rdx = z, %rax = t</code>，编译之后的汇编代码位：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scale:</span><br><span class="line">	leaq	(%rdi,%rsi,4), %rax      // x + 4 * y</span><br><span class="line">	leaq	(%rdx,%rdx,2), %rcx      // z + 2 * z = 3z</span><br><span class="line">	leaq	0(,%rcx,4), %rdx         // (x + 4 * y) + 4 * (3 * z) = x + 4 * y + 12 * z</span><br><span class="line">	addq	%rdx, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h5 id="一元操作和二元操作"><a class="markdownIt-Anchor" href="#一元操作和二元操作"></a> 一元操作和二元操作</h5>
<p>一元操作，及时源又是目的，这个操作数可以是寄存器，也可以是内存位置。例如，<code>incq (%rsp)</code> 会使栈顶的8字节元素加1，这种语法类似于C语言的<code>++</code> 和 <code>--</code> 从操作。</p>
<p>二元操作中，第二个操作数既是源又是目的，类似于C语言中的 <code>-=</code>，<code>+=</code>，<code>*=</code> 运算操作符。例如，<code>subq %rax, %rdx</code> 是将寄存器 <code>%rdx</code> 减去 <code>%rax</code> 的结果保存在 <code>%rdx</code> 中，第一个操作数可以使立即数，寄存器或是任意内存位置，第二个操作数可以是寄存器或是内存位置。</p>
<h5 id="移位操作"><a class="markdownIt-Anchor" href="#移位操作"></a> 移位操作</h5>
<p>移位操作，先给出移位量，然后第二项给出的是要移位的数，可以进行算数和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器 <code>%cl</code> 中（这些指令很特别，只允许以这个特定的寄存器作为操作数）。原则上来说，1字节的移位量使得移位量的编码范围可以达到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>255</mn></mrow><annotation encoding="application/x-tex">2^8-1=255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span></span></span></span>。</p>
<p><code>x86-64</code> 中，移位操作对 <code>w</code> 位长的数据值进行操作，移位量由 <code>%cl</code> 寄存器的低 <code>m</code> 位决定，这里 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">2^m=w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>，高位会被忽略。所以，当寄存器 <code>%cl</code> 的十六进制位 <code>%0xFF</code> 时，指令 <code>salb</code> 会移 <code>7</code> 位，<code>salw</code> 会移 <code>15</code> 位，<code>sall</code> 会移 <code>31</code> 位，<code>salq</code> 会移 <code>63</code> 位。</p>
<p>左移指令有两个名字：<code>SAL</code> 和 <code>SHL</code>，两者的效果是一样的，都是讲右边填上0。右移指令不同， <code>SAR</code> 执行算数移位（填上符号位），而 <code>SHR</code> 执行逻辑移位（填上0）。移位操作的目的操作数可以是一个寄存器或者一个内存位置。</p>
<h5 id="特殊的算数操作"><a class="markdownIt-Anchor" href="#特殊的算数操作"></a> 特殊的算数操作</h5>
<p>两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。 <code>x86-64</code> 指令集对128位（16字节）数的操作提供有限的支持。延续字（2字节），双字（四字节），四字（8字节）的命令管理，Intel 将16字节的数称为八字（oct word）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>imulq S</code></td>
<td style="text-align:center"><code>R[%rdx]: R[%rax] &lt;- s * R[%rax]</code></td>
<td style="text-align:center">有符号全乘法</td>
</tr>
<tr>
<td style="text-align:center"><code>mulq S</code></td>
<td style="text-align:center"><code>R[%rdx]: R[%rax] &lt;- s * R[%rax]</code></td>
<td style="text-align:center">无符号全乘法</td>
</tr>
<tr>
<td style="text-align:center"><code>cqto S</code></td>
<td style="text-align:center"><code>R[%rdx]: R[%rax] &lt;- 符号扩展（R[%rax]）</code></td>
<td style="text-align:center">转换为八字</td>
</tr>
<tr>
<td style="text-align:center"><code>idivq S</code></td>
<td style="text-align:center"><code>R[%rdx]&lt;-R[%rdx] &lt;- R[%rax] mod S; R[%rax]&lt;-R[%rdx] &lt;- R[%rax] ÷ S; </code></td>
<td style="text-align:center">有符号除法</td>
</tr>
<tr>
<td style="text-align:center"><code>divq S</code></td>
<td style="text-align:center"><code>R[%rdx]&lt;-R[%rdx] &lt;- R[%rax] mod S; R[%rax]&lt;-R[%rdx] &lt;- R[%rax] ÷ S; </code></td>
<td style="text-align:center">无符号除法</td>
</tr>
</tbody>
</table>
<p><code>imulq</code> 指令有两种不同的形式，双操作数和单操作数，单操作数时，计算两个64位值得全128位乘积，位补码乘法。而 <code>mulq</code> 是无符号乘法。这两个指令都要求一个参数必须在寄存器 <code>%rax</code> 中，而另一个作为指令的源操作数给出。然后乘积的高64位放在 <code>%rdx</code> 中，低64位放在 <code>%rax</code> 中。</p>
<p>看下面的代码示例，使用文件 <code>inttypes.h</code> 的定义，它是标准C扩展的一部分，只不过，它没有提供128位的值，因此只能依赖GCC提供的对128位的支持，声明一个新的类型 <code>uint128_t</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int128 <span class="type">uint128_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">store_uprod</span><span class="params">(<span class="type">uint128_t</span> *dest, <span class="type">uint64_t</span> x, <span class="type">uint64_t</span> y)</span> &#123;</span><br><span class="line">    *dest = x * (<span class="type">uint128_t</span>) y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc -Og -S imulq.c</p>
</blockquote>
<p>生成的汇编代码如下，<code>dest in %rdi, x in %rsi, y in %rdx</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">store_uprod:</span><br><span class="line">	movq	%rsi, %rax    // 先将 x 移动到 %rax 寄存器中</span><br><span class="line">	mulq	%rdx          // 然后将 %rax（x）和 %rdx（y）相乘</span><br><span class="line">	movq	%rax, (%rdi)  // 结果的低64位存储在 dest 中</span><br><span class="line">	movq	%rdx, 8(%rdi) // 结果的高64位存储 dest 中</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<h4 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h4>
<p>函数（过程）是软件设计中一种重要的抽象，它提供了一种封装代码的方式，用一组指定的参数和可选的一个或者多个返回值实现某种功能，然后又可以在程序的不同位置调用这个函数。</p>
<p>假设函数 <code>P</code> 调用函数 <code>Q</code>，要在机器级实现 <code>P</code> 调用 <code>Q</code>，然后从 <code>Q</code> 返回，我们必须考虑以下动作：</p>
<ul>
<li>
<p><code>传递控制</code>：在进入函数 <code>Q</code> 的时候，程序计数器必须被设置位 <code>Q</code> 的起始地址，然后再返回时，必须将程序计数器设置为 <code>P</code> 调用 <code>Q</code> 后面的那条指令地址；</p>
</li>
<li>
<p><code>传递数据</code>：<code>P</code> 必须能向 <code>Q</code> 提供一个或者多个参数， <code>Q</code> 必须能够向 <code>P</code> 返回一个值；</p>
</li>
<li>
<p><code>内存释放和分配</code>：在调用开始时，<code>Q</code> 可能需要位局部变量分配空间，而在返回时，需要释放这些空间；</p>
</li>
</ul>
<p><code>C</code> 语言中，函数调用机制的实现得在于应用栈这个先进后出内存管理原则。在 <code>P</code> 调用 <code>Q</code> 的过程中，当 <code>Q</code> 在执行时，<code>P</code> 以及向上追溯到 <code>P</code> 的调用链的函数，都是暂时挂起的。当 <code>Q</code> 运行时，它只需要为局部变量分配新的存储空间，当它返回时，任何为它分配的局部存储空间都可以释放。所以，程序可以用栈来管理它的函数调用所需要的存储空间，栈和程序寄存器存放这<code>传递控制</code> 和 <code>传递数据</code>，以及分配内存所需要的信息。当 <code>P</code> 调用 <code>Q</code>，控制和数据信息添加到栈尾，当 <code>P</code> 返回时，这些信息会被释放掉。</p>
<p>在 <code>x86-64</code> 中，栈是向低地址方向增长的，栈指针 <code>%rsp</code> 指向栈顶元素（低地址），可以使用 <code>pushq</code> 或者 <code>popq</code> 指令将数据存入栈上或者从栈上弹出。将栈指针减小一个适当的量可以为没有指定初始值得数据在栈上分配空间，类似，可以通过增加指针来释放空间。</p>
<p>当 <code>x86-64</code> 函数调用需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这部分内存空间就称为 <strong>栈帧</strong>。</p>
<p>如下图所示，当前正在执行的函数的帧总是在栈顶，当 <code>P</code> 调用 <code>Q</code> 时，会把返回地址压入栈中，指明当 <code>Q</code> 返回时，要从 <code>P</code> 程序的那个位置开始执行，我们这个返回地址当做<code>P</code>的栈帧的一部分，因为它存放的是与 <code>P</code> 相关的状态。<code>Q</code> 的代码会扩展当前栈的边界，分配它的栈帧所需要的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的函数设置参数。通过寄存器，<code>P</code> 可以传递最多6个整数值（也就是指针和整数），但是如果Q需要更多的参数，那么 <code>P</code> 可以在调用之前在自己的栈帧里存储好这些参数。</p>
<p><img data-src="stack-frame.png" alt="栈结构" /></p>
<h5 id="转移控制"><a class="markdownIt-Anchor" href="#转移控制"></a> 转移控制</h5>
<p>将控制从函数 <code>P</code> 转移到函数 <code>Q</code>，只需要简单地把程序计数器（<code>PC</code>）设置为 <code>Q</code> 的起始地址。不过稍后从 <code>Q</code> 返回的时候，处理器必须记录好它需要从 <code>P</code> 的哪个位置继续执行。在 X86-64 系统中，这个信息是用指令 <code>call Q</code> 调用函数 <code>Q</code> 来记录的，该指令会把紧跟在 <code>call</code> 指令后面那条指令的地址压入栈中，并且把 <code>PC</code> 计数器设置为 <code>Q</code> 的起始地址，压入栈中的下一条指令的地址被称作<strong>返回地址</strong>。而对应的 <code>ret</code> 指令会从栈中弹出返回地址，并且把 <code>PC</code> 更新。</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>call Label</code></td>
<td style="text-align:center">函数调用</td>
</tr>
<tr>
<td style="text-align:center"><code>call *Operand</code></td>
<td style="text-align:center">函数调用</td>
</tr>
<tr>
<td style="text-align:center"><code>ret</code></td>
<td style="text-align:center">从函数调用中返回</td>
</tr>
</tbody>
</table>
<h5 id="数据传送-2"><a class="markdownIt-Anchor" href="#数据传送-2"></a> 数据传送</h5>
<p>当函数调用时，除了要将控制传递给他并且在函数调用结束时再传递回来，函数调用还需要传递参数和返回值。x86-64 中，大部分的数据传递是通过寄存器实现的。当函数 <code>P</code> 调用 <code>Q</code> 时，<code>P</code> 的代码首先必须把参数复制到合适的寄存器中，而当 <code>Q</code> 返回时，<code>P</code> 的代码可以通过寄存器 <code>%rax</code> 而获取 <code>Q</code> 的返回值。</p>
<p>x86-64 中，可以通过寄存器最多传递6个整形（即整数和指针参数）。寄存器的使用也是有特殊顺序的，根据参数在参数列表中的顺序为他们分配寄存器，寄存器使用的名字取决于要传递的数据类型的大小。可以通过 64 位寄存器适当的部分访问小于 <code>64</code> 位的参数，例如，如果第一个参数是 <code>32</code> 位的，可以通过寄存器 <code>%edi</code> 来访问它。</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作数大小</th>
<th style="text-align:center">参数1</th>
<th style="text-align:center">参数2</th>
<th style="text-align:center">参数3</th>
<th style="text-align:center">参数4</th>
<th style="text-align:center">参数5</th>
<th style="text-align:center">参数6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>64</code></td>
<td style="text-align:center"><code>%rdi</code></td>
<td style="text-align:center"><code>%rsi</code></td>
<td style="text-align:center"><code>rdx</code></td>
<td style="text-align:center"><code>%rcx</code></td>
<td style="text-align:center"><code>%r8</code></td>
<td style="text-align:center"><code>%r9</code></td>
</tr>
<tr>
<td style="text-align:center"><code>32</code></td>
<td style="text-align:center"><code>%edi</code></td>
<td style="text-align:center"><code>%esi</code></td>
<td style="text-align:center"><code>%edx</code></td>
<td style="text-align:center"><code>%ecx</code></td>
<td style="text-align:center"><code>%r8d</code></td>
<td style="text-align:center"><code>%r9d</code></td>
</tr>
<tr>
<td style="text-align:center"><code>16</code></td>
<td style="text-align:center"><code>%di</code></td>
<td style="text-align:center"><code>%si</code></td>
<td style="text-align:center"><code>%dx</code></td>
<td style="text-align:center"><code>%cx</code></td>
<td style="text-align:center"><code>%r8w</code></td>
<td style="text-align:center"><code>%r9w</code></td>
</tr>
<tr>
<td style="text-align:center"><code>8</code></td>
<td style="text-align:center"><code>%dil</code></td>
<td style="text-align:center"><code>%sil</code></td>
<td style="text-align:center"><code>%dl</code></td>
<td style="text-align:center"><code>%cl</code></td>
<td style="text-align:center"><code>%r8b</code></td>
<td style="text-align:center"><code>%r9b</code></td>
</tr>
</tbody>
</table>
<p>如果一个函数有大雨6个整形参数，超出6个的部分就要通过栈来传递。假设函数 <code>P</code> 调用 <code>Q</code>，有 <code>n</code> 个整形参数，且 <code>n &gt; 6</code>，那么 <code>P</code> 的代码分配的栈帧必须能够容纳 <code>7</code> 到 <code>n</code> 好参数的存储空间。也就是说，要把参数 <code>1~6</code> 复制到对应的寄存器，把参数 <code>7~n</code> 放到栈上，而参数 <code>7</code> 位于栈顶。通过栈传递参数的时候，所有的数据大小都向 <code>8</code> 的倍数对齐。参数放置到对应的位置以后，程序就可以执行 <code>call</code> 指令将控制转移到函数 <code>Q</code> 了，函数 <code>Q</code> 可以通过寄存器访问参数，有必要的话也可以通过栈访问。相应地，如果函数 <code>Q</code> 调用了某个有超过<code>6</code>个参数的函数，它也需要在自己的栈帧中为超过<code>6</code>个部分的参数分配空间，对应于栈帧结构图中的参数构造区。</p>
<div class="tabs" id="数据传送代码示例"><ul class="nav-tabs"><li class="tab active"><a href="#数据传送代码示例-1">数据传送源代码示例</a></li><li class="tab"><a href="#数据传送代码示例-2">数据传送汇编代码解释</a></li></ul><div class="tab-content"><div class="tab-pane active" id="数据传送代码示例-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">q</span><span class="params">(<span class="type">char</span> a, <span class="type">long</span> b, <span class="type">char</span> c, <span class="type">long</span> d, <span class="type">char</span> e, <span class="type">long</span> f, <span class="type">char</span> g, <span class="type">long</span> h)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c + d + e + f + g + h; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">p</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">long</span> result;</span><br><span class="line">	result = q(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="数据传送代码示例-2"><p>使用下面的命令输出汇编代码：</p>
<blockquote>
<p>gcc -Og -S test.c</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">q:</span><br><span class="line">	movsbq	%dil, %rdi  	// 将第1个参数进行符号扩展，放到64为寄存器%rdi中</span><br><span class="line">	addq	%rdi, %rsi  	// 将第1个参数和第2个参数相加放到%rsi中</span><br><span class="line">	movsbq	%dl, %rdx   	// 将第3个参数进行符号位扩展</span><br><span class="line">	addq	%rsi, %rdx  	// 将前2个参数的和与第3个参数相加放到 %rdx 中</span><br><span class="line">	addq	%rdx, %rcx  	// 将前3个参数的和与第4个参数相加放到 %rcx 中</span><br><span class="line">	movsbq	%r8b, %r8   	// 将第5个参数进行符号位扩展</span><br><span class="line">	addq	%r8, %rcx   	// 将前4个参数的和与第5个参数相加放到 %rcx 中</span><br><span class="line">	addq	%r9, %rcx   	// 将前5个参数的和与第6个参数相加放到 %rcx 中</span><br><span class="line">	movsbq	8(%rsp), %rax   // 将第7个参数进行符号位扩展放到 %rax 中</span><br><span class="line">	addq	%rcx, %rax      // 将前6个参数的和与第7个参数相加放到 %rax 中</span><br><span class="line">	addq	16(%rsp), %rax  // 将前7个参数的和与第8个参数相加放到 %rax 中返回，返回值存储在 %rax 中</span><br><span class="line">	ret</span><br><span class="line">p:</span><br><span class="line">	subq	$8, %rsp   // 为变量 long 分配空间</span><br><span class="line">	pushq	$4         // 第8个参数4先放到栈上，通过pushq实现，其实是：subq %8, %rsp; movq $4, (%rsp)</span><br><span class="line">	pushq	$100       // 第7个参数&#x27;d&#x27;放到栈上，通过pushq实现</span><br><span class="line">	movl	$3, %r9d   // 第6个参数</span><br><span class="line">	movl	$99, %r8d  // 第5个参数</span><br><span class="line">	movl	$2, %ecx   // 第4个参数</span><br><span class="line">	movl	$98, %edx  // 第3个参数</span><br><span class="line">	movl	$1, %esi   // 第2个参数</span><br><span class="line">	movl	$97, %edi  // 第1个参数</span><br><span class="line">	call	q</span><br><span class="line">	movq	%rax, %rsi</span><br><span class="line">	movl	$.LC0, %edi</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	call	printf</span><br><span class="line">	addq	$24, %rsp</span><br><span class="line">	ret</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<h4 id="跳转"><a class="markdownIt-Anchor" href="#跳转"></a> 跳转</h4>
<p>程序开发中，除了顺序执行之外，还有就是分支语句，循环语句以及条件语句，根据数据测试的结果来决定执行哪些代码，这就涉及到程序的跳转执行。C语言中的语句和机器代码中的指令都是严格按照它们在程序中出现的次序顺序执行。可以使用 <code>jump</code> 指令改变一组机器代码指令的执行顺序，<code>jump</code> 指令指定控制应该被传递到程序的某个其他部分。</p>
<h5 id="条件码"><a class="markdownIt-Anchor" href="#条件码"></a> 条件码</h5>
<p>除了整数寄存器，CPU还维护者一组单个bit位的<strong>条件码寄存器</strong>，它们描述了最新的算数或者逻辑操作的属性，可以检测这些寄存器来执行条件分支指令，最常用的条件码有：</p>
<ul>
<li>
<p><code>CF</code>：进位标志。最近的操作使最高位产生了进位，可以用来检查无符号操作的溢出。</p>
<p>例如，对于下面的代码，由于最高位会发生进位操作，相加的结果发生溢出，此时进位标志 <code>CF</code> 会被置为1。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">255</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> t = a + b;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>ZF</code>：零标志。最近的操作得出的结果位0；</p>
<p>例如，对于下面的代码，当 <code>a + b</code> 的结果等于0时，此时零标志 <code>ZF</code> 会被置为1：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> t = a + b;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>SF</code>：符号标志。最近的操作得出的结果位负数；</p>
</li>
<li>
<p><code>OF</code>：溢出标志。最近的操作导致一个补码溢出，正溢出或者负溢出。</p>
</li>
</ul>
<p>用一个统一的例子来说明条件码寄存器的变化，我们可以用一个 <code>ADD</code> 指令完成类似于 <code>C</code> 中 <code>t = a + b</code> 的操作，然后根据下面的表达式对条件码寄存器赋值：</p>
<ul>
<li><code>CF</code>：当 <code>(unsigned) t &lt; (unsignd) a</code> 时，设置 <code>CF</code> 为1，表示存在无符号溢出；</li>
<li><code>ZF</code>：当 <code>t == 0</code> 时，设置 <code>ZF</code> 为1，表示最近计算结果位0；</li>
<li><code>SF</code>：当 <code>t &lt; 0</code> 时，设置 <code>SF</code> 为1，表示最近计算结果位负数；</li>
<li><code>OF</code>：当 <code>(a &lt;0==b&lt;0) &amp;&amp; (t &lt; 0 ! =a&lt;0)</code> 设置 <code>OF</code> 为1；</li>
</ul>
<p>条件码寄存器的值是有ALU在执行算数和运算指令时写入的，下面的这些算数运算指令都会改变条件码寄存器的内容：</p>
<ol>
<li>
<p>一元操作指令：</p>
<ul>
<li><code>INC D</code></li>
<li><code>DEC D</code></li>
<li><code>NEG D</code></li>
<li><code>NOT D</code></li>
</ul>
</li>
<li>
<p>二元操作指令：</p>
<ul>
<li><code>ADD S, D</code></li>
<li><code>SUB S, D</code></li>
<li><code>IMUL S, D</code></li>
<li><code>OR S, D</code></li>
<li><code>XOR S, D</code></li>
<li><code>AND S, D</code></li>
</ul>
</li>
<li>
<p>移位操作指令</p>
<ul>
<li><code>SAL k, D</code></li>
<li><code>SHL k, D</code></li>
<li><code>SAR k, D</code></li>
<li><code>SHR k, D</code></li>
</ul>
</li>
</ol>
<h5 id="访问条件码"><a class="markdownIt-Anchor" href="#访问条件码"></a> 访问条件码</h5>
<p>条件码同行不会被直接读取，常用的使用方法有三种：</p>
<ol>
<li>可以根据条件码的某种组合将1个字节设置位0后者1；</li>
<li>可以条件跳转到程序的某个其他的部分；</li>
<li>可以有条件地传送数据；</li>
</ol>
<p>对于方法一，我们有一类 <code>SET</code> 指令，它们之间区别是它们考虑的条件码组合是什么，这些指令的不同后缀表明了它们所考虑的条件码组合而不是操作数的大小。例如：</p>
<ul>
<li><code>sete</code> 表示相等时设置（<code>set when equal</code>）</li>
<li><code>setl</code> 表示小于时设置（<code>set when less</code>）</li>
<li><code>setb</code> 表示低于时设置（<code>set when below</code>）</li>
<li><code>setg</code> 表示大于时设置（<code>set when greater</code>）</li>
<li><code>setnle</code> 表示不下于等于时设置，等同于 <code>setg</code></li>
</ul>
<p>所有 <code>SET</code> 类的指令的列表由下表给出：</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">同义名</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">设置条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>sete D</code></td>
<td style="text-align:center"><code>setz</code></td>
<td style="text-align:center"><code>D&lt;-ZF</code></td>
<td style="text-align:center">相等/零</td>
</tr>
<tr>
<td style="text-align:center"><code>setne D</code></td>
<td style="text-align:center"><code>setnz</code></td>
<td style="text-align:center"><code>D&lt;-~ZF</code></td>
<td style="text-align:center">不等/非零</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>sets D</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>D&lt;-SF</code></td>
<td style="text-align:center">负数</td>
</tr>
<tr>
<td style="text-align:center"><code>setns D</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>D&lt;-~SF</code></td>
<td style="text-align:center">非负数</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>setg D</code></td>
<td style="text-align:center"><code>setnle</code></td>
<td style="text-align:center"><code>D&lt;-~(SF^OF) &amp; ~ZF</code></td>
<td style="text-align:center">大于（有符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>setge D</code></td>
<td style="text-align:center"><code>setnl</code></td>
<td style="text-align:center"><code>D&lt;-~(SF^OF)</code></td>
<td style="text-align:center">大于等于（有符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>setl D</code></td>
<td style="text-align:center"><code>setnge</code></td>
<td style="text-align:center"><code>D&lt;-SF^OF</code></td>
<td style="text-align:center">小于（有符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>setle D</code></td>
<td style="text-align:center"><code>setng</code></td>
<td style="text-align:center">`D&lt;-(SF^OF)</td>
<td style="text-align:center">ZF`</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>seta</code></td>
<td style="text-align:center"><code>setnbe</code></td>
<td style="text-align:center"><code>D&lt;-~CF &amp; ~ZF</code></td>
<td style="text-align:center">超过（无符号&gt;）</td>
</tr>
<tr>
<td style="text-align:center"><code>setae</code></td>
<td style="text-align:center"><code>setnb</code></td>
<td style="text-align:center"><code>D&lt;-~CF</code></td>
<td style="text-align:center">超过或者相等（无符号&gt;=）</td>
</tr>
<tr>
<td style="text-align:center"><code>setb</code></td>
<td style="text-align:center"><code>setnae</code></td>
<td style="text-align:center"><code>D&lt;-CF</code></td>
<td style="text-align:center">低于（无符号&lt;）</td>
</tr>
<tr>
<td style="text-align:center"><code>setbe</code></td>
<td style="text-align:center"><code>setna</code></td>
<td style="text-align:center">`D&lt;-CF</td>
<td style="text-align:center">ZF`</td>
</tr>
</tbody>
</table>
<h5 id="cmp-和-test"><a class="markdownIt-Anchor" href="#cmp-和-test"></a> CMP 和 TEST</h5>
<p><code>CMP S1, S2</code> 指令会根据 <code>S2-S1</code> 之差来设置条件码寄存器，除了只设置条件码寄存器而不更新目的寄存器之外，和 <code>SUB</code> 是一样的。</p>
<p><code>TEST S1, S2</code> 指令会根据 <code>S1 &amp; S2</code> 来设置条件码寄存器，除了只设置条件码寄存器而不更新目的寄存器之外，和 <code>AND</code> 是一样的。</p>
<ol>
<li>示例1，对于下面的代码，我们目的是 <code>a==b</code> 相等返回1，不相等返回0</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a == b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的汇编程序如下，参数 <code>a</code> 会被放在 <code>%rdi</code> 中，参数 <code>b</code> 会被放在 <code>%rsi</code> 中，那么 <code>cmpq	%rsi, %rdi</code> 就会执行 <code>a - b</code>，决定是否将 <code>ZF</code> 条件码寄存器设置为 <code>1</code>，否则是 <code>0</code>。最终 <code>sete</code> 指令将 <code>ZF</code> 指令的值放到 <code>%al</code> 寄存器，并由 <code>movzbl</code> 进行零扩展。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">comp:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	sete	%al</span><br><span class="line">	movzbl	%al, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>示例1，对于下面的代码，我们目的是 <code>a &lt; b</code> 相等返回1，不相等返回0</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的汇编程序如下，读取条件码寄存器的指令由之前的 <code>sete</code> 变成了现在的 <code>setl</code>，含义是如果 <code>a&lt;b</code>，就将 <code>al</code> 设置为1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">comp:</span><br><span class="line">	cmpq	%rsi, %rdi</span><br><span class="line">	setl	%al</span><br><span class="line">	movzbl	%al, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p><code>setl</code> 指令的结果实际上是由 <code>SF ^ OF</code> 计算得出，因为是有符号数相减我们需要考虑溢出的情况，单独考虑 <code>SF</code> 标志无法得出正确的结论：</p>
<ul>
<li><code>a &lt; b</code>，那么 <code>t &lt; 0</code>，所以 <code>SF = 1，OF = 0</code>，结果 <code>SF ^ OF = 1</code>；</li>
<li><code>a &gt; b</code>，那么 <code>t &gt; 0</code>，所以 <code>SF = 0, OF = 0</code>，结果 <code>SF ^ OF = 0</code>；</li>
<li><code>a &lt; b</code>，例如 <code>a = -2, b = 127</code>，但是 <code>a - b = 127 &gt; 0</code> ，所以 <code>SF = 0，OF = 1</code>，结果 <code>SF ^ OF = 1</code>；</li>
<li><code>a &gt; b</code>，例如 <code>a = 1, b = -128</code>，但是 <code>a - b = -127 &lt; 0</code>，所以 <code>SF = 1，OF = 1</code>，结果 <code>SF ^ OF = 0</code></li>
</ul>
<h5 id="跳转指令"><a class="markdownIt-Anchor" href="#跳转指令"></a> 跳转指令</h5>
<p>正常执行情况下，指令会按照它们出现的顺序一条一条的执行，跳转指令会导致执行切换到程序的一个全新的位置，在汇编代码中，这些跳转的目的地通常用一个标号标明，我们看下面的示例：</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="jump-example-c.png" alt="C代码" /></div><div class="group-picture-column"><img data-src="jump-example-asm.png" alt="汇编代码" /></div></div></div>
<p>其中，<code>jle .L2</code> 指令表示如果 <code>a &lt;= b</code> 则跳转到 <code>.L2</code> 处继续执行，它是根据 <code>(SF ^ OF) | ZF</code> 条件指令的组合的结果进行跳转。还有一种无条件跳转指令 <code>jmp</code>，它可以是直接跳转，即跳转目标时作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或者内存位置中读出的。汇编语言中，直接跳转时给出一个标号作为跳转目标的，例如上面中的 <code>.L2</code>。间接跳转的写法是 <code>*</code>后面跟一个操作数指示符。例如：</p>
<ul>
<li><code>jmp *%rax</code> 用寄存器 <code>%rax</code> 的值作为跳转目标</li>
<li><code>jmp *(%rax)</code> 从寄存器 <code>%rax</code> 代表的内存地址读出跳转目标</li>
</ul>
<p>以下列出常用的跳转指令列表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">同义名</th>
<th style="text-align:center">跳转条件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>jmp Label</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">直接跳转</td>
</tr>
<tr>
<td style="text-align:center"><code>jmp *Oprand*</code></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">间接跳转</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>je Label</code></td>
<td style="text-align:center"><code>jz</code></td>
<td style="text-align:center"><code>ZF</code></td>
<td style="text-align:center">相等/零</td>
</tr>
<tr>
<td style="text-align:center"><code>jne Label</code></td>
<td style="text-align:center"><code>jnz</code></td>
<td style="text-align:center"><code>~ZF</code></td>
<td style="text-align:center">不相等/非零</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>js Label</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>SF</code></td>
<td style="text-align:center">负数</td>
</tr>
<tr>
<td style="text-align:center"><code>jns Label</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>~SF</code></td>
<td style="text-align:center">非负数</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>jg Label</code></td>
<td style="text-align:center"><code>jnle</code></td>
<td style="text-align:center"><code>~(SF^OF) &amp; ~ZF</code></td>
<td style="text-align:center">大于（有符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>jge Label</code></td>
<td style="text-align:center"><code>jnl</code></td>
<td style="text-align:center"><code>~(SF^OF)</code></td>
<td style="text-align:center">大于等于（有符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>jl Label</code></td>
<td style="text-align:center"><code>jnge</code></td>
<td style="text-align:center"><code>(SF^OF)</code></td>
<td style="text-align:center">小于（有符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>jle Label</code></td>
<td style="text-align:center"><code>jng</code></td>
<td style="text-align:center">`(SF^OF)</td>
<td style="text-align:center">ZF`</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>ja Label</code></td>
<td style="text-align:center"><code>jnbe</code></td>
<td style="text-align:center"><code>~CF &amp; ~ZF</code></td>
<td style="text-align:center">超过（无符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>jae Label</code></td>
<td style="text-align:center"><code>jnb</code></td>
<td style="text-align:center"><code>~CF</code></td>
<td style="text-align:center">超过或者相等（无符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>jb Label</code></td>
<td style="text-align:center"><code>jnae</code></td>
<td style="text-align:center"><code>CF</code></td>
<td style="text-align:center">低于（无符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>jbe Label</code></td>
<td style="text-align:center"><code>jna</code></td>
<td style="text-align:center">`CF</td>
<td style="text-align:center">ZF`</td>
</tr>
</tbody>
</table>
<h5 id="条件移动指令"><a class="markdownIt-Anchor" href="#条件移动指令"></a> 条件移动指令</h5>
<p>跳转指令会运用到CPU的分支预测功能，如果预测失败会带来较大的性能损耗，如果我们对上面的 <code>absi</code> 代码使用编译器优化 <code>gcc -O1 -S source.c</code>，就会得到下面的汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absi:</span><br><span class="line">	movl	%edi, %edx</span><br><span class="line">	subl	%esi, %edx // 计算 a-b 放到 %edx</span><br><span class="line">	movl	%esi, %eax</span><br><span class="line">	subl	%edi, %eax // 计算 b-a 放到 %eax</span><br><span class="line">	cmpq	%rsi, %rdi // 计算 a-b，更新 SF，OF 以及 ZF 条件码</span><br><span class="line">	cmovg	%edx, %eax // 根据 ~(SF ^ OF) &amp; ~ZF 判断是否a&gt;b，决定是否将 %edx 中的值放到 %eax 返回</span><br><span class="line"> 	ret</span><br></pre></td></tr></table></figure>
<p>可以看到的是这里没有了跳转指令，而是使用了 <code>cmovg</code> 指令，按照寄存器的使用规则，参数 <code>a</code> 是在 <code>%edi</code> 中，参数 <code>b</code> 是在 <code>%esi</code> 中，返回值会放在 <code>%eax</code> 中返回，更多的条件移动指令如下表所示，理解下面的描述一般情况下结合之前的 cmp 指令更容易理解：</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">同义名</th>
<th style="text-align:center">传送条件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>cmove S,R</code></td>
<td style="text-align:center"><code>comvz</code></td>
<td style="text-align:center"><code>ZF</code></td>
<td style="text-align:center">相等/零</td>
</tr>
<tr>
<td style="text-align:center"><code>cmovne S,R</code></td>
<td style="text-align:center"><code>comvnz</code></td>
<td style="text-align:center"><code>~ZF</code></td>
<td style="text-align:center">不相等/非零</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>cmovs S,R</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>SF</code></td>
<td style="text-align:center">负数</td>
</tr>
<tr>
<td style="text-align:center"><code>cmovns S,R</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>~SF</code></td>
<td style="text-align:center">非负数</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>cmovg S,R</code></td>
<td style="text-align:center"><code>cmovnle</code></td>
<td style="text-align:center"><code>~(SF ^ OF) &amp; ~ZF</code></td>
<td style="text-align:center">大于（有符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>cmovge S,R</code></td>
<td style="text-align:center"><code>cmovnl</code></td>
<td style="text-align:center"><code>~(SF ^ OF)</code></td>
<td style="text-align:center">大于等于（有符号&gt;=）</td>
</tr>
<tr>
<td style="text-align:center"><code>cmovl S,R</code></td>
<td style="text-align:center"><code>cmovnge</code></td>
<td style="text-align:center"><code>SF ^ OF</code></td>
<td style="text-align:center">小于（有符号&lt;）</td>
</tr>
<tr>
<td style="text-align:center"><code>cmovle S,R</code></td>
<td style="text-align:center"><code>cmovng</code></td>
<td style="text-align:center">`(SF ^ OF)</td>
<td style="text-align:center">ZF`</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>cmova S,R</code></td>
<td style="text-align:center"><code>cmovnbe</code></td>
<td style="text-align:center"><code>~CF &amp; ~ZF</code></td>
<td style="text-align:center">超过（无符号）</td>
</tr>
<tr>
<td style="text-align:center"><code>cmovae S,R</code></td>
<td style="text-align:center"><code>cmovnb</code></td>
<td style="text-align:center"><code>~CF</code></td>
<td style="text-align:center">超过或相等（无符号&gt;=）</td>
</tr>
<tr>
<td style="text-align:center"><code>cmovb S,R</code></td>
<td style="text-align:center"><code>cmovnae</code></td>
<td style="text-align:center"><code>CF</code></td>
<td style="text-align:center">低于（无符号&lt;）</td>
</tr>
<tr>
<td style="text-align:center"><code>cmovbe S,R</code></td>
<td style="text-align:center"><code>cmovna</code></td>
<td style="text-align:center">`CF</td>
<td style="text-align:center">ZF`</td>
</tr>
</tbody>
</table>
<h3 id="go-汇编"><a class="markdownIt-Anchor" href="#go-汇编"></a> Go 汇编</h3>
<p>众所周知，Go 汇编器基于 <a target="_blank" rel="noopener" href="https://9p.io/wiki/plan9/plan_9_wiki/"><code>plan9 汇编</code></a>。那什么是 <code>plan9</code> 呢？<code>plan9</code> 来自于贝尔实验室的第九号计划，是一种概念操作系统， 基于现代化思想重新设计操作系统，目标是实现 UNIX 最初的承诺：一切皆文件。Plan 9的特色功能有：将所有本地和远程资源以文件形式组织的9P协议，union mounts，改进的进程文件系统以及本地的Unicode支持。在Plan 9中，所有的系统接口（如网络和用户界面接口），都是作为文件系统的一部分呈现，而不像其他操作系统上一样拥有自己独立的接口。</p>
<p>Go语言采用 plan9 系统的汇编部分原因是开发者都是同一批人，Go 编译器输出的汇编其是一种抽象，并没有映射到实际的硬件， Go 汇编器会将这个伪汇编翻译成目标硬件的机器语言。拥有这样一个中间层的最大优势在于它更容易适应新的架构，更多详细的可以看 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=KINIAgRpkDA">GopherCon 2016: Rob Pike - The Design of the Go Assembler</a>。关于 Go 汇编最重要的一点是 Go 汇编不直接对应于目标硬件这一事实，有些与硬件直接相关，但有些则没有。就像当我们类似 <code>MOV</code> 指令时，工具链位该操作实际生成的可能根本不是移动指令，可能是清除指令或加载指令等，或者他可能与具有该名称的机器指令完全对应。Go汇编作为连接器的输入，在生成机器码的时候才转换成对应平台相关的指令。</p>
<h4 id="汇编示例"><a class="markdownIt-Anchor" href="#汇编示例"></a> 汇编示例</h4>
<p>Go 的汇编程序是一种解析该半抽象指令集的描述并将其转换为要输入到链接器的指令的方法，我们来看以下面一段简单的 <code>Go</code> 代码被Go编译器转换成 <code>Go汇编</code> 是什么样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环境信息如下：</p>
<blockquote>
<p>go version go1.17.8 linux/amd64<br />
Linux ecs-335906 4.18.0-348.7.1.el8_5.x86_64 #1 SMP Wed Dec 22 13:25:12 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</p>
</blockquote>
<p>我们可以使用下面的不同的命令查看 <code>Go汇编代码</code> 和 <code>目标平台汇编代码</code>，对比发现 <code>Go汇编</code> 中存在很多的伪指令。</p>
<div class="tabs" id="go汇编示例"><ul class="nav-tabs"><li class="tab active"><a href="#go汇编示例-1">Go汇编</a></li><li class="tab"><a href="#go汇编示例-2">目标机器汇编</a></li></ul><div class="tab-content"><div class="tab-pane active" id="go汇编示例-1"><p>使用命令：<code>go tool compile -S add.go</code>，这将生成的 <code>GO</code> 表示的汇编，或者可以使用命令 <code>go build -gcflags=&quot;-S&quot; add.go</code> 生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.add STEXT nosplit size=4 args=0x10 locals=0x0 funcid=0x0</span><br><span class="line">	0x0000 00000 (add.go:4)	TEXT	&quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-16</span><br><span class="line">	0x0000 00000 (add.go:4)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (add.go:4)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0000 00000 (add.go:4)	FUNCDATA	$5, &quot;&quot;.add.arginfo1(SB)</span><br><span class="line">	0x0000 00000 (add.go:5)	ADDQ	BX, AX</span><br><span class="line">	0x0003 00003 (add.go:5)	RET</span><br></pre></td></tr></table></figure>
<p>如果我们已经生成可执行文件，我们还可以通过 <code>GO</code> 提供的反汇编工具查看 <code>Go汇编</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-335906 add]# go tool objdump -s main.add add</span><br><span class="line">TEXT main.add(SB) /root/workdir/add/add.go</span><br><span class="line">  add.go:5		0x4553e0		4801d8			ADDQ BX, AX</span><br><span class="line">  add.go:5		0x4553e3		c3			RET</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="go汇编示例-2"><p>在生成对应平台的二进制文件之后，我们通过调试工具查看 <code>add</code> 函数的汇编代码。第一种方式我们可以通过 <a target="_blank" rel="noopener" href="https://github.com/go-delve/delve"><code>dlv</code></a> ：</p>
<p><img data-src="dlv_add_asm.png" alt="" /></p>
<p>或者通过 <code>gdb</code>：</p>
<p><img data-src="gdb_add_asm.png" alt="" /></p>
<p>或者通过反汇编工具 <code>objdump</code>：</p>
<blockquote>
<p>objdump -d add &gt; add.obj</p>
</blockquote>
<p><img data-src="objdump_add_asm.png" alt="" /></p></div></div></div>
<h4 id="编译过程"><a class="markdownIt-Anchor" href="#编译过程"></a> 编译过程</h4>
<p>本节内容主要来源于 <a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-overview-of-the-compiler-4e5a153ca889">Go: Overview of the Compiler</a> 和 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/release-branch.go1.13/src/cmd/compile/README.md">Introduction to the Go compiler</a>。Go的编译过程包含四个阶段，被分成两类：</p>
<ul>
<li>
<p><code>编译前端</code>：此阶段从源代码运行分析并生成源代码的抽象句法结构，称为 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>。</p>
</li>
<li>
<p><code>编译后端</code>：第二阶段将源代码的表示形式转换为机器代码，并进行一些优化。</p>
</li>
</ul>
<p><img data-src="compile-process.png" alt="编译流程" /></p>
<p>由下面的一段代码展示这四个过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	b := <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">		add(a, b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h5>
<p>这个阶段的主要实现是在 <code>cmd/compile/internal/syntax</code> 中，在编译的第一阶段，对源代码进行分词（词法分析）、解析（语法分析），并为每个源文件构建语法树。</p>
<p>每个语法树都是相应源文件的精确表示，其节点对应于源文件的各种元素，例如表达式、声明和语句。语法树还包括位置信息，用于错误报告和调试信息的创建。</p>
<div class="tabs" id="go-compile-parsing"><ul class="nav-tabs"><li class="tab active"><a href="#go-compile-parsing-1">分词结果</a></li><li class="tab"><a href="#go-compile-parsing-2">分词代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="go-compile-parsing-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">root@b89af2baca14:/WORKDIR/gostudy/compile# go run tokenized.go</span><br><span class="line">1:1	package	&quot;package&quot;</span><br><span class="line">1:9	IDENT	&quot;main&quot;</span><br><span class="line">1:13	;	&quot;\n&quot;</span><br><span class="line">3:1	func	&quot;func&quot;</span><br><span class="line">3:6	IDENT	&quot;main&quot;</span><br><span class="line">3:10	(	&quot;&quot;</span><br><span class="line">3:11	)	&quot;&quot;</span><br><span class="line">3:13	&#123;	&quot;&quot;</span><br><span class="line">4:2	IDENT	&quot;a&quot;</span><br><span class="line">4:4	:=	&quot;&quot;</span><br><span class="line">4:7	INT	&quot;1&quot;</span><br><span class="line">4:8	;	&quot;\n&quot;</span><br><span class="line">5:2	IDENT	&quot;b&quot;</span><br><span class="line">5:4	:=	&quot;&quot;</span><br><span class="line">5:7	INT	&quot;2&quot;</span><br><span class="line">5:8	;	&quot;\n&quot;</span><br><span class="line">6:2	if	&quot;if&quot;</span><br><span class="line">6:5	IDENT	&quot;true&quot;</span><br><span class="line">6:10	&#123;	&quot;&quot;</span><br><span class="line">7:3	IDENT	&quot;add&quot;</span><br><span class="line">7:6	(	&quot;&quot;</span><br><span class="line">7:7	IDENT	&quot;a&quot;</span><br><span class="line">7:8	,	&quot;&quot;</span><br><span class="line">7:10	IDENT	&quot;b&quot;</span><br><span class="line">7:11	)	&quot;&quot;</span><br><span class="line">7:12	;	&quot;\n&quot;</span><br><span class="line">8:2	&#125;	&quot;&quot;</span><br><span class="line">8:3	;	&quot;\n&quot;</span><br><span class="line">9:1	&#125;	&quot;&quot;</span><br><span class="line">9:2	;	&quot;\n&quot;</span><br><span class="line">11:1	func	&quot;func&quot;</span><br><span class="line">11:6	IDENT	&quot;add&quot;</span><br><span class="line">11:9	(	&quot;&quot;</span><br><span class="line">11:10	IDENT	&quot;a&quot;</span><br><span class="line">11:11	,	&quot;&quot;</span><br><span class="line">11:13	IDENT	&quot;b&quot;</span><br><span class="line">11:15	IDENT	&quot;int&quot;</span><br><span class="line">11:18	)	&quot;&quot;</span><br><span class="line">11:20	&#123;	&quot;&quot;</span><br><span class="line">12:2	IDENT	&quot;println&quot;</span><br><span class="line">12:9	(	&quot;&quot;</span><br><span class="line">12:10	IDENT	&quot;a&quot;</span><br><span class="line">12:12	+	&quot;&quot;</span><br><span class="line">12:14	IDENT	&quot;b&quot;</span><br><span class="line">12:15	)	&quot;&quot;</span><br><span class="line">12:16	;	&quot;\n&quot;</span><br><span class="line">13:1	&#125;	&quot;&quot;</span><br><span class="line">13:2	;	&quot;\n&quot;</span><br><span class="line">root@b89af2baca14:/WORKDIR/gostudy/compile#</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="go-compile-parsing-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;go/scanner&quot;</span></span><br><span class="line">	<span class="string">&quot;go/token&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	srcCode := []<span class="type">byte</span>(</span><br><span class="line">		<span class="string">`package main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">	a := 1</span></span><br><span class="line"><span class="string">	b := 2</span></span><br><span class="line"><span class="string">	if true &#123;</span></span><br><span class="line"><span class="string">		add(a, b)</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func add(a, b int) &#123;</span></span><br><span class="line"><span class="string">	println(a + b)</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the scanner.</span></span><br><span class="line">	<span class="keyword">var</span> s scanner.Scanner</span><br><span class="line">	fset := token.NewFileSet()                          <span class="comment">// positions are relative to fset</span></span><br><span class="line">	file := fset.AddFile(<span class="string">&quot;&quot;</span>, fset.Base(), <span class="built_in">len</span>(srcCode)) <span class="comment">// register input &quot;file&quot;</span></span><br><span class="line">	s.Init(file, srcCode, <span class="literal">nil</span> <span class="comment">/* no error handler */</span>, scanner.ScanComments)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Repeated calls to Scan yield the token sequence found in the input.</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		pos, tok, lit := s.Scan()</span><br><span class="line">		<span class="keyword">if</span> tok == token.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\t%s\t%q\n&quot;</span>, fset.Position(pos), tok, lit)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>分词之后就可以拿去构建语法树。</p>
<h5 id="类型检查和ast转换"><a class="markdownIt-Anchor" href="#类型检查和ast转换"></a> 类型检查和AST转换</h5>
<p>这部分的代码实现主要在 <code>cmd/compile/internal/gc</code>，小写 <code>gc</code> 代表 <code>go compile</code>，大写 <code>GC</code> 代表 <code>Garbage Collector</code>。</p>
<p>这个阶段的第一件事情是将 <code>cmd/compile/internal/syntax</code> 的语法树转换为编译器的 <code>AST</code> 表示，接下来就是名称解析和类型推断，确定哪个对象属于哪个标识符，以及每个表达式具有什么类型。</p>
<p>这个阶段还会做一些优化，例如内联，我们可以使用 <code>go tool compile -w</code> 查看这些细节：</p>
<div class="tabs" id="类型检查和ast转换"><ul class="nav-tabs"><li class="tab active"><a href="#类型检查和ast转换-1">允许内敛优化</a></li><li class="tab"><a href="#类型检查和ast转换-2">禁用内敛优化</a></li></ul><div class="tab-content"><div class="tab-pane active" id="类型检查和ast转换-1"><p>将我们的代码保存为 <code>main.go</code> 之后，我们可以使用 <code>go tool compile -w</code> 查看这个过程，我们没有看到第7行存在函数调用。</p>
<p><img data-src="compile-allow-inline.png" alt="" /></p></div><div class="tab-pane" id="类型检查和ast转换-2"><p>禁用内敛优化，我们可以使用 <code>go tool compile -w -l</code> 查看这个过程，我们在第7行看到了调用 <code>add</code> 函数。</p>
<p><img data-src="compile-disable-inline.png" alt="" /></p></div></div></div>
<h5 id="ssa-代码生成"><a class="markdownIt-Anchor" href="#ssa-代码生成"></a> SSA 代码生成</h5>
<p>这个阶段会将 <code>AST</code> 被转换为静态单一分配 (<code>SSA</code>（静态单赋值形式）) 形式，这是一种具有特定属性的较低级别的中间表示，可以更轻松地实现优化并最终从中生成机器代码。 在此转换期间，编译器将会根据情况应用高度优化的代码完成代码自动优化。</p>
<p>在 <code>AST</code> 到 <code>SSA</code> 的转换过程中，某些节点也被降低为更简单的组件，以便编译器的其余部分可以使用它们。例如，内建的 <code>copy</code> 被内存移动所取代，并且 <code>range</code> 循环被重写为 <code>for</code> 循环。</p>
<p>然后，应用一系列与机器无关的通行证和规则。这些不涉及任何单一的计算机架构，因此可以在所有 <code>GOARCH</code> 变体上运行。这些通用传递的一些示例包括消除死代码、删除不需要的 <code>nil</code> 检查和删除未使用的分支。通用重写规则主要关注表达式，比如用常量值替换一些表达式，优化乘法和浮点运算。</p>
<p>这部分的实现在：</p>
<ul>
<li><code>cmd/compile/internal/gc</code> （AST 转换成SSA）</li>
<li><code>cmd/compile/internal/ssa</code> （应用一系列优化手段和基于架构的一些规则）</li>
</ul>
<div class="tabs" id="ssa-代码生成"><ul class="nav-tabs"><li class="tab active"><a href="#ssa-代码生成-1">生成优化的SSA代码</a></li><li class="tab"><a href="#ssa-代码生成-2">对比生成未优化的SSA代码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="ssa-代码生成-1"><p>使用如下的命令可以生成 <code>SSA</code> 代码：</p>
<blockquote>
<p>GOSSAFUNC=main go tool compile main.go &amp;&amp; open ssa.html</p>
</blockquote>
<p>这个生成的 <code>HTML</code> 文档会展示在生成最终代码的过程中应用了哪些规则，例如下面的，由于我们代码中的 <code>a</code> 和 <code>b</code> 是常量，<code>a + b</code> 的和也是已知的，所以应用 <code>opt</code> 规则，直接将其结果存储，并将原来的 <code>a</code> 和 <code>b</code> 删除。</p>
<p><img data-src="go-compile-ssa-optimize.png" alt="" /></p>
<p>一旦将所有能用的优化手段都运用完之后，就会生成一个中间的汇编代码，就是我们的 <code>GO汇编</code>：</p>
<p><img data-src="go-compile-gen-ir-asm.png" alt="" /></p></div><div class="tab-pane" id="ssa-代码生成-2"><p>使用如下的命令可以生成 <code>SSA</code> 代码：</p>
<blockquote>
<p>GOSSAFUNC=main go tool compile -l main.go &amp;&amp; open ssa.html</p>
</blockquote>
<p>这里我们禁用优化，可以看到最终生成的 <code>SSA</code> 和我们的源代码基本相同，<code>a</code> 和 <code>b</code> 两个变量没有被优化掉，没有使用 <code>opt</code> 优化规则：</p>
<p><img data-src="go-compile-ssa-unoptimize.png" alt="" /></p>
<p>生成的Go汇编中也可以证明这个：</p>
<p><img data-src="go-compile-gen-ir-unoptimize-asm.png" alt="" /></p></div></div></div>
<h5 id="生成机器代码"><a class="markdownIt-Anchor" href="#生成机器代码"></a> 生成机器代码</h5>
<p>这部分的实现主要在：</p>
<ul>
<li><code>cmd/compile/internal/ssa</code> (SSA 降级成平台相关的表示，并且进行优化，不再是中间码)</li>
<li><code>cmd/internal/obj</code> （机器代码生成）</li>
</ul>
<p>一旦 SSA 被“降低”并且更具体到目标架构，最终的代码优化通道就会运行。这包括另一个死代码消除过程、将值移近它们的用途、删除从不读取的局部变量以及寄存器分配。</p>
<p>作为此步骤的一部分完成的其他重要工作包括堆栈帧布局，它将堆栈偏移量分配给局部变量，以及指针活性分析，它计算在每个 <code>GC</code> 安全点处哪些堆栈指针处于活动状态。</p>
<p>在 <code>SSA</code> 生成阶段结束时，<code>Go</code> 函数已转换为一系列 <code>obj.Prog</code> 指令。这些被传递给汇编器（<code>cmd/internal/obj</code>），汇编器将它们转换为机器代码并写出最终的目标文件。目标文件还将包含反射数据、导出数据和调试信息。</p>
<p><code>Go 汇编</code> 可以作为链接器的直接输入生成机器代码，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>go tool compile -S hello.go</code> 将会直接输出 <code>Go汇编</code> 并且生成这个 <code>hello.o</code> 文件。使用 <code>go tool link hello.o</code> 将会链接并且生成可执行文件：</p>
<p><img data-src="go-compile-obj-ir.png" alt="" /></p>
<h4 id="汇编语言"><a class="markdownIt-Anchor" href="#汇编语言"></a> 汇编语言</h4>
<p>本节的内容主要基于<a target="_blank" rel="noopener" href="https://go.dev/doc/asm">https://go.dev/doc/asm</a>，详细描述Go汇编语言与 <code>x86-64</code> 不同的地方，相对于 <code>x86-64</code>，Go汇编 添加了一些伪指令用于汇编代码的快速开发，但是使用的指令还有通用寄存器命令仍然与特定平台相关，伪寄存器在链接阶段会被转换。</p>
<p>以 <code>x86-64</code> 平台为例，我们可以在以下文件中找到寄存器和指令列表：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/cmd/internal/obj/x86/list6.go"><code>src/cmd/internal/obj/x86/list6.go</code></a> (寄存器列表)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/cmd/internal/obj/x86/anames.go"><code>src/cmd/internal/obj/x86/anames.go</code></a> (指令列表)</li>
</ul>
<p>以通用64位寄存器为例，Go汇编中对寄存器的名称做了些许修改：</p>
<table>
<thead>
<tr>
<th style="text-align:center">X86-64</th>
<th style="text-align:center">rax</th>
<th style="text-align:center">rbx</th>
<th style="text-align:center">rcx</th>
<th style="text-align:center">rdx</th>
<th style="text-align:center">rdi</th>
<th style="text-align:center">rsi</th>
<th style="text-align:center">rbp</th>
<th style="text-align:center">rsp</th>
<th style="text-align:center">r8</th>
<th style="text-align:center">r9</th>
<th style="text-align:center">r10</th>
<th style="text-align:center">r11</th>
<th style="text-align:center">r12</th>
<th style="text-align:center">r13</th>
<th style="text-align:center">r14</th>
<th style="text-align:center">rip</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Go汇编</td>
<td style="text-align:center">AX</td>
<td style="text-align:center">BX</td>
<td style="text-align:center">CX</td>
<td style="text-align:center">DX</td>
<td style="text-align:center">DI</td>
<td style="text-align:center">SI</td>
<td style="text-align:center">BP</td>
<td style="text-align:center">SP</td>
<td style="text-align:center">R8</td>
<td style="text-align:center">R9</td>
<td style="text-align:center">R10</td>
<td style="text-align:center">R11</td>
<td style="text-align:center">R12</td>
<td style="text-align:center">R13</td>
<td style="text-align:center">R14</td>
<td style="text-align:center">PC</td>
</tr>
</tbody>
</table>
<p>也有一些指令别名，例如 <code>MOVD</code> 实际上就是 <code>MOVQ</code> 的别名，这些定义可以查看<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/7ca6902c171b336d98adbb103d701a013229c806/src/cmd/asm/internal/arch/arch.go#L102">https://github.com/golang/go/blob/7ca6902c171b336d98adbb103d701a013229c806/src/cmd/asm/internal/arch/arch.go#L102</a>。</p>
<p>从Go源代码转换为Go汇编有<code>3</code>中不同的方式，根据场景自行取用：</p>
<ul>
<li><code>go tool compile -S x.go</code></li>
<li><code>go build -gcflags=&quot;-S&quot; x.go</code></li>
<li><code>go build -o main main.go &amp;&amp; go tool objdump -s main.main main</code> （先编译然后反汇编）</li>
</ul>
<h5 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h5>
<p>虽然Go汇编受 plan9 影响，但仍然有众多不同。在常量估值方面，汇编代码中常量表达式使用Go的运算符优先级规则解析，而不是原始的C规则。例如，对于表达式 <code>3&amp;1&lt;&lt;2</code>，它的结果是 <code>4</code>（<code>(3&amp;1)&lt;&lt;2</code>），而不是 <code>0</code>（<code>3&amp;(1&lt;&lt;2)</code>）。还有就是数值常量总是被计算为 <code>64</code> 位无符号整数，因此 <code>-2</code> 会被计算为具有相同二进制形式的整数，它最终表现为 <code>-2</code> 还是 <code>65534</code>，取决于我们为这个变量添加的类型。例如，下面的代码会输出：</p>
<blockquote>
<p>num1=65534, num2=-2</p>
</blockquote>
<div class="tabs" id="go汇编语言常量整数"><ul class="nav-tabs"><li class="tab active"><a href="#go汇编语言常量整数-1">源代码，asm.go</a></li><li class="tab"><a href="#go汇编语言常量整数-2">源代码，asm.s</a></li></ul><div class="tab-content"><div class="tab-pane active" id="go汇编语言常量整数-1"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	num1 <span class="type">uint16</span></span><br><span class="line">	num2 <span class="type">int16</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;num1=%d, num2=%d&quot;</span>, num1, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="go汇编语言常量整数-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line"></span><br><span class="line">GLOBL ·num1(SB),NOPTR,$2</span><br><span class="line">DATA ·num1(SB)/2,$-2</span><br><span class="line"></span><br><span class="line">GLOBL ·num2(SB),NOPTR,$2</span><br><span class="line">DATA ·num2(SB)/2,$-2</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<p>在Go汇编中，全局变量由一系列的 <code>DATA</code> 指令和紧跟其后的 <code>GLOBL</code> 指令完成，每个 <code>DATA</code> 指令初始化对应内存的一部分，没有被显示初始化的内存将被清零，<code>DATA</code> 指令的通用形式是：</p>
<blockquote>
<p>DATA	symbol+offset(SB)/width, value</p>
</blockquote>
<p>具体含义是，将变量 <code>symbol</code> 从 <code>offset</code> 开始的 <code>width</code> 宽度的内存，用 <code>value</code> 对应的值进行初始化，<code>width</code> 必须是 <code>1</code>，<code>2</code>，<code>4</code>，或者 <code>8</code>，<code>offset</code>和 <code>width</code> 对应的单位都是字节。</p>
<p><code>GLOBL</code> 指令一般跟在 <code>DATA</code> 指令之后，声明变量是全局变量，如果 <code>DATA</code> 没有对它进行初始化，它的值将是全<code>0</code>。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA divtab&lt;&gt;+0x00(SB)/4, $0xf4f8fcff</span><br><span class="line">DATA divtab&lt;&gt;+0x04(SB)/4, $0xe6eaedf0</span><br><span class="line">...</span><br><span class="line">DATA divtab&lt;&gt;+0x3c(SB)/4, $0x81828384</span><br><span class="line">GLOBL divtab&lt;&gt;(SB), RODATA, $64</span><br><span class="line"></span><br><span class="line">GLOBL runtime·tlsoffset(SB), NOPTR|RODATA, $4</span><br></pre></td></tr></table></figure>
<p>这个例子中定义和声明了文件私有的（<code>&lt;&gt;</code>），<code>64 Bytes</code> 的变量 <code>divtab</code>。也声明了一个 <code>4 Bytes</code> 的未包含指针（<code>NOPTR</code>）的只读（<code>RODATA</code>）零值变量 <code>runtime·tlsoffset</code>。<code>GLOBL</code> 除了声明符号的大小之外，可能还会有<code>1</code>个参数用来指定符号的一些属性，这些属性定义在文件 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/runtime/textflag.h"><code>src/runtime/textflag.h</code></a> 中，主要有：</p>
<ul>
<li><code>NOPROF   = 1</code>: (For <code>TEXT</code> items.) Don’t profile the marked function. This flag is deprecated；</li>
<li><code>DUPOK    = 2</code>: 允许相同符号在二进制文件中有多个，链接器选择其中一个使用即可；</li>
<li><code>NOSPLIT  = 4</code>: (For <code>TEXT</code> items.) 不要插入用来检查是否需要栈扩展的代码；</li>
<li><code>RODATA   = 8</code>: (For <code>DATA</code> and <code>GLOBL</code> items.) 声明变量是只读的，将被放在二进制文件只读段；</li>
<li><code>NOPTR   = 16</code>: (For <code>DATA</code> and <code>GLOBL</code> items.) 声明的变量不包含任何指针，垃圾回收器不用扫描；</li>
<li><code>WRAPPER = 32</code>: (For <code>TEXT</code> items.) This is a wrapper function and should not count as disabling <code>recover</code>；</li>
<li><code>NEEDCTXT= 64</code>: (For <code>TEXT</code> items.) This function is a closure so it uses its incoming context register；</li>
<li><code>LOCAL  = 128</code>: 此符号是动态共享对象的本地符号；</li>
<li><code>TLSBSS = 256</code>: (For <code>DATA</code> and <code>GLOBL</code> items.) 把这个变量放到线程的本地存储中；</li>
<li><code>NOFRAME = 512</code>: （对于 <code>TEXT</code> 项。）不要插入指令来分配堆栈帧并保存/恢复返回地址，即使这不是叶函数。仅对声明帧大小为 <code>0</code> 的函数有效；</li>
<li><code>TOPFRAME = 2048</code>: (For TEXT items.) Function is the outermost frame of the call stack. Traceback should stop at this function；</li>
<li><code>ABIWRAPPER</code>：表示函数是一个ABI包装器；</li>
</ul>
<h5 id="寄存器-3"><a class="markdownIt-Anchor" href="#寄存器-3"></a> 寄存器</h5>
<p>Go汇编定义了一些由工具链维护的伪寄存器，这些寄存器对所有的架构都是通用的：</p>
<ul>
<li><code>FP</code>：用于访问函数参数和局部变量；</li>
<li><code>PC</code>：程序计数器，等同于x86-64中的 <code>%rip</code> ；</li>
<li><code>SB</code>：静态基指针，用于访问全局变量；</li>
<li><code>SP</code>：栈指针，指向函数栈帧的高地址；</li>
</ul>
<p>通过 <code>SB</code> 和 <code>FP</code> 这两个伪寄存器，我们可以访问所有我们定义的函数和变量。</p>
<h6 id="sb"><a class="markdownIt-Anchor" href="#sb"></a> SB</h6>
<p><code>SB</code> 寄存器可以被看做是对原始内存的访问，所以 <code>foo(SB)</code> 指向变量 <code>foo</code> 的内存地址，它被用于去引用全局变量和函数。在定义的符号后面添加 <code>&lt;&gt;</code> 表示这个符号只能在当前文件内被使用。在符号后面可以添加一个 <code>offset</code>，例如 <code>foo+4(SB)</code> 表示从 <code>foo</code> 的第四个字节开始。</p>
<p>例如，我们定义一个 <code>uint16</code> 的变量 <code>num</code>，给他赋值 <code>0xABCD</code>，十进制是 <code>43981</code>，二进制表示是 <code>10101011 11001101</code>，我们可以用下面的汇编代码对他进行初始化，Go汇编代码有个要求就是结尾必须有个空行，否则编译会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line"></span><br><span class="line">DATA ·num(SB)/1,$0b11001101</span><br><span class="line">DATA ·num+1(SB)/1,$0b10101011</span><br><span class="line">GLOBL ·num(SB),NOPTR,$2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="fp"><a class="markdownIt-Anchor" href="#fp"></a> FP</h6>
<p>栈帧是操作系统为函数调用在栈上开辟的内存空间，它包含自己的局部变量和被调函数的参数。我们可以通过Go语言中的 <code>FP</code>伪寄存器和一个偏移量访问当前函数的参数。所以说在 <code>64</code>位系统上， <code>0(FP)</code>是第一个参数，<code>8(FP)</code> 是第二个参数。但是当使用这种方式引用函数参数时，我们必须加上变量名，例如 <code>first_arg+0(FP)</code>，<code>second_arg+8(FP)</code>，这是Go的汇编器强制要求，但是名称是什么无所谓，不必须和函数签名一致。要注意区分的是，<code>foo+8(FP)</code> 和 <code>foo+8(SB)</code>，前者时相对于 <code>FP</code> 进行偏移，而后者是相对于 <code>foo</code> 的起始地址进行偏移。</p>
<p>对于Go定义的函数，<code>go vet</code> 将会检查参数名称是否和偏移量匹配。另外，在<code>32</code> 位系统上，<code>64</code> 位值得低 <code>32</code> 位和高 <code>32</code> 位可以通过在名称后面添加 <code>_lo</code> 和 <code>_hi</code> 后缀进行区分。例如，<code>arg_lo+0(FP)</code> 和 <code>arg_hi+4(FP)</code>，如果函数没有对返回值命名，那么默认为 <code>ret</code>。</p>
<p>为了说明对 <code>FP</code> 伪寄存器的使用，我们准备如下的例子，例子很简单，就是实现对全局变量 <code>numa</code> 和 <code>numb</code> 的交换，我们使用汇编实现 <code>p</code> 和 <code>q</code> 函数，就是想演示通过栈如何传递参数以及栈的布局，这两个函数如果用Go实现就是：</p>
<blockquote>
<p>func p() {numa, numb = q(numa, numb)}</p>
</blockquote>
<blockquote>
<p>func q(a, b uint32) (ret0, ret1 uint32) {return b, a}</p>
</blockquote>
<div class="tabs" id="go汇编fp伪寄存器使用"><ul class="nav-tabs"><li class="tab active"><a href="#go汇编fp伪寄存器使用-1">main.go</a></li><li class="tab"><a href="#go汇编fp伪寄存器使用-2">asm.s</a></li></ul><div class="tab-content"><div class="tab-pane active" id="go汇编fp伪寄存器使用-1"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numa, numb <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">q</span><span class="params">(a, b <span class="type">uint32</span>)</span></span> (ret0, ret1 <span class="type">uint32</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(numa, numb)</span><br><span class="line">	p()</span><br><span class="line">	fmt.Println(numa, numb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将汇编代码和Go代码一起编译运行是没有任何问题的，现在我们来画处当进入 <code>q</code> 函数内时，<code>p</code> 和 <code>q</code> 栈帧示意图。有一点需要提前了解的是，我们在为 <code>p</code> 函数分配栈帧的时候，不需要分配它调用 <code>q</code> 时存储<strong>返回地址</strong>（<code>CALL</code> 指令下一条指令地址）的空间，<code>CALL</code> 指令执行的时候会自动扩展栈，将返回地址压栈，可以通过 <code>dlv</code> 调试代码查看寄存器值得变化以及对应内存值。所以<mark class="label ">当我们执行 <code>q</code> 函数的时候</mark>，看到的栈空间以及 <code>FP</code> 的位置如下图：</p>
<p><img data-src="pcallq-goasm-fp.png" alt="" /></p></div><div class="tab-pane" id="go汇编fp伪寄存器使用-2"><p>下面的汇编代码中，只使用了虚拟寄存器 <code>FP</code>，在函数 <code>q</code> 中，使用硬件寄存器 <code>SP</code> 将 <code>q</code> 的参数放置到栈上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line"></span><br><span class="line">DATA  ·numa+0(SB)/4, $1</span><br><span class="line">GLOBL ·numa(SB),NOPTR,$4</span><br><span class="line"></span><br><span class="line">DATA  ·numb+0(SB)/4, $2</span><br><span class="line">GLOBL ·numb(SB),NOPTR,$4</span><br><span class="line"></span><br><span class="line">TEXT ·p(SB), NOSPLIT, $40-0</span><br><span class="line">    // x86-64，当帧大于0时，被调用者需要保存和恢复BP寄存器</span><br><span class="line">    SUBQ  $40, SP</span><br><span class="line">    MOVQ  BP, 32(SP)</span><br><span class="line">    LEAQ  32(SP), BP</span><br><span class="line"></span><br><span class="line">    // x86-64 不能将数据从内存直接移动到另一块内存，所以需要先移动到寄存器做中转</span><br><span class="line">    // 将全局变量 numa 赋值给 q 的参数 a</span><br><span class="line">    MOVQ ·numa(SB), AX</span><br><span class="line">    MOVQ AX, (SP)  // a = numa</span><br><span class="line"></span><br><span class="line">    // 将全局变量 numb 赋值给 q 的参数 b</span><br><span class="line">    MOVQ ·numb(SB), BX</span><br><span class="line">    MOVQ BX, 8(SP)  // b = numb</span><br><span class="line"></span><br><span class="line">    CALL ·q(SB)</span><br><span class="line"></span><br><span class="line">	// 将 ret1 给 numb</span><br><span class="line">	// 将 ret0 给 numa</span><br><span class="line">    MOVQ 16(SP), AX // 16(SP) is ret0 = 2</span><br><span class="line">    MOVQ 24(SP), CX // 24(SP) is ret1  = 1</span><br><span class="line">    MOVQ AX, ·numa(SB)</span><br><span class="line">    MOVQ CX, ·numb(SB)</span><br><span class="line"></span><br><span class="line">    MOVQ 32(SP), BP</span><br><span class="line">    ADDQ $40, SP</span><br><span class="line"></span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">TEXT ·q(SB), NOSPLIT, $0-24</span><br><span class="line">    // 将参数a赋值给 ret1</span><br><span class="line">    MOVQ a+0(FP), DI</span><br><span class="line">    MOVQ DI, ret1+24(FP) // a-&gt;ret1 = 1</span><br><span class="line"></span><br><span class="line">    // 将参数b赋值给 ret0</span><br><span class="line">    MOVQ b+8(FP), SI</span><br><span class="line">    MOVQ SI, ret0+16(FP) // b-&gt;ret0 = 2</span><br><span class="line"></span><br><span class="line">    RET</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<h6 id="sp"><a class="markdownIt-Anchor" href="#sp"></a> SP</h6>
<p>虚拟机寄存器 <code>SP</code> 是一个虚拟栈指针，用于访问局部变量和那些为函数调用准备的参数，它指向栈帧的最高地址，所以引用应该用负偏移量，区间是 <code>[−framesize, 0)</code>，例如 <code>x-8(SP)</code>，以及 <code>y-4(SP)</code> 等。</p>
<div class="note success no-icon"><p>也有个硬件寄存器 <code>SP</code>，区分两者的特征是有没有一个前缀符号，例如 <code>x-8(SP)</code> 是引用伪寄存器，而 <code>8(SP)</code> 则是引用硬件寄存器。还有一个就是伪寄存器使用负数作为偏移量，而物理寄存器SP使用正数作为偏移量。</p>
</div>
<p>Go汇编中，由于 <code>SP</code> 和 <code>PC</code> 是某些物理寄存器的别名，所以要想访问真实的寄存器，需要使用真正的以 <code>R</code> 开头的名字，例如，在 ARM 上，<code>SP</code> 和 <code>PC</code> 对应于 <code>R13</code> 和 <code>R15</code>。</p>
<p>还是上面 <code>FP</code> 中的示例，不过在前面，我们在函数 <code>p</code> 中是使用<mark class="label ">物理寄存器SP</mark>为被调函数 <code>q</code> 准备参数和访问其返回值，这次我们使用<mark class="label ">伪寄存器SP</mark> 做这些事情，并且下面给出的是函数 <code>p</code> 的栈帧示意图和汇编实现：</p>
<div class="tabs" id="go汇编sp伪寄存器使用"><ul class="nav-tabs"><li class="tab active"><a href="#go汇编sp伪寄存器使用-1">伪寄存器SP栈帧示意图</a></li><li class="tab"><a href="#go汇编sp伪寄存器使用-2">汇编代码 asm.s</a></li></ul><div class="tab-content"><div class="tab-pane active" id="go汇编sp伪寄存器使用-1"><p><img data-src="pcallq-goasm-sp.png" alt="" /></p></div><div class="tab-pane" id="go汇编sp伪寄存器使用-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line"></span><br><span class="line">DATA  ·numa+0(SB)/4, $1</span><br><span class="line">GLOBL ·numa(SB),NOPTR,$4</span><br><span class="line"></span><br><span class="line">DATA  ·numb+0(SB)/4, $2</span><br><span class="line">GLOBL ·numb(SB),NOPTR,$4</span><br><span class="line"></span><br><span class="line">TEXT ·p(SB), NOSPLIT, $40-0</span><br><span class="line">    // x86-64，当帧大于0时，被调用者需要保存和恢复BP寄存器</span><br><span class="line">    SUBQ  $40, SP</span><br><span class="line">    MOVQ  BP, 32(SP)</span><br><span class="line">    LEAQ  32(SP), BP</span><br><span class="line"></span><br><span class="line">    // x86-64 不能将数据从内存直接移动到另一块内存，所以需要先移动到寄存器做中转</span><br><span class="line">    // 将全局变量 numa 赋值给 q 的参数 a</span><br><span class="line">    MOVQ ·numa(SB), AX</span><br><span class="line">    MOVQ AX, a-40(SP)  // a = numa</span><br><span class="line"></span><br><span class="line">    // 将全局变量 numb 赋值给 q 的参数 b</span><br><span class="line">    MOVQ ·numb(SB), BX</span><br><span class="line">    MOVQ BX, b-32(SP)  // b = numb</span><br><span class="line"></span><br><span class="line">    CALL ·q(SB)</span><br><span class="line">    </span><br><span class="line">    // 将 ret1 给 numb</span><br><span class="line">    // 将 ret0 给 numa</span><br><span class="line">    MOVQ ret0-24(SP), AX // ret0-24 is ret0 = 2</span><br><span class="line">    MOVQ ret1-16(SP), CX // ret1-16 is ret1  = 1</span><br><span class="line">    MOVQ AX, ·numa(SB)</span><br><span class="line">    MOVQ CX, ·numb(SB)</span><br><span class="line"></span><br><span class="line">    MOVQ 32(SP), BP</span><br><span class="line">    ADDQ $40, SP</span><br><span class="line"></span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">TEXT ·q(SB), NOSPLIT, $0-24</span><br><span class="line">    // 将参数a赋值给 ret1</span><br><span class="line">    MOVQ a+0(FP), DI</span><br><span class="line">    MOVQ DI, ret1+24(FP) // a-&gt;ret1 = 1</span><br><span class="line"></span><br><span class="line">    // 将参数b赋值给 ret0</span><br><span class="line">    MOVQ b+8(FP), SI</span><br><span class="line">    MOVQ SI, ret0+16(FP) // b-&gt;ret0 = 2</span><br><span class="line"></span><br><span class="line">    RET</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<h5 id="常量与结构体"><a class="markdownIt-Anchor" href="#常量与结构体"></a> 常量与结构体</h5>
<p>如果 <code>go</code> 的包包含 <code>.s</code> 文件，<code>go build</code> 就会让编译器输出一个特殊的头文件 <code>go_asm.h</code>，然后这个 <code>.s</code> 文件可以 <code>#include &quot;go_asm.h&quot;</code>。这个文件中包含了Go代码中定义的常量符号，以及结构的大小和结构体字段的偏移量。例如，我们有下面的常量和结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bufSize = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf [bufSize]<span class="type">int</span></span><br><span class="line">	r   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么会生的 <code>go_asm.h</code> 文件内容如下，所以我们可以在汇编代码中以 <code>const_bufSize</code> 访问常量 <code>bufSize</code>；通过 <code>reader__size</code> 获取 <code>reader</code> 结构体的大小；通过 <code>reader_buf</code>  和 <code>reader_r</code> 可以获取字段 <code>buf</code> 和字段 <code>r</code> 相对于 <code>reader</code> 的偏移量。可以通过 <code>go build -work -x</code> 命令输出编译过程和工作目录，在工作目录中可以找到到 <code>go_asm.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generated by compile -asmhdr from package main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> const_bufSize 0x400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reader__size 4100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reader_buf 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reader_r 4096</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们做个示例，使用 <code>outputVars</code> 调用 <code>printInt</code> 函数，输出 <code>const_bufSize</code>，<code>reader__size</code>，<code>reader.buf[1]</code> 以及 <code>reader.r</code>，Go 代码和汇编代码如下所示，运行这段代码将会输出:</p>
<pre><code>1024 4100 1 8
</code></pre>
<div class="tabs" id="go汇编常量和结构体"><ul class="nav-tabs"><li class="tab active"><a href="#go汇编常量和结构体-1">update.s</a></li><li class="tab"><a href="#go汇编常量和结构体-2">main.go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="go汇编常量和结构体-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line">#include &quot;go_asm.h&quot;</span><br><span class="line"></span><br><span class="line">TEXT ·outputVars(SB), NOSPLIT, $24-8</span><br><span class="line">    SUBQ  $24, SP</span><br><span class="line">    MOVQ  BP, 16(SP)</span><br><span class="line">    LEAQ  16(SP), BP</span><br><span class="line"></span><br><span class="line">    MOVL $const_bufSize, (SP)</span><br><span class="line">    MOVL $reader__size, 4(SP)</span><br><span class="line"></span><br><span class="line">    MOVQ addr+0(FP), AX</span><br><span class="line"></span><br><span class="line">    MOVL reader_buf+4(AX), CX</span><br><span class="line">    MOVL CX, 8(SP)</span><br><span class="line"></span><br><span class="line">    MOVL reader_r(AX), CX</span><br><span class="line">    MOVL CX, 12(SP)</span><br><span class="line"></span><br><span class="line">    CALL ·printInt(SB)</span><br><span class="line"></span><br><span class="line">    MOVQ 16(SP), BP</span><br><span class="line">    ADDQ $24, SP</span><br><span class="line"></span><br><span class="line">    RET</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="go汇编常量和结构体-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bufSize = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf [bufSize]<span class="type">uint32</span></span><br><span class="line">	r   <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outputVars</span><span class="params">(r *reader)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInt</span><span class="params">(a, b, c, d <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	outputVars(&amp;reader&#123;buf: [bufSize]<span class="type">uint32</span>&#123;<span class="number">1</span>: <span class="number">1</span>&#125;, r: <span class="number">8</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div>
<h5 id="运行时"><a class="markdownIt-Anchor" href="#运行时"></a> 运行时</h5>
<p>Go 是一个具有垃圾回收的语言，为了让 GC 运行正确，运行时必须清楚地指导指针在全局数据中和栈帧中的位置。当编译Go代码的时候，编译器会输出这个信息，但是汇编程序必须显示地定义它。</p>
<p>带有 <code>NOPTR</code> 标识的符号被认为不包含任何指针，带有 <code>RODATA</code> 标志的数据会会在只读内存空间中分配内存，隐式带有 <code>NOPTR</code> 标记。如果一个数据的总大小小于指针大小（8字节），也会被隐式打上 <code>NOPTR</code> 标记。在汇编代码中定义一个指针变量是不可能的，这样的数据必须被定义在Go代码中。既是声明的某个变量在汇编代码中没有被用 <code>DATA</code> 和 <code>GLOBL</code> 指令声明，汇编代码仍然可以按名称访问到它。一般情况下，我们只在Go代码中定义非 <code>RODATA</code> 的数据。</p>
<p>每个函数也需要给出它的参数，返回值以及栈帧中可能包含的指针的位置。对于没有指针结果、没有本地堆栈帧或没有函数调用的汇编函数，唯一的要求是在同一包中的 Go 源文件中为函数定义 Go 原型签名。汇编代码中的函数不能包含包名，例如，对于 <code>syscall</code> 包中的 <code>Syscall</code> 函数，在 <code>Text</code> 指令中应该使用 <code>·Syscall</code> 而不是 <code>syscall·Syscall</code>。对于其他更复杂的场景，可以使用定义在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/runtime/funcdata.h"><code>src/runtime/funcdata.h</code></a> 中的伪指令。</p>
<p>如果一个函数没有参数也没有结果，指针信息是可以被省略的。这在 <code>Text</code> 指令中可以使用 <code>$n-0</code> 这样的帧参数大小形式声明。否则指针信息必须在Go文件中通过Go原型声明提供。在函数开始部分，函数参数是被认为初始化的，但是返回值是被认为是未初始化的。如果返回值在函数调用期间保存了指针，则该函数应首先将返回值归零，然后执行伪指令 <code>GO_RESULTS_INITIALIZED</code>。该指令表示返回值现在已经初始化并且应该在堆栈移动和垃圾收集期间进行扫描。通常情况下汇编函数不应该返回指针或不包含调用指令，标准库中没有汇编函数使用 <code>GO_RESULTS_INITIALIZED</code>。</p>
<p>如果一个函数没有栈帧，指针信息是会被省略的，在 <code>Text</code> 指令中，会被表示成 <code>$0-n</code>。如果函数是叶子函数，也就是没有函数调用，指针信息也是可以被省略的。否则，必须通过指令 <code>NO_LOCAL_POINTERS</code> 来说明函数栈帧是没有包含任何指针的。因为堆栈大小调整是通过移动堆栈来实现的，所以堆栈指针可能会在任何函数调用期间发生变化：即使指向堆栈数据的指针也不能保存在局部变量中。</p>
<p>写汇编函数的时候，我们应该总是提供Go的原型声明，也就是使用Go代码呈现函数签名，这样，既可以位参数和结果提供指针信息，也可以让 <code>go vet</code> 检查用于访问它们的偏移量是否正确。</p>
<h5 id="架构相关信息"><a class="markdownIt-Anchor" href="#架构相关信息"></a> 架构相关信息</h5>
<p>列出某个平台的所有指令或者其他细节是不现实的，想要看到特定平台下面有哪些指令，例如：ARM 平台，我们可以去这里 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/cmd/internal/obj/arm/a.out.go">src/cmd/internal/obj/arm</a>，这个文件里面有一系列以字母 <code>A</code> 开头的常量，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AAND = obj.ABaseARM + obj.A_ARCHSPECIFIC + <span class="literal">iota</span></span><br><span class="line">	AEOR</span><br><span class="line">	ASUB</span><br><span class="line">	ARSB</span><br><span class="line">	AADD</span><br><span class="line">	AADC</span><br><span class="line">	ASBC</span><br><span class="line">	ARSC</span><br><span class="line">	ATST</span><br><span class="line">	ATEQ</span><br><span class="line">	ACMP</span><br><span class="line">	ACMN</span><br><span class="line">	AORR</span><br><span class="line">	ABIC</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这个列表中指令的名字和拼写，这个平台下对应的汇编器和链接器都是已知的。每个指令虽然都是以 <code>A</code> 开头，例如 <code>AAND</code>，但是它实际代表的指令是 <code>AND</code> ，在汇编代码中也是写作 <code>AND</code>。我们熟知的 <code>X86-64</code> 结构对应的指令列表是在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/cmd/internal/obj/x86/a.out.go">cmd/internal/obj/x86/a.out.go</a>。</p>
<p>所有架构共享以下的寻址方式，每个架构可能也有自己特定的寻址方式：</p>
<ol>
<li><code>(R1)</code>， 寄存器简洁寻址；</li>
<li><code>4(R1)</code>，寄存器使用偏移量间接寻址；</li>
<li><code>$foo(SB)</code>，绝对寻址</li>
</ol>
<p>在Go汇编系统中，如我们上面描述的例子所展示的那样，汇编指令中，我们的数据都是从左流向右，即源操作数在做，目的操作数在右。例如：<code>MOVQ $0, CX</code>，将 <code>0</code> 移动到 <code>CX</code> 寄存器，已达到清空寄存器的目的。这个数据流向规则在那些使用相反方向数据流的架构中依然适用。</p>
<p>下面我们展示几个我们熟知的架构 <code>X86</code>平台，其他的请看<a target="_blank" rel="noopener" href="https://go.dev/doc/asm">A Quick Guide to Go’s Assembler</a>：</p>
<h6 id="32-bit-intel-386"><a class="markdownIt-Anchor" href="#32-bit-intel-386"></a> 32-bit Intel 386</h6>
<p>指向 <code>g</code> 结构的运行时指针是通过 <code>MMU</code> 中未使用的（就 Go 而言）寄存器的值来维护的。在运行时包中，汇编代码可以包含 <code>go_tls.h</code>，它定义了一个依赖于操作系统和体系结构的宏 <code>get_tls</code> 用于访问该寄存器。<code>get_tls</code> 宏接受一个参数，即加载 <code>g</code> 指针的寄存器。</p>
<p>例如，可以使用下面的代码将 <code>g</code> 和 <code>g.m</code> 分别加载 <code>AX</code> 和 <code>BX</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;go_tls.h&quot;</span><br><span class="line">#include &quot;go_asm.h&quot;</span><br><span class="line">...</span><br><span class="line">get_tls(CX)</span><br><span class="line">MOVL	g(CX), AX     // Move g into AX.</span><br><span class="line">MOVL	g_m(AX), BX   // Move g.m into BX.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个宏在 <code>amd64</code> 架构下也有定义，请查看 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/runtime/go_tls.h">src/runtime/go_tls.h</a>，它的内容是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GOARCH_arm</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LR R14</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GOARCH_amd64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	get_tls(r)	MOVQ TLS, r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	g(r)	0(r)(TLS*1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GOARCH_386</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	get_tls(r)	MOVL TLS, r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	g(r)	0(r)(TLS*1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>x86 系统中， <code>TLS</code> 中存储的是当前 <code>g</code> 的地址，goroutine ID 存储在 <code>g.goid</code> 字段中，<code>go1.16.*</code> 版本中，<code>g.goid</code> 的偏移量是 <code>152</code>，我们可以通过下面的代码实现goid的获取：</p>
<div class="tabs" id="汇编方式获取goid"><ul class="nav-tabs"><li class="tab active"><a href="#汇编方式获取goid-1">asm.s</a></li><li class="tab"><a href="#汇编方式获取goid-2">main.go</a></li></ul><div class="tab-content"><div class="tab-pane active" id="汇编方式获取goid-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line"></span><br><span class="line">TEXT ·gid(SB), NOSPLIT, $0-8</span><br><span class="line">    MOVQ (TLS), AX</span><br><span class="line">    MOVQ 152(AX), BX</span><br><span class="line">    MOVQ BX, ret0+0(FP)</span><br><span class="line">    RET</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="汇编方式获取goid-2"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gid</span><span class="params">()</span></span> <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(gid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>
<p>偏移量的计算我们可以通过 <code>dlv</code> 调试器在用户态任意函数任意位置断住，使用如下的指令获取：</p>
<pre><code>(dlv) p &amp;runtime.curg
(*runtime.g)(0xc000000180)
(dlv) p &amp;runtime.curg.goid
(*int64)(0xc000000218)
(dlv) p 0xc000000218-0xc000000180
152
(dlv)
</code></pre>
<p>特有的寻址方式如下：</p>
<ul>
<li><code>(DI)(BX*2)</code>: 代表的地址是：<code>DI + BX * 2</code></li>
<li><code>64(DI)(BX*2)</code>: 代表的地址是：<code>64 + DI + BX * 2</code>，比例因子只能是 <code>1</code>，<code>2</code>，<code>4</code> 或者 <code>8</code>。</li>
</ul>
<p>使用编译器和汇编器的 <code>-dynlink</code> 或 <code>-shared</code> 模式时，必须假设对固定内存位置（例如全局变量）的任何加载或存储都会覆盖 <code>CX</code>。因此，为了安全使用这些模式，汇编代码通常应避免使用 <code>CX</code>，除非在内存引用之间。</p>
<h6 id="64-bit-intel-386-amd64"><a class="markdownIt-Anchor" href="#64-bit-intel-386-amd64"></a> 64-bit Intel 386 (AMD64)</h6>
<p>这两种架构在汇编级别表现基本相同，访问运行时 <code>g</code> 和 <code>m</code> 的方式也和 <code>32 bit x86</code> 架构是一样的，只是这里的使用的指令是 <code>MOVQ</code> 而不是 <code>MOVL</code>。另外。</p>
<p>作为被调用者需要保存 <code>BP</code>，汇编器会自动在帧大于0的函数中插入 <code>BP</code> 保存和恢复的指令。允许使用 <code>BP</code> 作为通用寄存器，但是这会干扰采样分析。</p>
<h3 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h3>
<ol>
<li><a target="_blank" rel="noopener" href="https://go.dev/doc/asm">A Quick Guide to Go’s Assembler</a></li>
<li><a target="_blank" rel="noopener" href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html">第3章 Go汇编语言</a></li>
<li><a target="_blank" rel="noopener" href="https://particle.cafe/blog/golang-calling-convention.html">Golang Calling Convention</a></li>
<li><a target="_blank" rel="noopener" href="https://oysz2016.github.io/post/8611e6fb.html">数学公式语法——Mathjax教程</a></li>
<li><a target="_blank" rel="noopener" href="https://9p.io/wiki/plan9/plan_9_wiki/">Plan9 wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://talks.golang.org/2012/splash.article">Go at Google: Language Design in the Service of Software Engineering</a></li>
<li><a target="_blank" rel="noopener" href="https://kcode.icu/posts/go/2021-03-20-go-%E4%BD%BF%E7%94%A8%E7%9A%84-plan9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2/">Go 使用的 plan9 汇编语言初探</a></li>
<li><a target="_blank" rel="noopener" href="http://www.4k8k.xyz/article/weixin_40486544/108392947">从Go走进plan9汇编</a></li>
<li><a target="_blank" rel="noopener" href="https://linuxtut.com/en/231350711f9ab6eba95e/">Getting Started with Go Assembly</a></li>
<li><a target="_blank" rel="noopener" href="https://quasilyte.dev/blog/post/call-go-from-jit/">Calling Go funcs from asm and JITed code</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="MichaelFu 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="MichaelFu 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>MichaelFu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" title="【Golang】汇编语言">https://blog.fudenglong.site/2022/03/01/Go/【Golang】汇编语言/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/23/Go/%E3%80%90Golang%E3%80%91%E5%BD%B1%E5%93%8Druntime%E8%A1%8C%E4%B8%BA%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" rel="prev" title="【Golang】影响runtime行为的环境变量">
                  <i class="fa fa-angle-left"></i> 【Golang】影响runtime行为的环境变量
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/23/HTTPS/" rel="next" title="HTTPS">
                  HTTPS <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">辽ICP备15012817号-2 </a>
  </div>
  <div class="copyright">
    &copy; 2020 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MichaelFu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">465k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">28:11</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/gamelife1314" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/bookmark.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/search/local-search.min.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js"},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/tags/pdf.min.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"dark","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js"}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/tags/mermaid.min.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/fancybox.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/pace.min.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":false,"delay":true,"timeout":5000,"priority":true,"url":"https://blog.fudenglong.site/2022/03/01/Go/%E3%80%90Golang%E3%80%91%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/quicklink.min.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"gamelife1314/gamelife1314.github.io","issue_term":"title","theme":"github-light"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/comments/utterances.min.js"></script>

</body>
</html>
