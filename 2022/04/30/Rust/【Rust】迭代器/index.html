<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta name="google-site-verification" content="lk2gSYFP_NyLNFob-fFnt7fm-I_n1ZYws-WZll7mshg">
  <meta name="msvalidate.01" content="6Jdc01DjYOLguhS5">
  <meta name="baidu-site-verification" content="code-NR10G09zww">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7Ccursive:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/yellow/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.fudenglong.site","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":800},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/local-search.xml","localsearch":{"enable":true,"top_n_per_article":10,"unescape":false,"preload":true,"trigger":"auto"}}</script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script>

    <meta name="description" content="迭代器是产生一系列值的值，通常用于循环操作。Rust 的标准库提供了遍历vector、字符串、哈希表和其他集合的迭代器，还提供了从输入流生成文本行、网络连接、用于多线程之间值传递的迭代器，Rust 的迭代器灵活、富有表现力且高效。 在 Rust 中，std::iter::Iterator 和 std::iter::IntoIterator 是实现迭代器的基础。 12345pub trait Ite">
<meta property="og:type" content="article">
<meta property="og:title" content="【Rust】迭代器">
<meta property="og:url" content="https://blog.fudenglong.site/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/index.html">
<meta property="og:site_name" content="MichaelFu">
<meta property="og:description" content="迭代器是产生一系列值的值，通常用于循环操作。Rust 的标准库提供了遍历vector、字符串、哈希表和其他集合的迭代器，还提供了从输入流生成文本行、网络连接、用于多线程之间值传递的迭代器，Rust 的迭代器灵活、富有表现力且高效。 在 Rust 中，std::iter::Iterator 和 std::iter::IntoIterator 是实现迭代器的基础。 12345pub trait Ite">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.fudenglong.site/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/other-iterators.png">
<meta property="article:published_time" content="2022-04-30T12:20:44.000Z">
<meta property="article:modified_time" content="2022-04-30T12:20:44.000Z">
<meta property="article:author" content="MichaelFu">
<meta property="article:tag" content="《Rust 程序设计》">
<meta property="article:tag" content="迭代器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.fudenglong.site/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/other-iterators.png">


<link rel="canonical" href="https://blog.fudenglong.site/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.fudenglong.site/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/","path":"2022/04/30/Rust/【Rust】迭代器/","title":"【Rust】迭代器"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>【Rust】迭代器 | MichaelFu</title>
  







<script async src="/lib/fireworks.js"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MichaelFu</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好记性不如烂笔头</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-云-&nbsp;&nbsp;原-&nbsp;&nbsp;生"><a href="/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="section"><i class="fa fa-cloud fa-fw"></i>云 &nbsp;&nbsp;原 &nbsp;&nbsp;生</a></li><li class="menu-item menu-item-rust-编程"><a href="/Programming-Rust/" rel="section"><i class="fa fa-cat fa-fw"></i>Rust 编程</a></li><li class="menu-item menu-item-go-&nbsp;&nbsp;&nbsp;编程"><a href="/Programming-Go/" rel="section"><i class="fa fa-hippo fa-fw"></i>Go &nbsp;&nbsp;&nbsp;编程</a></li><li class="menu-item menu-item-前端知识"><a href="https://wshuhua.github.io/" rel="section" target="_blank"><i class="fa fa-sun fa-fw"></i>前端知识</a></li><li class="menu-item menu-item-leetcode-rust"><a href="/Leetcode-Rust/" rel="section"><i class="fa fa-book fa-fw"></i>Leetcode-Rust</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text"> 创建迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iter-%E5%92%8C-iter_mut"><span class="nav-number">1.1.</span> <span class="nav-text"> iter 和 iter_mut</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#into_iter-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text"> into_iter 实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#from_fn-%E5%92%8C-successors"><span class="nav-number">1.3.</span> <span class="nav-text"> from_fn 和 successors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drain"><span class="nav-number">1.4.</span> <span class="nav-text"> drain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text"> 其他迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text"> 迭代适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map-filter"><span class="nav-number">2.1.</span> <span class="nav-text"> map、filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filter_map-flat_map"><span class="nav-number">2.2.</span> <span class="nav-text"> filter_map、flat_map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flatten"><span class="nav-number">2.3.</span> <span class="nav-text"> flatten</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#take-take_while"><span class="nav-number">2.4.</span> <span class="nav-text"> take、take_while</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skip-skip_while"><span class="nav-number">2.5.</span> <span class="nav-text"> skip、skip_while</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#peekable"><span class="nav-number">2.6.</span> <span class="nav-text"> peekable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fuse"><span class="nav-number">2.7.</span> <span class="nav-text"> fuse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#next_back-rev"><span class="nav-number">2.8.</span> <span class="nav-text"> next_back、rev</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inspect"><span class="nav-number">2.9.</span> <span class="nav-text"> inspect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chain"><span class="nav-number">2.10.</span> <span class="nav-text"> chain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#enumerate"><span class="nav-number">2.11.</span> <span class="nav-text"> enumerate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zip"><span class="nav-number">2.12.</span> <span class="nav-text"> zip</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#by_ref"><span class="nav-number">2.13.</span> <span class="nav-text"> by_ref</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cycle"><span class="nav-number">2.14.</span> <span class="nav-text"> cycle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text"> 消费迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#count-sum-product"><span class="nav-number">3.1.</span> <span class="nav-text"> count、sum、product</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#max-min"><span class="nav-number">3.2.</span> <span class="nav-text"> max、min</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#max_by-min_by"><span class="nav-number">3.3.</span> <span class="nav-text"> max_by、min_by</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#max_by_key-min_by_key"><span class="nav-number">3.4.</span> <span class="nav-text"> max_by_key、min_by_key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#item-%E5%BA%8F%E5%88%97%E6%AF%94%E8%BE%83"><span class="nav-number">3.5.</span> <span class="nav-text"> item 序列比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#any-all"><span class="nav-number">3.6.</span> <span class="nav-text"> any、all</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#position-rposition-exactsizeiterator"><span class="nav-number">3.7.</span> <span class="nav-text"> position、rposition、ExactSizeIterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fold-rfold"><span class="nav-number">3.8.</span> <span class="nav-text"> fold、rfold</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try_fold-try_rfold"><span class="nav-number">3.9.</span> <span class="nav-text"> try_fold、try_rfold</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nth-nth_back"><span class="nav-number">3.10.</span> <span class="nav-text"> nth、nth_back</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#last"><span class="nav-number">3.11.</span> <span class="nav-text"> last</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-rfind-find_map"><span class="nav-number">3.12.</span> <span class="nav-text"> find、rfind、find_map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collect-fromiterator"><span class="nav-number">3.13.</span> <span class="nav-text"> collect、FromIterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extend"><span class="nav-number">3.14.</span> <span class="nav-text"> extend</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#partition"><span class="nav-number">3.15.</span> <span class="nav-text"> partition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for_each-try_for_each"><span class="nav-number">3.16.</span> <span class="nav-text"> for_each、try_for_each</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text"> 实现迭代器</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MichaelFu"
      src="/avatar.jpeg">
  <p class="site-author-name" itemprop="name">MichaelFu</p>
  <div class="site-description" itemprop="description">实践能让记忆更深刻</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">84</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gamelife1314" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gamelife1314" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:michael.fudenglong@qq.com" title="E-Mail → mailto:michael.fudenglong@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://www.rust-lang.org/zh-CN/" title="https:&#x2F;&#x2F;www.rust-lang.org&#x2F;zh-CN&#x2F;" rel="noopener" target="_blank">Rust</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://go.dev/" title="https:&#x2F;&#x2F;go.dev&#x2F;" rel="noopener" target="_blank">Golang</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://www.python.org/" title="https:&#x2F;&#x2F;www.python.org&#x2F;" rel="noopener" target="_blank">Python</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://doc.rust-lang.org/cargo/index.html" title="https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;index.html" rel="noopener" target="_blank">Cargo</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://gist.github.com/rxaviers/7360908" title="https:&#x2F;&#x2F;gist.github.com&#x2F;rxaviers&#x2F;7360908" rel="noopener" target="_blank">Emoji</a>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.fudenglong.site/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.jpeg">
      <meta itemprop="name" content="MichaelFu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MichaelFu">
      <meta itemprop="description" content="实践能让记忆更深刻">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="【Rust】迭代器 | MichaelFu">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【Rust】迭代器
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-30 20:20:44" itemprop="dateCreated datePublished" datetime="2022-04-30T20:20:44+08:00">2022-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>迭代器是产生一系列值的值，通常用于循环操作。<code>Rust</code> 的标准库提供了遍历<code>vector</code>、字符串、哈希表和其他集合的迭代器，还提供了从输入流生成文本行、网络连接、用于多线程之间值传递的迭代器，<code>Rust</code> 的迭代器灵活、富有表现力且高效。</p>
<p>在 <code>Rust</code> 中，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html"><code>std::iter::Iterator</code></a> 和 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code>std::iter::IntoIterator</code></a> 是实现迭代器的基础。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器可以是任何实现了 <code>Iterator</code> 的值，<code>Item</code> 是每次迭代产生的值，<code>next</code> 要么返回 <code>Some(v)</code>，<code>v</code> 是下一个值，要么返回 <code>None</code> 表示迭代结束。</p>
<p>想要被迭代的类型也可以实现 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code>std::iter::IntoIterator</code></a>，它的 <code>into_iter</code> 返回一个迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">IntoIterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IntoIter</span>: <span class="built_in">Iterator</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::IntoIter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们常用的 <code>for</code> 循环仅仅是先调用 <code>into_iter</code> 生成一个迭代器，然后重复调用迭代器的 <code>next</code> 方法，直到 <code>next</code> 返回 <code>None</code>，预示着迭代结束。</p>
<span id="more"></span>
<h3 id="创建迭代器"><a class="markdownIt-Anchor" href="#创建迭代器"></a> 创建迭代器</h3>
<p><code>Rust</code> 标准库文档详细解释了每种类型提供的迭代器类型，但该库遵循一些通用约定来帮助定位并找到需要的东西。</p>
<h4 id="iter-和-iter_mut"><a class="markdownIt-Anchor" href="#iter-和-iter_mut"></a> <code>iter</code> 和 <code>iter_mut</code></h4>
<p>大多数集合类型都提供了 <code>iter</code> 和 <code>iter_mut</code> 方法，它们返回类型的迭代器，生成对每个<code>item</code>的共享或可变引用。像 <code>&amp;[T]</code> 和 <code>&amp;mut [T]</code> 这样的数组切片也有 <code>iter</code> 和 <code>iter_mut</code> 方法。这些方法是获取迭代器的最常用方法，如果不打算让 <code>for</code> 循环为您处理它，可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iterator</span> = v.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">4</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">20</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">12</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">8</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">6</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
<p>这个迭代器的 <code>item</code> 类型是 <code>&amp;i32</code>：每次调用 <code>next</code> 都会产生对下一个元素的引用，直到我们到达<code>vector</code>的末尾。每种类型都可以自由地以最适合其目的的方式实现 <code>iter</code> 和 <code>iter_mut</code>。<code>std::path::Path</code> 上的 <code>iter</code> 方法返回一个迭代器，该迭代器一次生成一个路径信息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::OsStr;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">path</span> = Path::<span class="title function_ invoke__">new</span>(<span class="string">&quot;C:/Users/JimB/Downloads/Fedora.iso&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iterator</span> = path.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(OsStr::<span class="title function_ invoke__">new</span>(<span class="string">&quot;C:&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(OsStr::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Users&quot;</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iterator.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(OsStr::<span class="title function_ invoke__">new</span>(<span class="string">&quot;JimB&quot;</span>)));</span><br></pre></td></tr></table></figure>
<h4 id="into_iter-实现"><a class="markdownIt-Anchor" href="#into_iter-实现"></a> <code>into_iter</code> 实现</h4>
<p>当一个类型实现 <code>IntoIterator</code> 时，你可以自己调用它的 <code>into_iter</code> 方法，就像 <code>for</code> 循环一样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeSet;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">favorites</span> = BTreeSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line">favorites.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Lucy in the Sky With Diamonds&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">favorites.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Liebesträume No. 3&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">it</span> = favorites.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(it.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Liebesträume No. 3&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"><span class="built_in">assert_eq!</span>(it.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Lucy in the Sky With Diamonds&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line"><span class="built_in">assert_eq!</span>(it.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
<p>大多数集合提供了几种 <code>IntoIterator</code> 的实现，例如，<code>&amp;T</code>，<code>&amp;mut T</code> 和 <code>T</code>：</p>
<ul>
<li>
<p><code>&amp;T</code> 类型的迭代器产生的每个值都是对值的共享引用；</p>
</li>
<li>
<p><code>&amp;mut T</code> 类型的迭代器产生的每个值都对值的可变引用。例如 <code>Vec&lt;String&gt;</code>，调用 <code>(&amp;mut vector).into_iter()</code> 返回了一个迭代器，它的 <code>Item</code> 类型是 <code>&amp;mut String</code>；</p>
</li>
<li>
<p>调用 <code>T</code> 类型的 <code>into_iter()</code> 方法首先会获取集合值的是所有权，在迭代过程中，每个 <code>item</code> 的所有权从集合移动至消费的人；</p>
</li>
</ul>
<p><code>for</code> 循环将 <code>IntoIterator::into_iter</code> 应用于其操作数，因此这三个实现创建了以下习惯用法，用于迭代对集合的共享或可变引用，或使用集合并获取其元素的所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> &amp;collection &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> collection &#123; ... &#125;</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> collection &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>并非每种类型都提供所有三种实现。例如，<code>HashSet</code>、<code>BTreeSet</code> 和 <code>BinaryHeap</code> 不会在可变引用上实现 <code>IntoIterator</code>，因为修改它们的元素可能会违反类型的不变性。</p>
<p>切片实现了三个 <code>IntoIterator</code> 变体中的两个，因为它们不拥有自己的元素，所以不存在<code>[T]</code>这种情况。相反，<code>&amp;[T]</code> 和 <code>&amp;mut [T]</code> 的 <code>into_iter</code> 返回一个迭代器，该迭代器生成对元素的共享和可变引用。</p>
<h4 id="from_fn-和-successors"><a class="markdownIt-Anchor" href="#from_fn-和-successors"></a> <code>from_fn</code> 和 <code>successors</code></h4>
<p>一个更简单通用的方式是提供一个返回它们的闭包。<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/fn.from_fn.html"><code>std::iter::from_fn</code></a> 调用一个返回 <code>Option&lt;T&gt;</code> 的函数生成一个迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> rand::random; <span class="comment">// In Cargo.toml dependencies: rand = &quot;0.7&quot;</span></span><br><span class="line">    <span class="keyword">use</span> std::iter::from_fn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lengths</span>: <span class="type">Vec</span>&lt;<span class="type">f64</span>&gt; = <span class="title function_ invoke__">from_fn</span>(|| <span class="title function_ invoke__">Some</span>((random::&lt;<span class="type">f64</span>&gt;() - random::&lt;<span class="type">f64</span>&gt;()).<span class="title function_ invoke__">abs</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">take</span>(<span class="number">1000</span>)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个迭代器永远返回 <code>Some(f64)</code>，所以它永远不会结束，但是我们通过 <code>take(1000)</code> 只取了前 <code>1000</code> 个值。</p>
<p>如果产生的每个值都和前一个相关，那么可以使用 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/fn.successors.html"><code>std::iter::successors</code></a> 函数完成，它接受一个初始值和一个函数并且返回下一个 <code>item</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> num::Complex;</span><br><span class="line"><span class="keyword">use</span> std::iter::successors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">escape_time</span>(c: Complex&lt;<span class="type">f64</span>&gt;, limit: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">zero</span> = Complex &#123; re: <span class="number">0.0</span>, im: <span class="number">0.0</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">successors</span>(<span class="title function_ invoke__">Some</span>(zero), |&amp;z| <span class="title function_ invoke__">Some</span>(z * z + c))</span><br><span class="line">        .<span class="title function_ invoke__">take</span>(limit)</span><br><span class="line">        .<span class="title function_ invoke__">enumerate</span>()</span><br><span class="line">        .<span class="title function_ invoke__">find</span>(|(_i, z)| z.<span class="title function_ invoke__">norm_sqr</span>() &gt; <span class="number">4.0</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|(i, _z)| i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从零开始，<code>successors</code> 通过重复对最后一个点求平方并与参数 <code>c</code>求和。</p>
<p><code>from_fn</code> 和 <code>successors</code> 都接受 <code>FnMut</code> 闭包，因此闭包可以捕获和修改来自周围范围的变量。例如，这个斐波那契函数使用<code>move</code>闭包来捕获变量并将其用作其运行状态：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fibonacci</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item = <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">state</span> = (<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    std::iter::<span class="title function_ invoke__">from_fn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        state = (state.<span class="number">1</span>, state.<span class="number">0</span> + state.<span class="number">1</span>);</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(state.<span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">fibonacci</span>().<span class="title function_ invoke__">take</span>(<span class="number">10</span>).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="drain"><a class="markdownIt-Anchor" href="#drain"></a> <code>drain</code></h4>
<p>许多集合类型提供了一个 <code>drain</code> 方法，该方法需要获取集合的可变引用，将对应区间的值从原来的集合中删掉，并且将删除的值以一个新的迭代器返回：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">outer</span> = <span class="string">&quot;Earth&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">inner</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_iter</span>(outer.<span class="title function_ invoke__">drain</span>(<span class="number">1</span>..<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(outer, <span class="string">&quot;Eh&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(inner, <span class="string">&quot;art&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他迭代器"><a class="markdownIt-Anchor" href="#其他迭代器"></a> 其他迭代器</h4>
<p><img data-src="other-iterators.png" alt="" /></p>
<h3 id="迭代适配器"><a class="markdownIt-Anchor" href="#迭代适配器"></a> 迭代适配器</h3>
<p>一旦有了一个迭代器，<code>Iterator</code> 提供了广泛的适配器方法选择，它们使用一个迭代器并构建一个新迭代器。要了解适配器的工作原理，我们将从两个最流行的 <code>map</code> 和 <code>filter</code> 开始。</p>
<h4 id="map-filter"><a class="markdownIt-Anchor" href="#map-filter"></a> <code>map</code>、<code>filter</code></h4>
<p><code>Iterator</code> 和 <code>map</code> 方法接受一个闭包或者函数作为参数应用于它的所有元素，然后产生新的迭代器。而 <code>filter</code> 接受一个闭包或函数作为参数，应用于所有元素过滤出符合要求的元素组成新的迭代器。</p>
<p>例如，我们可以使用 <code>map</code> 去将一段文本每行开始和结尾的空格去掉：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot; ponies \n giraffes\niguanas \nsquid&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = text.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">map</span>(<span class="type">str</span>::trim).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="string">&quot;ponies&quot;</span>, <span class="string">&quot;giraffes&quot;</span>, <span class="string">&quot;iguanas&quot;</span>, <span class="string">&quot;squid&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的案例，我们如果想在处理掉首尾的空格之后，还要排除 <code>&quot;iguanas&quot;</code>，我们可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot; ponies \n giraffes\niguanas \nsquid&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = text</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(<span class="type">str</span>::trim)</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|s| *s != <span class="string">&quot;iguanas&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="string">&quot;ponies&quot;</span>, <span class="string">&quot;giraffes&quot;</span>, <span class="string">&quot;squid&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器适配器就像 <code>shell</code> 中的 <code>pipeline</code>，每个适配器有一个单独的目的。这些适配器函数签名如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">map</span>&lt;B, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=B&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">filter</span>&lt;P&gt;(<span class="keyword">self</span>, predicate: P) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, P: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>
<p>在标准库中，<code>map</code> 和 <code>filter</code> 实际上返回名为 <code>std::iter::Map</code> 和 <code>std::iter::Filter</code> 的特定不透明结构类型。然而，仅仅看到它们的名字并不能提供太多信息，所以这里，我们只打算写 <code>-&gt; impl Iterator&lt;Item=...&gt;</code> ，因为它告诉我们真正想知道的：方法返回一个生成给定 <code>item</code> 类型的迭代器。</p>
<p>由于大多数适配器需要获取所有权，因此它们需要 <code>Self </code> 是 <code>Sized</code>。</p>
<p><code>map</code> 通过值将每个 <code>item</code> 传递给它的闭包，然后将闭包结果的所有权传递给它的消费者。<code>filter</code> 通过共享引用将每个项目传递给它的闭包，在<code>item</code>被选择传递给其消费者的情况下保留所有权。这就是示例必须解引用 <code>s</code> 来和 <code>&quot;iguanas&quot;</code> 比较的原因：<code>filter</code> 闭包的参数 <code>s</code> 的类型是 <code>&amp;&amp;str</code>。</p>
<p>关于迭代器适配器，有两点需要注意。</p>
<ul>
<li>
<p>迭代器是惰性的，不调用 <code>next</code> 方法就不会实际运行，也就是不会消费任何 <code>item</code>。前面的例子中，在 <code>collect</code> 调用 <code>filter</code> 返回的迭代器的 <code>next</code> 方法之前，<code>text.lines()</code> 和 <code>map()</code> 不会做任何工作，这点很像 <code>python</code> 中的生成器；</p>
</li>
<li>
<p>迭代适配器是零成本抽象，这意味着 <code>Rust</code> 有足够的信息将每个迭代器的 <code>next</code> 方法内联到其消费者中，然后将整个流程转换为机器代码作为一个单元，也就是我们不用关心适配器的性能开销，<code>Rust</code> 帮我们解决，对于上面的例子，和我们手写下面的代码有同样的性能：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">line</span> = line.<span class="title function_ invoke__">trim</span>();</span><br><span class="line">    <span class="keyword">if</span> line != <span class="string">&quot;iguanas&quot;</span> &#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="filter_map-flat_map"><a class="markdownIt-Anchor" href="#filter_map-flat_map"></a> <code>filter_map</code>、<code>flat_map</code></h4>
<p><code>filter_map</code> 类似于 <code>map</code>，但是它的闭包函数返回一个 <code>Option&lt;T&gt;</code> 决定这个值是留还是删掉，有点像 <code>filter</code> 和 <code>map</code> 的结合，该函数的声明如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">filter_map</span>&lt;B, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=B&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;B&gt;;</span><br></pre></td></tr></table></figure>
<p>举个例子，如果你想从一段以空格分割的字符串中解析出数字，可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;1\nfrond .25 289\n3.1415 estuary\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> text</span><br><span class="line">        .<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter_map</span>(|w| <span class="type">f64</span>::<span class="title function_ invoke__">from_str</span>(w).<span class="title function_ invoke__">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:4.2&#125;&quot;</span>, number.<span class="title function_ invoke__">sqrt</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码输出：</p>
<pre><code>1.00
0.50
17.00
1.77
</code></pre>
<p>这个目的可以使用 <code>map</code> 和 <code>filter</code> 配合完成，但是有了 <code>filter_map</code> 就显得有点笨拙了：</p>
<div class="note warning"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;1\nfrond .25 289\n3.1415 estuary\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> text</span><br><span class="line">        .<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|w| <span class="type">f64</span>::<span class="title function_ invoke__">from_str</span>(w))</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|r| r.<span class="title function_ invoke__">is_ok</span>())</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|r| r.<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:4.2&#125;&quot;</span>, number.<span class="title function_ invoke__">sqrt</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>而 <code>flat_map</code> 和 <code>map</code> 一样，只是它的闭包可以返回多个 <code>item</code>，而不是一个，它的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">flat_map</span>&lt;U, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=U::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> U, U: <span class="built_in">IntoIterator</span>;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">major_cities</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Japan&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Tokyo&quot;</span>, <span class="string">&quot;Kyoto&quot;</span>]);</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;The United States&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Portland&quot;</span>, <span class="string">&quot;Nashville&quot;</span>]);</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Brazil&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;São Paulo&quot;</span>, <span class="string">&quot;Brasília&quot;</span>]);</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Kenya&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Nairobi&quot;</span>, <span class="string">&quot;Mombasa&quot;</span>]);</span><br><span class="line">    major_cities.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;The Netherlands&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Amsterdam&quot;</span>, <span class="string">&quot;Utrecht&quot;</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">countries</span> = [<span class="string">&quot;Japan&quot;</span>, <span class="string">&quot;Brazil&quot;</span>, <span class="string">&quot;Kenya&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;city <span class="keyword">in</span> countries.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">flat_map</span>(|country| &amp;major_cities[country]) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, city);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码输出：</p>
<pre><code>Tokyo
Kyoto
São Paulo
Brasília
Nairobi
Mombasa
</code></pre>
<h4 id="flatten"><a class="markdownIt-Anchor" href="#flatten"></a> <code>flatten</code></h4>
<p>如果我们要将一个二维数组转换成一维数组，就可以使用 <code>flatten</code>，在这里二维数组的每个元素都是可迭代的，它的定义如下，要求迭代器中的每个元素也都是可迭代的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">flatten</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>::Item: <span class="built_in">IntoIterator</span>;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line">    <span class="comment">// A table mapping cities to their parks: each value is a vector.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parks</span> = BTreeMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    parks.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Portland&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Mt. Tabor Park&quot;</span>, <span class="string">&quot;Forest Park&quot;</span>]);</span><br><span class="line">    parks.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Kyoto&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Tadasu-no-Mori Forest&quot;</span>, <span class="string">&quot;Maruyama Koen&quot;</span>]);</span><br><span class="line">    parks.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Nashville&quot;</span>, <span class="built_in">vec!</span>[<span class="string">&quot;Percy Warner Park&quot;</span>, <span class="string">&quot;Dragon Park&quot;</span>]);</span><br><span class="line">    <span class="comment">// Build a vector of all parks. `values` gives us an iterator producing</span></span><br><span class="line">    <span class="comment">// vectors, and then `flatten` produces each vector&#x27;s elements in turn.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">all_parks</span>: <span class="type">Vec</span>&lt;_&gt; = parks.<span class="title function_ invoke__">values</span>().<span class="title function_ invoke__">flatten</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        all_parks,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="string">&quot;Tadasu-no-Mori Forest&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Maruyama Koen&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Percy Warner Park&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Dragon Park&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Mt. Tabor Park&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Forest Park&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用 <code>flatten</code> 挑出 <code>Vec&lt;Option&lt;&amp;str&gt;&gt;</code> 中所有 <code>Some&lt;&amp;str&gt;</code>，因为 <code>Option</code> 也是可迭代的，例如，：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(<span class="string">&quot;day&quot;</span>), <span class="literal">None</span>, <span class="title function_ invoke__">Some</span>(<span class="string">&quot;one&quot;</span>)]</span><br><span class="line">            .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">            .<span class="title function_ invoke__">flatten</span>()</span><br><span class="line">            .collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;(),</span><br><span class="line">        <span class="built_in">vec!</span>[<span class="string">&quot;day&quot;</span>, <span class="string">&quot;one&quot;</span>]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="take-take_while"><a class="markdownIt-Anchor" href="#take-take_while"></a> <code>take</code>、<code>take_while</code></h4>
<p><code>take</code> 和 <code>take_while</code> 用于决定迭代什么时候结束，前者通过迭代次数，后者通过一个闭包。它们都会获取原迭代器的所有权，它们的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">take</span>(<span class="keyword">self</span>, n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">take_while</span>&lt;P&gt;(<span class="keyword">self</span>, predicate: P) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, P: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>
<p>举个例子，给定一封电子邮件，其中一个空行将标头与邮件正文分开，可以使用 <code>take_while</code> 仅迭代标头：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="string">&quot;To: jimb\r\n\</span></span><br><span class="line"><span class="string"> From: superego &lt;editor@oreilly.com&gt;\r\n\</span></span><br><span class="line"><span class="string"> \r\n\</span></span><br><span class="line"><span class="string"> Did you get any writing done today?\r\n\</span></span><br><span class="line"><span class="string"> When will you stop wasting time plotting fractals?\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">header</span> <span class="keyword">in</span> message.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">take_while</span>(|l| !l.<span class="title function_ invoke__">is_empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, header);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="skip-skip_while"><a class="markdownIt-Anchor" href="#skip-skip_while"></a> <code>skip</code>、<code>skip_while</code></h4>
<p><code>skip</code> 和 <code>skip_while</code> 方法是 <code>take</code> 和 <code>take_while</code> 的补充：它们从迭代的开始丢弃一定数量的<code>item</code>，或者丢弃<code>item</code>直到闭包找到一个可接受的项目，剩余的保持不变。它们的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">skip</span>(<span class="keyword">self</span>, n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">skip_while</span>&lt;P&gt;(<span class="keyword">self</span>, predicate: P) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, P: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>
<p>例如，我们处理命令行参数时，通常丢掉第一个表示程序路径的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">arg</span> <span class="keyword">in</span> std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想处理上面的邮件中的主体消息而不是标题，我们可以跳过开头的非空行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="string">&quot;To: jimb\r\n\</span></span><br><span class="line"><span class="string"> From: superego &lt;editor@oreilly.com&gt;\r\n\</span></span><br><span class="line"><span class="string"> \r\n\</span></span><br><span class="line"><span class="string"> Did you get any writing done today?\r\n\</span></span><br><span class="line"><span class="string"> When will you stop wasting time plotting fractals?\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">body</span> <span class="keyword">in</span> message.<span class="title function_ invoke__">lines</span>().<span class="title function_ invoke__">skip_while</span>(|l| !l.<span class="title function_ invoke__">is_empty</span>()).<span class="title function_ invoke__">skip</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="peekable"><a class="markdownIt-Anchor" href="#peekable"></a> <code>peekable</code></h4>
<p><code>peekable</code> 迭代器就是可以让你浏览下一个 <code>item</code> 但是又没实际使用它，就像调用了 <code>next</code> 然后又退回来了（假设），可以将任何迭代器通过转换成 <code>peekable</code> 的 <code>Iterator</code>。它的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">peekable</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> std::iter::Peekable&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html"><code>std::iter::Peekable</code></a> 是实现了 <code>Iterator&lt;Item=Self::Item&gt;</code> 的迭代器，这里的 <code>Self</code> 指的是底层的迭代器。</p>
<p>例如，如果要从字符流中解析数字，则在看到其后的第一个非数字字符之前，无法确定数字的结束位置：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::iter::Peekable;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_number</span>&lt;I&gt;(tokens: &amp;<span class="keyword">mut</span> Peekable&lt;I&gt;) <span class="punctuation">-&gt;</span> <span class="type">u32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    I: <span class="built_in">Iterator</span>&lt;Item = <span class="type">char</span>&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> tokens.<span class="title function_ invoke__">peek</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(r) <span class="keyword">if</span> r.<span class="title function_ invoke__">is_digit</span>(<span class="number">10</span>) =&gt; &#123;</span><br><span class="line">                n = n * <span class="number">10</span> + r.<span class="title function_ invoke__">to_digit</span>(<span class="number">10</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; <span class="keyword">return</span> n,</span><br><span class="line">        &#125;</span><br><span class="line">        tokens.<span class="title function_ invoke__">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">chars</span> = <span class="string">&quot;226153980,1766319049&quot;</span>.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">peekable</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parse_number</span>(&amp;<span class="keyword">mut</span> chars), <span class="number">226153980</span>);</span><br><span class="line">    <span class="comment">// Look, `parse_number` didn&#x27;t consume the comma! So we will.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(chars.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">parse_number</span>(&amp;<span class="keyword">mut</span> chars), <span class="number">1766319049</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(chars.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fuse"><a class="markdownIt-Anchor" href="#fuse"></a> <code>fuse</code></h4>
<p><code>fuse</code> 在迭代器第一次结束，即调用它的 <code>next</code> 方法返回 <code>None</code> 之后永远都返回 <code>None</code>，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Flaky</span>(<span class="type">bool</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Flaky</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="number">0</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="string">&quot;totally the last item&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="number">0</span> = <span class="literal">true</span>; <span class="comment">// D&#x27;oh!</span></span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flaky</span> = <span class="title function_ invoke__">Flaky</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(flaky.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;totally the last item&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(flaky.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(flaky.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;totally the last item&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">not_flaky</span> = <span class="title function_ invoke__">Flaky</span>(<span class="literal">true</span>).<span class="title function_ invoke__">fuse</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(not_flaky.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="string">&quot;totally the last item&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(not_flaky.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(not_flaky.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="next_back-rev"><a class="markdownIt-Anchor" href="#next_back-rev"></a> <code>next_back</code>、<code>rev</code></h4>
<p>如果迭代器实现了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/trait.DoubleEndedIterator.html"><code>std::iter::DoubleEndedIterator</code></a>，就可以从两端开始迭代，直到它们相遇迭代结束。该 <code>trait</code> 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">DoubleEndedIterator</span>: <span class="built_in">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next_back</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bee_parts</span> = [<span class="string">&quot;head&quot;</span>, <span class="string">&quot;thorax&quot;</span>, <span class="string">&quot;abdomen&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = bee_parts.<span class="title function_ invoke__">iter</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;head&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next_back</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;abdomen&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;thorax&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next_back</span>(), <span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个迭代器是双端迭代器，我们就可以使用 <code>rev</code> 对迭代器进行反转，<code>rev</code> 方法的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">rev</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span> + <span class="built_in">DoubleEndedIterator</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">meals</span> = [<span class="string">&quot;breakfast&quot;</span>, <span class="string">&quot;lunch&quot;</span>, <span class="string">&quot;dinner&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = meals.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rev</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;dinner&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;lunch&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;breakfast&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inspect"><a class="markdownIt-Anchor" href="#inspect"></a> <code>inspect</code></h4>
<p><code>inspect</code> 对于调试很方便，但在生产代码中使用不多。它只是将闭包应用于每个<code>item</code>的共享引用，然后传递该<code>item</code>。闭包不会影响<code>item</code>，但它可以做一些事情，比如打印它们或对它们进行断言。</p>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">upper_case</span>: <span class="type">String</span> = <span class="string">&quot;große&quot;</span></span><br><span class="line">        .<span class="title function_ invoke__">chars</span>()</span><br><span class="line">        .<span class="title function_ invoke__">inspect</span>(|c| <span class="built_in">println!</span>(<span class="string">&quot;before: &#123;:?&#125;&quot;</span>, c))</span><br><span class="line">        .<span class="title function_ invoke__">flat_map</span>(|c| c.<span class="title function_ invoke__">to_uppercase</span>())</span><br><span class="line">        .<span class="title function_ invoke__">inspect</span>(|c| <span class="built_in">println!</span>(<span class="string">&quot; after: &#123;:?&#125;&quot;</span>, c))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(upper_case, <span class="string">&quot;GROSSE&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小写德语字母<code>“ß”</code>的大写等效项是<code>“SS”</code>，这就是为什么 <code>char::to_uppercase</code> 返回字符的迭代器，而不是单个替换字符。 前面的代码使用 <code>flat_map</code> 将 <code>to_uppercase</code> 返回的所有序列连接成一个字符串，并打印以下内容：</p>
<pre><code>before: 'g'
after: 'G'
before: 'r'
after: 'R'
before: 'o'
after: 'O'
before: 'ß'
after: 'S'
after: 'S'
before: 'e'
after: 'E'
</code></pre>
<h4 id="chain"><a class="markdownIt-Anchor" href="#chain"></a> <code>chain</code></h4>
<p><code>chain</code> 可以将多个迭代器连接起来，它的方法声明如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">chain</span>&lt;U&gt;(<span class="keyword">self</span>, other: U) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Iterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, U: <span class="built_in">IntoIterator</span>&lt;Item=<span class="keyword">Self</span>::Item&gt;;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">chain</span>(<span class="built_in">vec!</span>[<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>chain</code> 迭代器是可以反转的，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">chain</span>(<span class="built_in">vec!</span>[<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]).<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, [<span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enumerate"><a class="markdownIt-Anchor" href="#enumerate"></a> <code>enumerate</code></h4>
<p><code>enumerate</code> 可以用于在迭代的时候自动加上索引，例如，原本返回 <code>A, B, C</code> 序列，现在返回 <code>(0, A), (1, B), (2, C)</code>。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, num) <span class="title function_ invoke__">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">chain</span>(<span class="built_in">vec!</span>[<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]).<span class="title function_ invoke__">rev</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, index, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码输出：<br />
0, 40<br />
1, 30<br />
2, 20<br />
3, 3<br />
4, 2<br />
5, 1</p>
<h4 id="zip"><a class="markdownIt-Anchor" href="#zip"></a> <code>zip</code></h4>
<p><code>zip</code> 用于将两个迭代器合成一个迭代器，每次各从一个中取出一个值，组成一对，直到有一个迭代结束。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;_&gt; = (<span class="number">0</span>..).<span class="title function_ invoke__">zip</span>(<span class="string">&quot;ABCD&quot;</span>.<span class="title function_ invoke__">chars</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="built_in">vec!</span>[(<span class="number">0</span>, <span class="string">&#x27;A&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;D&#x27;</span>)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>zip</code> 的参数可以是任何可迭代对象：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::iter::repeat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">endings</span> = <span class="built_in">vec!</span>[<span class="string">&quot;once&quot;</span>, <span class="string">&quot;twice&quot;</span>, <span class="string">&quot;chicken soup with rice&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rhyme</span>: <span class="type">Vec</span>&lt;(&amp;<span class="type">str</span>, &amp;<span class="type">str</span>)&gt; = <span class="title function_ invoke__">repeat</span>(<span class="string">&quot;going&quot;</span>).<span class="title function_ invoke__">zip</span>(endings).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        rhyme,</span><br><span class="line">        <span class="built_in">vec!</span>[</span><br><span class="line">            (<span class="string">&quot;going&quot;</span>, <span class="string">&quot;once&quot;</span>),</span><br><span class="line">            (<span class="string">&quot;going&quot;</span>, <span class="string">&quot;twice&quot;</span>),</span><br><span class="line">            (<span class="string">&quot;going&quot;</span>, <span class="string">&quot;chicken soup with rice&quot;</span>)</span><br><span class="line">        ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="by_ref"><a class="markdownIt-Anchor" href="#by_ref"></a> <code>by_ref</code></h4>
<p>前面看到的大多数的适配器都会获取底层迭代器的所有权，没法再次使用，例如，对于上面的邮件示例，我们想解析邮件标题和邮件内容，可以这样做：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">message</span> = <span class="string">&quot;To: jimb\r\n\</span></span><br><span class="line"><span class="string"> From: superego &lt;editor@oreilly.com&gt;\r\n\</span></span><br><span class="line"><span class="string"> \r\n\</span></span><br><span class="line"><span class="string"> Did you get any writing done today?\r\n\</span></span><br><span class="line"><span class="string"> When will you stop wasting time plotting fractals?\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lines</span> = message.<span class="title function_ invoke__">lines</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Headers:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">header</span> <span class="keyword">in</span> lines.<span class="title function_ invoke__">by_ref</span>().<span class="title function_ invoke__">take_while</span>(|l| !l.<span class="title function_ invoke__">is_empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;\nBody:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">body</span> <span class="keyword">in</span> lines &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>lines.by_ref()</code> 借用了一个对迭代器的可变引用，而 <code>take_while</code> 迭代器正是这个引用的所有者。该迭代器在第一个 <code>for</code> 循环结束时退出时被丢掉，因此可以在第二个 <code>for</code> 循环中再次使用行。该代码输出：</p>
<pre><code>Headers:
To: jimb
From: superego &lt;editor@oreilly.com&gt;

Body:
Did you get any writing done today?
When will you stop wasting time plotting fractals?
</code></pre>
<h4 id="cycle"><a class="markdownIt-Anchor" href="#cycle"></a> <code>cycle</code></h4>
<p><code>cycle</code> 可以通过底层的迭代器无休止地生成值序列，只要底层的迭代器实现了 <code>std::clone::Clone</code>，因为他需要保存它的初始状态并且在每次循环开始时重用它，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dirs</span> = [<span class="string">&quot;North&quot;</span>, <span class="string">&quot;East&quot;</span>, <span class="string">&quot;South&quot;</span>, <span class="string">&quot;West&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">spin</span> = dirs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cycle</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;North&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;East&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;South&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;West&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;North&quot;</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(spin.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;East&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费迭代器"><a class="markdownIt-Anchor" href="#消费迭代器"></a> 消费迭代器</h3>
<p>前面已经讲解了如何创建和转换迭代器，这节来说明如何消费迭代器，除了使用 <code>for</code> 和直接调用 <code>next</code> 之外的其他方法。</p>
<h4 id="count-sum-product"><a class="markdownIt-Anchor" href="#count-sum-product"></a> <code>count</code>、<code>sum</code>、<code>product</code></h4>
<p><code>count</code> 用于统计迭代器中有多少个 <code>item</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sum</code> 和 <code>product</code> 用于计算迭代器整数或者浮点数的和或者乘积：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">triangle</span>(n: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    (<span class="number">1</span>..=n).<span class="title function_ invoke__">sum</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">factorial</span>(n: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    (<span class="number">1</span>..=n).<span class="title function_ invoke__">product</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">triangle</span>(<span class="number">20</span>), <span class="number">210</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">factorial</span>(<span class="number">20</span>), <span class="number">2432902008176640000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="max-min"><a class="markdownIt-Anchor" href="#max-min"></a> <code>max</code>、<code>min</code></h4>
<p><code>min</code> 和 <code>max</code> 分别返回迭代器内<code>item</code>的最大或者最小值，其中这里的<code>item</code>必须实现 <code>std::cmp::Ord</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>([-<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, -<span class="number">5</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">max</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>([-<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, -<span class="number">5</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min</span>(), <span class="title function_ invoke__">Some</span>(&amp;-<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法返回 <code>Option&lt;Self::Item&gt;</code>，所以它们可以返回 <code>None</code> 如果迭代器内没有 <code>item</code>。</p>
<h4 id="max_by-min_by"><a class="markdownIt-Anchor" href="#max_by-min_by"></a> <code>max_by</code>、<code>min_by</code></h4>
<p>同 <code>max</code> 和 <code>min</code> 一样，只是它们使用自定义的比较函数，例如：</p>
<div class="note danger"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line">    <span class="comment">// Compare two f64 values. Panic if given a NaN.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp</span>(lhs: &amp;<span class="type">f64</span>, rhs: &amp;<span class="type">f64</span>) <span class="punctuation">-&gt;</span> Ordering &#123;</span><br><span class="line">        lhs.<span class="title function_ invoke__">partial_cmp</span>(rhs).<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">max_by</span>(cmp), <span class="title function_ invoke__">Some</span>(<span class="number">4.0</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">min_by</span>(cmp), <span class="title function_ invoke__">Some</span>(<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1.0</span>, <span class="number">4.0</span>, std::<span class="type">f64</span>::NAN, <span class="number">2.0</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">copied</span>().<span class="title function_ invoke__">max_by</span>(cmp), <span class="title function_ invoke__">Some</span>(<span class="number">4.0</span>)); <span class="comment">// panics</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="max_by_key-min_by_key"><a class="markdownIt-Anchor" href="#max_by_key-min_by_key"></a> <code>max_by_key</code>、<code>min_by_key</code></h4>
<p><code>max_by_key</code> 和<code>min_by_key</code> 通过传入的闭包选择根据 <code>item</code> 的某些内容来确定最大最小值，它们的定义如下，传入的闭包返回 <code>None</code> 表示这个 <code>item</code> 不参与比较：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">min_by_key</span>&lt;B: <span class="built_in">Ord</span>, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">max_by_key</span>&lt;B: <span class="built_in">Ord</span>, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> B;</span><br></pre></td></tr></table></figure>
<p>举个例子，根据 <code>HashMap</code> 的值进行比较：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">populations</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Portland&quot;</span>, <span class="number">583_776</span>);</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Fossil&quot;</span>, <span class="number">449</span>);</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Greenhorn&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Boring&quot;</span>, <span class="number">7_762</span>);</span><br><span class="line">    populations.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;The Dalles&quot;</span>, <span class="number">15_340</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        populations.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">max_by_key</span>(|&amp;(_name, pop)| pop),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>((&amp;<span class="string">&quot;Portland&quot;</span>, &amp;<span class="number">583_776</span>))</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        populations.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">min_by_key</span>(|&amp;(_name, pop)| pop),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>((&amp;<span class="string">&quot;Greenhorn&quot;</span>, &amp;<span class="number">2</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="item-序列比较"><a class="markdownIt-Anchor" href="#item-序列比较"></a> <code>item</code> 序列比较</h4>
<p>可以使用 <code>&lt;</code>，<code>==</code> 等比较运算符比较 <code>str</code>，<code>vector</code> 或者 <code>slice</code>，只要它们的 <code>item</code> 支持比较，除此之外还可以使用 <code>eq</code>，<code>lt</code> 等方法进行比较：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">packed</span> = <span class="string">&quot;Helen of Troy&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaced</span> = <span class="string">&quot;Helen   of    Troy&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">obscure</span> = <span class="string">&quot;Helen of Sandusky&quot;</span>; <span class="comment">// nice person, just not famous</span></span><br><span class="line">    <span class="built_in">assert!</span>(packed != spaced);</span><br><span class="line">    <span class="built_in">assert!</span>(packed.<span class="title function_ invoke__">split_whitespace</span>().<span class="title function_ invoke__">eq</span>(spaced.<span class="title function_ invoke__">split_whitespace</span>()));</span><br><span class="line">    <span class="comment">// This is true because &#x27; &#x27; &lt; &#x27;o&#x27;.</span></span><br><span class="line">    <span class="built_in">assert!</span>(spaced &lt; obscure);</span><br><span class="line">    <span class="comment">// This is true because &#x27;Troy&#x27; &gt; &#x27;Sandusky&#x27;.</span></span><br><span class="line">    <span class="built_in">assert!</span>(spaced.<span class="title function_ invoke__">split_whitespace</span>().<span class="title function_ invoke__">gt</span>(obscure.<span class="title function_ invoke__">split_whitespace</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>split_whitespace</code> 使用空格分割字符串生成字符串序列，然后比较字符串而不是按字符比较。</p>
<h4 id="any-all"><a class="markdownIt-Anchor" href="#any-all"></a> <code>any</code>、<code>all</code></h4>
<p><code>any</code> 和 <code>all</code> 引用传入的返回 <code>bool</code> 的函数，判断迭代器的 <code>item</code> 是否存在满足条件还是都满足条件：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span> = <span class="string">&quot;Iterator&quot;</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(id.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">any</span>(<span class="type">char</span>::is_uppercase));</span><br><span class="line">    <span class="built_in">assert!</span>(!id.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">all</span>(<span class="type">char</span>::is_uppercase));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="position-rposition-exactsizeiterator"><a class="markdownIt-Anchor" href="#position-rposition-exactsizeiterator"></a> <code>position</code>、<code>rposition</code>、<code>ExactSizeIterator</code></h4>
<p><code>position</code> 和 <code>rposition</code> 都是用于从迭代器序列中查找满足条件元素的索引，只是一个从左往右，一个从右往左。如果查找到满足条件的返回 <code>Some(v)</code>，否则返回 <code>None</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;Xerxes&quot;</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(text.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">position</span>(|c| c == <span class="string">&#x27;e&#x27;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(text.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">position</span>(|c| c == <span class="string">&#x27;z&#x27;</span>), <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">bytes</span> = <span class="string">b&quot;Xerxes&quot;</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rposition</span>(|&amp;c| c == <span class="string">b&#x27;e&#x27;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rposition</span>(|&amp;c| c == <span class="string">b&#x27;X&#x27;</span>), <span class="title function_ invoke__">Some</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p><code>rposition</code> 需要满足的条件更多，他要求迭代器必须是可反转的，并且是取得其精确长度，需要实现 <code>std::iter::ExactSizeIterator</code> :</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">ExactSizeIterator</span>: <span class="built_in">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">len</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">is_empty</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>len</code> 方法返回剩余的项目数，如果迭代完成，<code>is_empty</code> 方法返回 <code>true</code>。</p>
<h4 id="fold-rfold"><a class="markdownIt-Anchor" href="#fold-rfold"></a> <code>fold</code>、<code>rfold</code></h4>
<p><code>fold</code> 方法是一个非常通用的工具，用于在迭代器产生的整个项目序列上累积某种结果。给定一个我们称为累计值的初始值和一个闭包，<code>fold</code>重复地将闭包应用于当前累计值和迭代器的下一<code>item</code>。闭包返回的值作为新的累计值，与下一<code>item</code>一起传递给闭包。</p>
<p><code>sum</code>，<code>count</code>，<code>product</code> 以及 <code>max</code> 都可以用 <code>fold</code> 来实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |n, _| n + <span class="number">1</span>), <span class="number">6</span>); <span class="comment">// count</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |n, i| n + i), <span class="number">45</span>); <span class="comment">// sum</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">1</span>, |n, i| n * i), <span class="number">151200</span>); <span class="comment">// product</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// max</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">fold</span>(<span class="type">i32</span>::<span class="title function_ invoke__">min_value</span>(), std::cmp::max), <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fold</code> 的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fold</span>&lt;A, F&gt;(<span class="keyword">self</span>, init: A, f: F) <span class="punctuation">-&gt;</span> A</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>, F: <span class="title function_ invoke__">FnMut</span>(A, <span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> A;</span><br></pre></td></tr></table></figure>
<p>这里，<code>A</code> 是累计值类型。<code>init</code> 参数是一个 <code>A</code>，闭包的第一个参数和返回值以及 <code>fold</code> 本身的返回值也是如此。请注意，累计值被移入和移出闭包，因此可以将 <code>fold</code> 与非 <code>Copy</code> 累计值类型一起使用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [</span><br><span class="line">        <span class="string">&quot;Pack&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="string">&quot;box&quot;</span>, <span class="string">&quot;with&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;dozen&quot;</span>, <span class="string">&quot;liquor&quot;</span>, <span class="string">&quot;jugs&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="comment">// See also: the `join` method on slices, which won&#x27;t</span></span><br><span class="line">    <span class="comment">// give you that extra space at the end.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pangram</span> = a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="type">String</span>::<span class="title function_ invoke__">new</span>(), |s, w| s + w + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(pangram, <span class="string">&quot;Pack my box with five dozen liquor jugs &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rfold</code> 作用类似，它要求迭代器是可以从右往左进行迭代：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">weird_pangram</span> = a.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">rfold</span>(<span class="type">String</span>::<span class="title function_ invoke__">new</span>(), |s, w| s + w + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(weird_pangram, <span class="string">&quot;jugs liquor dozen five with box my Pack &quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="try_fold-try_rfold"><a class="markdownIt-Anchor" href="#try_fold-try_rfold"></a> <code>try_fold</code>、<code>try_rfold</code></h4>
<p><code>try_fold</code> 方法与 <code>fold</code> 相同，只是迭代过程可以提前退出，而不会消耗迭代器中的所有值。传递给 <code>try_fold</code> 的闭包必须返回一个 <code>Result</code>：如果它返回 <code>Err(e)</code>，<code>try_fold</code> 会立即返回 <code>Err(e)</code> 作为它的值，否则它继续继续处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::error::Error;</span><br><span class="line">    <span class="keyword">use</span> std::io::prelude::*;</span><br><span class="line">    <span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stdin</span> = std::io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">sum</span> = stdin</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">            .<span class="title function_ invoke__">try_fold</span>(<span class="number">0</span>, |sum, line| <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">u64</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(sum + <span class="type">u64</span>::<span class="title function_ invoke__">from_str</span>(&amp;line?.<span class="title function_ invoke__">trim</span>())?)</span><br><span class="line">            &#125;)?;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, sum);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>try_fold</code> 非常灵活，它被用来实现 <code>Iterator</code> 的许多其他消费者方法。 例如这是 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/src/core/iter/traits/iterator.rs.html#2452-2455"><code>all</code></a>的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">all</span>&lt;F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#[inline]</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">check</span>&lt;T&gt;(<span class="keyword">mut</span> f: <span class="keyword">impl</span> <span class="title class_">FnMut</span>(T) <span class="punctuation">-&gt;</span> <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>((), T) <span class="punctuation">-&gt;</span> ControlFlow&lt;()&gt; &#123;</span><br><span class="line">            <span class="keyword">move</span> |(), x| &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="title function_ invoke__">f</span>(x) &#123; ControlFlow::CONTINUE &#125; <span class="keyword">else</span> &#123; ControlFlow::BREAK &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">try_fold</span>((), <span class="title function_ invoke__">check</span>(f)) == ControlFlow::CONTINUE</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="nth-nth_back"><a class="markdownIt-Anchor" href="#nth-nth_back"></a> <code>nth</code>、<code>nth_back</code></h4>
<p><code>nth(n)</code> 从迭代器中跳过 <code>n</code> 个 <code>item</code> 返回下一个，<code>nth(0)</code> 等价于 <code>.next()</code>，而且它没有获取迭代器的所有权，所以可以多次调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">squares</span> = (<span class="number">0</span>..<span class="number">10</span>).<span class="title function_ invoke__">map</span>(|i| i*i);</span><br><span class="line"><span class="built_in">assert_eq!</span>(squares.<span class="title function_ invoke__">nth</span>(<span class="number">4</span>), <span class="title function_ invoke__">Some</span>(<span class="number">16</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(squares.<span class="title function_ invoke__">nth</span>(<span class="number">0</span>), <span class="title function_ invoke__">Some</span>(<span class="number">25</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(squares.<span class="title function_ invoke__">nth</span>(<span class="number">6</span>), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure>
<p>它的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">nth</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, n: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br></pre></td></tr></table></figure>
<p><code>nth_back(n)</code> 需要一个可以双端迭代的迭代器，从后往前找，<code>.nth_back(0)</code> 等价于 <code>.nth_back(0)</code>。</p>
<h4 id="last"><a class="markdownIt-Anchor" href="#last"></a> <code>last</code></h4>
<p><code>last</code> 返回最后迭代器的最后一个元素，如果迭代器为空，返回 <code>None</code>，例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">squares</span> = (<span class="number">0</span>..<span class="number">10</span>).<span class="title function_ invoke__">map</span>(|i| i*i);</span><br><span class="line"><span class="built_in">assert_eq!</span>(squares.<span class="title function_ invoke__">last</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">81</span>));</span><br><span class="line">This consumes all the iterator’s items starti</span><br></pre></td></tr></table></figure>
<p>它的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">last</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br></pre></td></tr></table></figure>
<p>这个从前往后消费迭代器的所有<code>item</code>，即使它是可以 <code>reversible</code>，因此，如果你有一个 <code>reversible</code> 迭代器，而且不想消费所有 <code>item</code>，可以使用 <code>.next_back()</code>。</p>
<h4 id="find-rfind-find_map"><a class="markdownIt-Anchor" href="#find-rfind-find_map"></a> <code>find</code>、<code>rfind</code>、<code>find_map</code></h4>
<p><code>find</code> 依次将迭代器的 <code>item</code> 传入给定的闭包，返回第一个满足条件的，如果直到结束都没有找到，返回 <code>None</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find</span>&lt;P&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, predicate: P) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">    P: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br></pre></td></tr></table></figure>
<p><code>rfind</code> 要求迭代器必须是可以从后往前迭代，除此之外和 <code>find</code> 相同。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">289</span>, <span class="number">1234</span>, <span class="number">546</span>, <span class="number">19989</span>, <span class="number">878</span>, <span class="number">345</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find</span>(|&amp;item| *item &gt; <span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">rfind</span>(|&amp;item| *item &gt; <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>find_map</code> 可以对返回的值进行自定义，而不是迭代器中的类型，它的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">find_map</span>&lt;B, F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;B&gt; <span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>(<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;B&gt;;</span><br></pre></td></tr></table></figure>
<p>例如，对于上面的例子，我们可以在满足要求时，将返回值包装成 <code>Some(Number)</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    num: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">289</span>, <span class="number">1234</span>, <span class="number">546</span>, <span class="number">19989</span>, <span class="number">878</span>, <span class="number">345</span>];</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;&#123;:?&#125;&quot;</span>,</span><br><span class="line">        numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find_map</span>(|&amp;item| &#123;</span><br><span class="line">            <span class="keyword">if</span> item &gt; <span class="number">1000</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(Number &#123; num: item &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="collect-fromiterator"><a class="markdownIt-Anchor" href="#collect-fromiterator"></a> <code>collect</code>、<code>FromIterator</code></h4>
<p><code>collect</code> 可以从 <code>Rust</code> 的标准库构建任何类型的集合，只要迭代器产生合适的项目类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::&#123;HashSet, BTreeSet, LinkedList, HashMap, BTreeMap&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: HashSet&lt;<span class="type">String</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: BTreeSet&lt;<span class="type">String</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: LinkedList&lt;<span class="type">String</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collecting a map requires (key, value) pairs, so for this example,</span></span><br><span class="line"><span class="comment">// zip the sequence of strings with a sequence of integers.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: HashMap&lt;<span class="type">String</span>, <span class="type">usize</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">zip</span>(<span class="number">0</span>..).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">args</span>: BTreeMap&lt;<span class="type">String</span>, <span class="type">usize</span>&gt; = std::env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">zip</span>(<span class="number">0</span>..).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>
<p><code>collect</code> 本身并不知道如何构造所有这些类型。相反当一些像 <code>Vec</code> 或 <code>HashMap</code> 这样的集合类型知道如何从一个迭代器构造自己时，它实现了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html#"><code>std::iter::FromIterator</code></a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FromIterator</span>&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_iter</span>&lt;T&gt;(iter: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        T: <span class="built_in">IntoIterator</span>&lt;Item = A&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="extend"><a class="markdownIt-Anchor" href="#extend"></a> <code>extend</code></h4>
<p>如果一个类型实现了 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/trait.Extend.html"><code>std::iter::Extend</code></a>，<code>extend</code> 方法可以从另外一个可迭代的集合添加 <code>item</code> 到自身，它的声明如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Extend</span>&lt;A&gt; &#123;</span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">extend</span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, iter: T)</span><br><span class="line"> <span class="keyword">where</span> T: <span class="built_in">IntoIterator</span>&lt;Item=A&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有标准库的集合类型都实现了 <code>Extend</code>。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = (<span class="number">0</span>..<span class="number">5</span>).<span class="title function_ invoke__">map</span>(|i| <span class="number">1</span> &lt;&lt; i).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">v.<span class="title function_ invoke__">extend</span>(&amp;[<span class="number">31</span>, <span class="number">57</span>, <span class="number">99</span>, <span class="number">163</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v, &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">31</span>, <span class="number">57</span>, <span class="number">99</span>, <span class="number">163</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="partition"><a class="markdownIt-Anchor" href="#partition"></a> <code>partition</code></h4>
<p><code>partition</code> 通过传入的闭包将集合分成两拨，例如我们可以将切片数字分成奇数偶数序列：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">289</span>, <span class="number">1234</span>, <span class="number">546</span>, <span class="number">19989</span>, <span class="number">878</span>, <span class="number">345</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (base, even): (<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;, <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) = numbers.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">partition</span>(|n| *n &amp; <span class="number">1</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;&quot;</span>, base, even);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码输出：<br />
[10, 34, 1234, 546, 878], [9, 289, 19989, 345]</p>
<p>和 <code>collect</code> 一样，<code>partition</code> 可以创建任何你喜欢的集合，但是两者必须是相同的类型，使用上和 <code>collect</code> 一样，需要指定返回类型。<code>partition</code> 的签名如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">partition</span>&lt;B, F&gt;(<span class="keyword">self</span>, f: F) <span class="punctuation">-&gt;</span> (B, B)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        B: <span class="built_in">Default</span> + <span class="built_in">Extend</span>&lt;<span class="keyword">Self</span>::Item&gt;,</span><br><span class="line">        F: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">Self</span>::Item) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br></pre></td></tr></table></figure>
<h4 id="for_each-try_for_each"><a class="markdownIt-Anchor" href="#for_each-try_for_each"></a> <code>for_each</code>、<code>try_for_each</code></h4>
<p><code>for_each</code> 的用途和 <code>for</code> 相似，在其中也可使用 <code>break</code> 和 <code>continue</code> 这样的控制结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    [<span class="string">&quot;doves&quot;</span>, <span class="string">&quot;hens&quot;</span>, <span class="string">&quot;birds&quot;</span>]</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>([<span class="string">&quot;turtle&quot;</span>, <span class="string">&quot;french&quot;</span>, <span class="string">&quot;calling&quot;</span>].<span class="title function_ invoke__">iter</span>())</span><br><span class="line">        .<span class="title function_ invoke__">zip</span>(<span class="number">2</span>..<span class="number">5</span>)</span><br><span class="line">        .<span class="title function_ invoke__">rev</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|((item, kind), quantity)| <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, quantity, kind, item))</span><br><span class="line">        .for_each(|gift| &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;You have received: &#123;&#125;&quot;</span>, gift);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改代码输出：</p>
<pre><code>You have received: 4 calling birds
You have received: 3 french hens
You have received: 2 turtle doves
</code></pre>
<p>如果闭包可以失败，或者需要提前退出，可以使用 <code>try_for_each</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> .<span class="title function_ invoke__">try_for_each</span>(|gift| &#123;</span><br><span class="line">    <span class="built_in">writeln!</span>(&amp;<span class="keyword">mut</span> output_file, <span class="string">&quot;You have received: &#123;&#125;&quot;</span>, gift)</span><br><span class="line">&#125;)?;</span><br></pre></td></tr></table></figure>
<h3 id="实现迭代器"><a class="markdownIt-Anchor" href="#实现迭代器"></a> 实现迭代器</h3>
<p>可以为自己的类型实现 <code>IntoIterator</code> 和 <code>Iterator</code>，这样前面讲的所有方法都可以使用了，<code>for</code> 循环使用 <code>IntoIterator::into_iter</code> 将其操作数转换为迭代器。但是标准库为实现 <code>Iterator</code> 的每种类型提供了 <code>IntoIterator</code> 的全面实现，<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html#impl-IntoIterator-25">例如</a>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;I: <span class="built_in">Iterator</span>&gt; <span class="built_in">IntoIterator</span> <span class="keyword">for</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = I::Item;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">IntoIter</span> = I;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">into_iter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> I &#123;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个 <a target="_blank" rel="noopener" href="https://github.com/ProgrammingRust/examples/blob/master/binary-tree/src/lib.rs">BinaryTree</a> 的实现，</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="MichaelFu 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="MichaelFu 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>MichaelFu
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://blog.fudenglong.site/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="【Rust】迭代器">https://blog.fudenglong.site/2022/04/30/Rust/【Rust】迭代器/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E3%80%8ARust-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B/" rel="tag"># 《Rust 程序设计》</a>
              <a href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/" rel="tag"># 迭代器</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E9%97%AD%E5%8C%85/" rel="prev" title="【Rust】闭包">
                  <i class="fa fa-angle-left"></i> 【Rust】闭包
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/01/Rust/%E3%80%90Rust%E3%80%91%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/" rel="next" title="【Rust】集合类型">
                  【Rust】集合类型 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">辽ICP备15012817号-2 </a>
  </div>
  <div class="copyright">
    &copy; 2020 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MichaelFu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">465k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">28:11</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/gamelife1314" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/bookmark.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/pjax.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/search/local-search.min.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js"},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/tags/pdf.min.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":"dark","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js"}}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/tags/mermaid.min.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/fancybox.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/pace.min.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":false,"delay":true,"timeout":5000,"priority":true,"url":"https://blog.fudenglong.site/2022/04/30/Rust/%E3%80%90Rust%E3%80%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"}</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/quicklink.min.js"></script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"gamelife1314/gamelife1314.github.io","issue_term":"title","theme":"github-light"}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-next/8.21.1/third-party/comments/utterances.min.js"></script>

</body>
</html>
